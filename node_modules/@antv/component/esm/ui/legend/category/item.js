import { __assign, __extends, __read, __rest } from "tslib";
import { Circle, } from '@antv/g';
import { Marker } from '../../marker';
import { Component } from '../../../core';
import { classNames, copyAttributes, ellipsisIt, ifShow, parseSeriesAttr, renderExtDo, scaleToPixel, select, subStyleProps, } from '../../../util';
var CLASS_NAMES = classNames({
    layout: 'flex',
    markerGroup: 'marker-group',
    marker: 'marker',
    labelGroup: 'label-group',
    label: 'label',
    valueGroup: 'value-group',
    value: 'value',
    backgroundGroup: 'background-group',
    background: 'background',
}, 'legend-category-item');
function styleOfMarker(group) {
    var marker = group.querySelector(CLASS_NAMES.marker.class);
    if (marker)
        return marker.style;
    return {};
}
var CategoryItem = /** @class */ (function (_super) {
    __extends(CategoryItem, _super);
    function CategoryItem(options) {
        return _super.call(this, options, {
            span: [1, 1],
            marker: function () { return new Circle({ style: { r: 6 } }); },
            markerSize: 10,
            labelFill: '#646464',
            valueFill: '#646464',
            labelFontSize: 12,
            valueFontSize: 12,
            labelTextBaseline: 'middle',
            valueTextBaseline: 'middle',
        }) || this;
    }
    Object.defineProperty(CategoryItem.prototype, "showValue", {
        get: function () {
            var valueText = this.attributes.valueText;
            if (!valueText)
                return false;
            if (typeof valueText === 'string' || typeof valueText === 'number')
                return valueText !== '';
            if (typeof valueText === 'function')
                return true;
            return valueText.attr('text') !== '';
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryItem.prototype, "actualSpace", {
        get: function () {
            var label = this.labelGroup;
            var value = this.valueGroup;
            var markerSize = this.attributes.markerSize;
            var _a = label.node().getBBox(), labelWidth = _a.width, labelHeight = _a.height;
            var _b = value.node().getBBox(), valueWidth = _b.width, valueHeight = _b.height;
            return {
                markerWidth: markerSize,
                labelWidth: labelWidth,
                valueWidth: valueWidth,
                height: Math.max(markerSize, labelHeight, valueHeight),
            };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryItem.prototype, "span", {
        get: function () {
            var span = this.attributes.span;
            if (!span)
                return [1, 1];
            var _a = __read(parseSeriesAttr(span), 2), span1 = _a[0], innerSpan = _a[1];
            var span2 = this.showValue ? innerSpan : 0;
            var basis = span1 + span2;
            return [span1 / basis, span2 / basis];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryItem.prototype, "shape", {
        get: function () {
            var _a;
            var _b = this.attributes, markerSize = _b.markerSize, fullWidth = _b.width;
            var actualSpace = this.actualSpace;
            var markerWidth = actualSpace.markerWidth, height = actualSpace.height;
            var _c = this.actualSpace, labelWidth = _c.labelWidth, valueWidth = _c.valueWidth;
            var _d = __read(this.spacing, 2), spacing1 = _d[0], spacing2 = _d[1];
            if (fullWidth) {
                var width_1 = fullWidth - markerSize - spacing1 - spacing2;
                var _e = __read(this.span, 2), span1 = _e[0], span2 = _e[1];
                _a = __read([span1 * width_1, span2 * width_1], 2), labelWidth = _a[0], valueWidth = _a[1];
            }
            var width = markerWidth + labelWidth + valueWidth + spacing1 + spacing2;
            return { width: width, height: height, markerWidth: markerWidth, labelWidth: labelWidth, valueWidth: valueWidth };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryItem.prototype, "spacing", {
        get: function () {
            var spacing = this.attributes.spacing;
            if (!spacing)
                return [0, 0];
            var _a = __read(parseSeriesAttr(spacing), 2), spacing1 = _a[0], spacing2 = _a[1];
            if (this.showValue)
                return [spacing1, spacing2];
            return [spacing1, 0];
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryItem.prototype, "layout", {
        get: function () {
            var _a = this.shape, markerWidth = _a.markerWidth, labelWidth = _a.labelWidth, valueWidth = _a.valueWidth, width = _a.width, height = _a.height;
            var _b = __read(this.spacing, 2), spacing1 = _b[0], spacing2 = _b[1];
            return {
                height: height,
                width: width,
                markerWidth: markerWidth,
                labelWidth: labelWidth,
                valueWidth: valueWidth,
                position: [markerWidth / 2, markerWidth + spacing1, markerWidth + labelWidth + spacing1 + spacing2],
            };
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CategoryItem.prototype, "scaleSize", {
        get: function () {
            var markerShapeStyle = styleOfMarker(this.markerGroup.node());
            var _a = this.attributes, markerSize = _a.markerSize, _b = _a.markerStrokeWidth, markerStrokeWidth = _b === void 0 ? markerShapeStyle.strokeWidth : _b, _c = _a.markerLineWidth, markerLineWidth = _c === void 0 ? markerShapeStyle.lineWidth : _c, _d = _a.markerStroke, markerStroke = _d === void 0 ? markerShapeStyle.stroke : _d;
            // empirical value
            var strokeWidth = +(markerStrokeWidth || markerLineWidth || (markerStroke ? 1 : 0)) * Math.sqrt(2);
            var _e = this.markerGroup.node().getBBox(), width = _e.width, height = _e.height;
            return (1 - strokeWidth / Math.max(width, height)) * markerSize;
        },
        enumerable: false,
        configurable: true
    });
    CategoryItem.prototype.renderMarker = function (container) {
        var _this = this;
        var marker = this.attributes.marker;
        var style = subStyleProps(this.attributes, 'marker');
        this.markerGroup = container.maybeAppendByClassName(CLASS_NAMES.markerGroup, 'g').style('zIndex', 0);
        ifShow(!!marker, this.markerGroup, function () {
            var _a;
            var parent = _this.markerGroup.node();
            var oldMarker = (_a = parent.childNodes) === null || _a === void 0 ? void 0 : _a[0];
            var newMarker = typeof marker === 'string'
                ? new Marker({ style: { symbol: marker }, className: CLASS_NAMES.marker.name })
                : marker();
            if (!oldMarker) {
                if (!(newMarker instanceof Marker))
                    select(newMarker).attr('className', CLASS_NAMES.marker.name).styles(style);
                parent.appendChild(newMarker);
            }
            else if (newMarker.nodeName === oldMarker.nodeName) {
                if (oldMarker instanceof Marker)
                    oldMarker.update(__assign(__assign({}, style), { symbol: marker }));
                else {
                    copyAttributes(oldMarker, newMarker);
                    select(oldMarker).styles(style);
                }
            }
            else {
                oldMarker.remove();
                select(newMarker).attr('className', CLASS_NAMES.marker.name).styles(style);
                parent.appendChild(newMarker);
            }
            // record the scale of marker
            _this.markerGroup.node().scale(1 / _this.markerGroup.node().getScale()[0]);
            var scale = scaleToPixel(_this.markerGroup.node(), _this.scaleSize, true);
            _this.markerGroup.node().style._transform = "scale(".concat(scale, ")");
        });
    };
    CategoryItem.prototype.renderLabel = function (container) {
        var _a = subStyleProps(this.attributes, 'label'), label = _a.text, style = __rest(_a, ["text"]);
        this.labelGroup = container.maybeAppendByClassName(CLASS_NAMES.labelGroup, 'g').style('zIndex', 0);
        this.labelGroup.maybeAppendByClassName(CLASS_NAMES.label, function () { return renderExtDo(label); }).styles(style);
    };
    CategoryItem.prototype.renderValue = function (container) {
        var _this = this;
        var _a = subStyleProps(this.attributes, 'value'), value = _a.text, style = __rest(_a, ["text"]);
        this.valueGroup = container.maybeAppendByClassName(CLASS_NAMES.valueGroup, 'g').style('zIndex', 0);
        ifShow(this.showValue, this.valueGroup, function () {
            _this.valueGroup.maybeAppendByClassName(CLASS_NAMES.value, function () { return renderExtDo(value); }).styles(style);
        });
    };
    CategoryItem.prototype.renderBackground = function (container) {
        var _a = this.shape, width = _a.width, height = _a.height;
        var style = subStyleProps(this.attributes, 'background');
        this.background = container.maybeAppendByClassName(CLASS_NAMES.backgroundGroup, 'g').style('zIndex', -1);
        this.background.maybeAppendByClassName(CLASS_NAMES.background, 'rect').styles(__assign({ width: width, height: height }, style));
    };
    CategoryItem.prototype.adjustLayout = function () {
        var _a = this.layout, labelWidth = _a.labelWidth, valueWidth = _a.valueWidth, height = _a.height, _b = __read(_a.position, 3), markerX = _b[0], labelX = _b[1], valueX = _b[2];
        var halfHeight = height / 2;
        // console.log(this.markerGroup.node().style._transform);
        this.markerGroup.styles({
            transform: "translate(".concat(markerX, ", ").concat(halfHeight, ")").concat(this.markerGroup.node().style._transform),
        });
        this.labelGroup.styles({ transform: "translate(".concat(labelX, ", ").concat(halfHeight, ")") });
        ellipsisIt(this.labelGroup.select(CLASS_NAMES.label.class).node(), Math.ceil(labelWidth));
        if (this.showValue) {
            this.valueGroup.styles({ transform: "translate(".concat(valueX, ", ").concat(halfHeight, ")") });
            ellipsisIt(this.valueGroup.select(CLASS_NAMES.value.class).node(), Math.ceil(valueWidth));
        }
    };
    CategoryItem.prototype.render = function (attributes, container) {
        var ctn = select(container);
        var _a = attributes.x, x = _a === void 0 ? 0 : _a, _b = attributes.y, y = _b === void 0 ? 0 : _b;
        ctn.styles({ transform: "translate(".concat(x, ", ").concat(y, ")") });
        this.renderMarker(ctn);
        this.renderLabel(ctn);
        this.renderValue(ctn);
        this.renderBackground(ctn);
        this.adjustLayout();
    };
    return CategoryItem;
}(Component));
export { CategoryItem };
//# sourceMappingURL=item.js.map
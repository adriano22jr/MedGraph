"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var line_1 = require("../guides/line");
var test_1 = require("../utils/test");
function inferTextBaseline(attr) {
    var type = attr.type, labelDirection = attr.labelDirection;
    if (type === 'linear' && (0, line_1.isAxisHorizontal)(attr)) {
        return labelDirection === 'negative' ? 'bottom' : 'top';
    }
    return 'middle';
}
function wrapLabels(labels, overlapCfg, attr, utils) {
    var _a = overlapCfg.wordWrapWidth, wordWrapWidth = _a === void 0 ? 50 : _a, _b = overlapCfg.maxLines, maxLines = _b === void 0 ? 3 : _b, _c = overlapCfg.recoverWhenFailed, recoverWhenFailed = _c === void 0 ? true : _c, _d = overlapCfg.margin, margin = _d === void 0 ? [0, 0, 0, 0] : _d;
    var defaultLines = labels.map(function (label) { return label.attr('maxLines') || 1; });
    var minLines = Math.min.apply(Math, tslib_1.__spreadArray([], tslib_1.__read(defaultLines), false));
    var runAndPassed = function () { return (0, test_1.boundTest)(labels, attr, margin).length < 1; };
    var textBaseline = inferTextBaseline(attr);
    var setLabelsWrap = function (lines) {
        return labels.forEach(function (label, index) {
            var maxLines = Array.isArray(lines) ? lines[index] : lines;
            utils.wrap(label, wordWrapWidth, maxLines, textBaseline);
        });
    };
    if (minLines > maxLines)
        return;
    for (var lines = minLines; lines <= maxLines; lines++) {
        setLabelsWrap(lines);
        if (runAndPassed())
            return;
    }
    if (recoverWhenFailed) {
        setLabelsWrap(defaultLines);
    }
}
exports.default = wrapLabels;
//# sourceMappingURL=autoWrap.js.map
import type { Tuple4Number } from '@antv/g-lite';
import EventEmitter from 'eventemitter3';
import type { Mesh } from '../Mesh';
import type { BlendFactor, BlendMode, Color, CompareFunction, CullMode, Device, Format, FrontFace, StencilFaceState, Texture } from '@antv/g-device-api';
export interface IMaterial {
    cullMode: CullMode;
    blendConstant: Color;
    blendEquation: BlendMode;
    blendEquationAlpha: BlendMode;
    blendSrc: BlendFactor;
    blendDst: BlendFactor;
    blendSrcAlpha: BlendFactor;
    blendDstAlpha: BlendFactor;
    depthCompare: CompareFunction;
    depthTest: boolean;
    depthWrite: boolean;
    stencilFront: Partial<StencilFaceState>;
    stencilBack: Partial<StencilFaceState>;
    stencilWrite: boolean;
    stencilRef: number;
    frontFace: FrontFace;
    polygonOffset: boolean;
    dithering: boolean;
    wireframe: boolean;
    wireframeColor: string;
    wireframeLineWidth: number;
    vertexShader: string;
    fragmentShader: string;
}
type MaterialUniformData = number | [number] | [number, number] | [number, number, number] | Tuple4Number | [
    [
        number,
        number
    ],
    [
        number,
        number
    ]
] | [
    [
        number,
        number,
        number
    ],
    [
        number,
        number,
        number
    ],
    [
        number,
        number,
        number
    ]
] | [
    [
        number,
        number,
        number,
        number
    ],
    [
        number,
        number,
        number,
        number
    ],
    [
        number,
        number,
        number,
        number
    ],
    [
        number,
        number,
        number,
        number
    ]
];
export interface MaterialUniform {
    name: string;
    format: Format;
    data: MaterialUniformData;
    offset?: number;
    size?: number;
}
export declare enum MaterialEvent {
    CHANGED = "changed"
}
/**
 * an encapsulation on top of shaders
 * @see https://doc.babylonjs.com/divingDeeper/materials/using/materials_introduction
 */
export declare abstract class Material<T extends IMaterial = any> extends EventEmitter {
    protected device: Device;
    protected props: T;
    /**
     * relative meshes
     */
    meshes: Mesh[];
    /**
     * cullFace
     */
    get cullMode(): CullMode;
    set cullMode(value: CullMode);
    get frontFace(): FrontFace;
    set frontFace(value: FrontFace);
    /**
     * Blending state
     */
    get blendConstant(): Color;
    set blendConstant(value: Color);
    get blendEquation(): BlendMode;
    set blendEquation(value: BlendMode);
    get blendEquationAlpha(): BlendMode;
    set blendEquationAlpha(value: BlendMode);
    get blendSrc(): BlendFactor;
    set blendSrc(value: BlendFactor);
    get blendDst(): BlendFactor;
    set blendDst(value: BlendFactor);
    get blendSrcAlpha(): BlendFactor;
    set blendSrcAlpha(value: BlendFactor);
    get blendDstAlpha(): BlendFactor;
    set blendDstAlpha(value: BlendFactor);
    get depthCompare(): CompareFunction;
    set depthCompare(value: CompareFunction);
    get depthTest(): boolean;
    set depthTest(value: boolean);
    get depthWrite(): boolean;
    set depthWrite(value: boolean);
    get stencilFront(): Partial<StencilFaceState>;
    set stencilFront(value: Partial<StencilFaceState>);
    get stencilBack(): Partial<StencilFaceState>;
    set stencilBack(value: Partial<StencilFaceState>);
    get stencilWrite(): boolean;
    set stencilWrite(value: boolean);
    get stencilRef(): number;
    set stencilRef(value: number);
    get polygonOffset(): boolean;
    set polygonOffset(value: boolean);
    get dithering(): boolean;
    set dithering(value: boolean);
    get wireframe(): boolean;
    set wireframe(value: boolean);
    get wireframeColor(): string;
    set wireframeColor(value: string);
    get wireframeLineWidth(): number;
    set wireframeLineWidth(value: number);
    get vertexShader(): string;
    set vertexShader(value: string);
    get fragmentShader(): string;
    set fragmentShader(value: string);
    defines: Record<string, number | boolean | string>;
    uniforms: Record<string, number | number[] | Float32Array>;
    uniformNames: string[];
    uboBuffer: number[];
    textures: Record<string, Texture>;
    samplers: string[];
    /**
     * need re-compiling like vs/fs changed
     */
    programDirty: boolean;
    /**
     * need re-upload textures
     */
    textureDirty: boolean;
    /**
     * inform geometry to rebuild, eg. wireframe
     */
    geometryDirty: boolean;
    constructor(device: Device, props: Partial<IMaterial>);
    private compile;
    /**
     * @example
     * material.setUniforms({
     *   u_ModelMatrix: [1, 2, 3, 4],
     *   u_Time: 1,
     *   u_Map: texture,
     * })
     */
    setUniforms(uniforms: Record<string, null | number | number[] | Float32Array | Texture>): void;
    private dispatchMutationEvent;
}
export {};

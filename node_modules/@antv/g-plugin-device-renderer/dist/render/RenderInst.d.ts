import type { IndexBufferDescriptor, InputLayout, MegaStateDescriptor, Program, RenderPass, RenderPipelineDescriptor, SamplerBinding, VertexBufferDescriptor } from '@antv/g-device-api';
import type { DynamicUniformBuffer } from './DynamicUniformBuffer';
import type { RenderCache } from './RenderCache';
export declare enum RenderInstFlags {
    None = 0,
    Indexed = 1,
    AllowSkippingIfPipelineNotReady = 2,
    Template = 4,
    Draw = 8,
    InheritedFlags = 3
}
export interface RenderInstUniform {
    name: string;
    value: number | number[] | Float32Array;
}
export declare class RenderInst {
    sortKey: number;
    debug: any;
    renderPipelineDescriptor: RenderPipelineDescriptor;
    private uniformBuffer;
    uniforms: RenderInstUniform[][];
    private bindingDescriptors;
    private dynamicUniformBufferByteOffsets;
    flags: RenderInstFlags;
    private vertexBuffers;
    private indexBuffer;
    private drawStart;
    private drawCount;
    private drawInstanceCount;
    constructor();
    /**
     * Resets a render inst to be boring, so it can re-enter the pool.
     * Normally, you should not need to call this.
     */
    reset(): void;
    /**
     * Copies the fields from another render inst {@param o} to this render inst.
     * Normally, you should not need to call this.
     */
    setFromTemplate(o: RenderInst): void;
    validate(): void;
    /**
     * Set the {@see Program} that this render inst will render with. This is part of the automatic
     * pipeline building facilities. At render time, a pipeline will be automatically and constructed from
     * the pipeline parameters.
     */
    setProgram(program: Program): void;
    /**
     * Set the {@see MegaStateDescriptor} that this render inst will render with. This is part of the automatic
     * pipeline building facilities. At render time, a pipeline will be automatically and constructed from
     * the pipeline parameters.
     */
    setMegaStateFlags(r: Partial<MegaStateDescriptor>): MegaStateDescriptor;
    /**
     * Retrieve the {@see MegaStateDescriptor} property bag that this will render with. This is similar to
     * {@see setMegaStateFlags} but allows you to set fields directly on the internal property bag, rather than
     * merge them. This can be slightly more efficient.
     */
    getMegaStateFlags(): MegaStateDescriptor;
    /**
     * Sets the vertex input configuration to be used by this render instance.
     * The {@see InputLayout} is used to construct the pipeline as part of the automatic pipeline building
     * facilities, while the {@see VertexBufferDescriptor} and {@see IndexBufferDescriptor} is used for the render.
     */
    setVertexInput(inputLayout: InputLayout | null, vertexBuffers: (VertexBufferDescriptor | null)[] | null, indexBuffer: IndexBufferDescriptor | null): void;
    setBindingLayout(bindingLayout: {
        numUniformBuffers: number;
        numSamplers: number;
    }): void;
    drawIndexes(indexCount: number, indexStart?: number): void;
    drawIndexesInstanced(indexCount: number, instanceCount: number, indexStart?: number): void;
    drawPrimitives(primitiveCount: number, primitiveStart?: number): void;
    /**
     * account for WebGL1
     */
    setUniforms(bufferIndex: number, uniforms: RenderInstUniform[]): void;
    setUniformBuffer(uniformBuffer: DynamicUniformBuffer): void;
    /**
     * Allocates {@param wordCount} words from the uniform buffer and assigns it to the buffer
     * slot at index {@param bufferIndex}. As a convenience, this also directly returns the same
     * offset into the uniform buffer, in words, that would be returned by a subsequent call to
     * {@see getUniformBufferOffset}.
     */
    allocateUniformBuffer(bufferIndex: number, wordCount: number): number;
    /**
     * Returns the offset into the uniform buffer, in words, that is assigned to the buffer slot
     * at index {@param bufferIndex}, to be used with e.g. {@see mapUniformBufferF32}.
     */
    getUniformBufferOffset(bufferIndex: number): number;
    /**
     * This is a convenience wrapper for {@see RenderDynamicUniformBuffer.mapBufferF32}, but uses
     * the values previously assigned for the uniform buffer slot at index {@param bufferIndex}.
     * Like {@see RenderDynamicUniformBuffer.mapBufferF32}, this does not return a slice for the
     * buffer; you need to write to it with the correct uniform buffer offset; this will usually be
     * returned by {@see allocateUniformBuffer}.
     */
    mapUniformBufferF32(bufferIndex: number): Float32Array;
    /**
     * Retrieve the {@see RenderDynamicUniformBuffer} that this render inst will use to allocate.
     */
    getUniformBuffer(): DynamicUniformBuffer;
    /**
     * Sets the {@param SamplerBinding}s in use by this render instance.
     *
     * Note that {@see RenderInst} has a method of doing late binding, intended to solve cases where live render
     * targets are used, which can have difficult control flow consequences for users. Pass a string instead of a
     * SamplerBinding to record that it can be resolved later, and use {@see RenderInst.resolveLateSamplerBinding}
     * or equivalent to fill it in later.
     */
    setSamplerBindingsFromTextureMappings(mappings: (SamplerBinding | null)[]): void;
    /**
     * Sets whether this render inst should be skipped if the render pipeline isn't ready.
     *
     * Some draws of objects can be skipped if the pipelines aren't ready. Others are more
     * crucial to draw, and so this can be set to force for the pipeline to become available.
     *
     * By default, this is true.
     */
    setAllowSkippingIfPipelineNotReady(v: boolean): void;
    private setAttachmentFormatsFromRenderPass;
    drawOnPass(cache: RenderCache, passRenderer: RenderPass): boolean;
}

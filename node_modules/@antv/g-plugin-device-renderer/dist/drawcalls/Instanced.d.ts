import type { DisplayObject } from '@antv/g-lite';
import { BufferGeometry } from '../geometries';
import type { LightPool } from '../LightPool';
import type { Material } from '../materials';
import type { RenderInst, RenderHelper } from '../render';
import { TextureMapping } from '../render';
import type { BatchContext } from '../renderer';
import type { Batch } from '../renderer/Batch';
import type { TexturePool } from '../TexturePool';
export declare const FILL_TEXTURE_MAPPING = "FillTextureMapping";
/**
 * WebGPU has max vertex attribute num(8)
 */
export declare enum VertexAttributeBufferIndex {
    MODEL_MATRIX = 0,
    PACKED_COLOR = 1,
    PACKED_STYLE = 2,
    PICKING_COLOR = 3,// built-in
    POSITION = 4,
    NORMAL = 5,
    UV = 6,
    BARYCENTRIC = 7,
    MAX = 8
}
/**
 * GL.MAX_VERTEX_ATTRIBS
 */
export declare enum VertexAttributeLocation {
    MODEL_MATRIX0 = 0,
    MODEL_MATRIX1 = 1,
    MODEL_MATRIX2 = 2,
    MODEL_MATRIX3 = 3,
    PACKED_COLOR = 4,// fill & stroke
    PACKED_STYLE1 = 5,// opacity fillOpacity strokeOpacity lineWidth
    PACKED_STYLE2 = 6,// visibility anchorX anchorY increasedLineWidthForHitTesting
    PICKING_COLOR = 7,
    POSITION = 8,
    NORMAL = 9,
    UV = 10,
    BARYCENTRIC = 11,
    MAX = 12
}
/**
 * Draw call.
 */
export declare abstract class Instanced {
    protected renderHelper: RenderHelper;
    protected texturePool: TexturePool;
    protected lightPool: LightPool;
    /**
     * All drawcall constructors.
     */
    protected drawcallCtors: (new (..._: any) => Instanced)[];
    /**
     * index in renderer.meshes
     */
    index: number;
    context: BatchContext;
    /**
     * unique ID
     */
    id: number;
    renderer: Batch;
    /**
     * assigned by user which help BatchManager deciding whether to merge,
     * e.g. `will-change` property in CSS
     */
    key: string;
    /**
     * attribute name used for gradient or pattern
     */
    gradientAttributeName: 'stroke' | 'fill';
    constructor(renderHelper: RenderHelper, texturePool: TexturePool, lightPool: LightPool, object: DisplayObject, 
    /**
     * All drawcall constructors.
     */
    drawcallCtors: (new (..._: any) => Instanced)[], 
    /**
     * index in renderer.meshes
     */
    index: number, context: BatchContext);
    /**
     * instances
     */
    objects: DisplayObject[];
    material: Material;
    geometry: BufferGeometry;
    clipPath: DisplayObject;
    clipPathTarget: DisplayObject;
    private program;
    geometryDirty: boolean;
    /**
     * the same material maybe shared between different canvases
     */
    materialDirty: boolean;
    /**
     * texture mappings
     */
    protected textureMappings: TextureMapping[];
    /**
     * Divisor of instanced array.
     */
    protected divisor: number;
    /**
     * Account for anchor and merge it into modelMatrix.
     */
    protected mergeXYZIntoModelMatrix: boolean;
    protected checkNodeName: boolean;
    /**
     * Create a new batch if the number of instances exceeds.
     */
    maxInstances: number;
    protected abstract createMaterial(objects: DisplayObject[]): void;
    get instance(): DisplayObject<any, any>;
    inited: boolean;
    init(): void;
    observeGeometryChanged(): void;
    observeMaterialChanged(): void;
    private shouldMergeColor;
    /**
     * should be merged into current InstancedMesh
     */
    shouldMerge(object: DisplayObject, index: number): boolean;
    protected createGeometry(objects: DisplayObject[]): void;
    destroy(): void;
    applyRenderInst(renderInst: RenderInst, objects: DisplayObject[]): void;
    /**
     * update a continuous GPU buffer
     */
    protected updateBatchedAttribute(objects: DisplayObject[], startIndex: number, name: string, value: any): void;
    updateAttribute(objects: DisplayObject[], startIndex: number, name: string, value: any): void;
    changeRenderOrder(object: DisplayObject, renderOrder: number): void;
    private generateWireframe;
    protected beforeUploadUBO(renderInst: RenderInst, objects: DisplayObject[]): void;
    private uploadUBO;
    private uploadFog;
    private uploadMaterial;
    protected createFillGradientTextureMapping(objects: DisplayObject[]): TextureMapping | null;
}

import { isFunction, isNumber, isObject } from '@antv/util';
/**
 * Format value with multiple types into a function returns number.
 * @param defaultValue default value when value is invalid
 * @param value value to be formatted
 * @returns formatted result, a function returns number
 */
export function formatNumberFn(defaultValue, value) {
    let resultFunc;
    if (isFunction(value)) {
        resultFunc = value;
    }
    else if (isNumber(value)) {
        // value is number
        resultFunc = () => value;
    }
    else {
        // value is not number and function
        resultFunc = () => defaultValue;
    }
    return resultFunc;
}
/**
 * Format size config with multiple types into a function returns number
 * @param defaultValue default value when value is invalid
 * @param value value to be formatted
 * @param resultIsNumber whether returns number
 * @returns formatted result, a function returns number
 */
export function formatSizeFn(defaultValue, value, resultIsNumber = true) {
    if (!value && value !== 0) {
        return (d) => {
            const { size } = d.data || {};
            if (size) {
                if (Array.isArray(size)) {
                    return size[0] > size[1] ? size[0] : size[1];
                }
                if (isObject(size)) {
                    return size.width > size.height ? size.width : size.height;
                }
                return size;
            }
            return defaultValue;
        };
    }
    if (isFunction(value)) {
        return value;
    }
    if (isNumber(value)) {
        return () => value;
    }
    if (Array.isArray(value)) {
        return () => {
            if (resultIsNumber) {
                const max = Math.max(...value);
                return isNaN(max) ? defaultValue : max;
            }
            return value;
        };
    }
    if (isObject(value)) {
        return () => {
            if (resultIsNumber) {
                const max = Math.max(value.width, value.height);
                return isNaN(max) ? defaultValue : max;
            }
            return [value.width, value.height];
        };
    }
    return () => defaultValue;
}
/**
 * format the props nodeSize and nodeSpacing to a function
 * @param nodeSize
 * @param nodeSpacing
 * @returns
 */
export const formatNodeSize = (nodeSize, nodeSpacing) => {
    let nodeSizeFunc;
    let nodeSpacingFunc;
    if (isNumber(nodeSpacing)) {
        nodeSpacingFunc = () => nodeSpacing;
    }
    else if (isFunction(nodeSpacing)) {
        nodeSpacingFunc = nodeSpacing;
    }
    else {
        nodeSpacingFunc = () => 0;
    }
    if (!nodeSize) {
        nodeSizeFunc = (d) => {
            var _a, _b;
            if ((_a = d.data) === null || _a === void 0 ? void 0 : _a.bboxSize) {
                return (Math.max(d.data.bboxSize[0], d.data.bboxSize[1]) + nodeSpacingFunc(d));
            }
            if ((_b = d.data) === null || _b === void 0 ? void 0 : _b.size) {
                if (Array.isArray(d.data.size)) {
                    return Math.max(d.data.size[0], d.data.size[1]) + nodeSpacingFunc(d);
                }
                const dataSize = d.data.size;
                if (isObject(dataSize)) {
                    const res = dataSize.width > dataSize.height ? dataSize.width : dataSize.height;
                    return res + nodeSpacingFunc(d);
                }
                return dataSize + nodeSpacingFunc(d);
            }
            return 10 + nodeSpacingFunc(d);
        };
    }
    else if (Array.isArray(nodeSize)) {
        nodeSizeFunc = (d) => {
            const res = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];
            return res + nodeSpacingFunc(d);
        };
    }
    else if (isFunction(nodeSize)) {
        nodeSizeFunc = nodeSize;
    }
    else {
        nodeSizeFunc = (d) => nodeSize + nodeSpacingFunc(d);
    }
    return nodeSizeFunc;
};
//# sourceMappingURL=function.js.map
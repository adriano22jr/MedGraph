import { __awaiter, __generator, __extends, __spreadArray, __read } from 'tslib';
import { setDOMSize, RenderReason, isBrowser, AbstractRendererPlugin, AbstractRenderer } from '@antv/g-lite';
import * as CanvasPathGenerator from '@antv/g-plugin-canvas-path-generator';
export { CanvasPathGenerator };
import * as CanvasPicker from '@antv/g-plugin-canvas-picker';
export { CanvasPicker };
import * as CanvasRenderer from '@antv/g-plugin-canvas-renderer';
export { CanvasRenderer };
import * as DomInteraction from '@antv/g-plugin-dom-interaction';
export { DomInteraction };
import * as HTMLRenderer from '@antv/g-plugin-html-renderer';
export { HTMLRenderer };
import * as ImageLoader from '@antv/g-plugin-image-loader';
export { ImageLoader };
import { isString } from '@antv/util';

var Canvas2DContextService = /** @class */ (function () {
    function Canvas2DContextService(context) {
        this.renderingContext = context.renderingContext;
        this.canvasConfig = context.config;
    }
    Canvas2DContextService.prototype.init = function () {
        var _a = this.canvasConfig, container = _a.container, canvas = _a.canvas;
        if (canvas) {
            this.$canvas = canvas;
            if (container &&
                canvas.parentElement !== container) {
                container.appendChild(canvas);
            }
            this.$container = canvas.parentElement;
            this.canvasConfig.container = this.$container;
        }
        else if (container) {
            // create container
            this.$container = isString(container)
                ? document.getElementById(container)
                : container;
            if (this.$container) {
                // create canvas
                var $canvas = document.createElement('canvas');
                this.$container.appendChild($canvas);
                if (!this.$container.style.position) {
                    this.$container.style.position = 'relative';
                }
                this.$canvas = $canvas;
            }
        }
        this.context = this.$canvas.getContext('2d');
        this.resize(this.canvasConfig.width, this.canvasConfig.height);
    };
    Canvas2DContextService.prototype.getContext = function () {
        return this.context;
    };
    Canvas2DContextService.prototype.getDomElement = function () {
        return this.$canvas;
    };
    Canvas2DContextService.prototype.getDPR = function () {
        return this.dpr;
    };
    Canvas2DContextService.prototype.getBoundingClientRect = function () {
        if (this.$canvas.getBoundingClientRect) {
            return this.$canvas.getBoundingClientRect();
        }
    };
    Canvas2DContextService.prototype.destroy = function () {
        // @ts-ignore
        if (this.$container && this.$canvas && this.$canvas.parentNode) {
            // destroy context
            // @ts-ignore
            this.$container.removeChild(this.$canvas);
        }
    };
    Canvas2DContextService.prototype.resize = function (width, height) {
        var devicePixelRatio = this.canvasConfig.devicePixelRatio;
        // use user-defined dpr first
        var dpr = devicePixelRatio || (isBrowser && window.devicePixelRatio) || 1;
        dpr = dpr >= 1 ? Math.ceil(dpr) : 1;
        this.dpr = dpr;
        if (this.$canvas) {
            // set canvas width & height
            this.$canvas.width = this.dpr * width;
            this.$canvas.height = this.dpr * height;
            // set CSS style width & height
            setDOMSize(this.$canvas, width, height);
            // const dpr = this.getDPR();
            // scale all drawing operations by the dpr
            // @see https://www.html5rocks.com/en/tutorials/canvas/hidpi/
            // this.context.scale(dpr, dpr);
        }
        this.renderingContext.renderReasons.add(RenderReason.CAMERA_CHANGED);
    };
    Canvas2DContextService.prototype.applyCursorStyle = function (cursor) {
        if (this.$container && this.$container.style) {
            this.$container.style.cursor = cursor;
        }
    };
    Canvas2DContextService.prototype.toDataURL = function (options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var type, encoderOptions;
            return __generator(this, function (_a) {
                type = options.type, encoderOptions = options.encoderOptions;
                return [2 /*return*/, this.context.canvas.toDataURL(type, encoderOptions)];
            });
        });
    };
    return Canvas2DContextService;
}());

var ContextRegisterPlugin = /** @class */ (function (_super) {
    __extends(ContextRegisterPlugin, _super);
    function ContextRegisterPlugin() {
        var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
        _this.name = 'canvas-context-register';
        return _this;
    }
    ContextRegisterPlugin.prototype.init = function () {
        this.context.ContextService = Canvas2DContextService;
    };
    ContextRegisterPlugin.prototype.destroy = function () {
        delete this.context.ContextService;
    };
    return ContextRegisterPlugin;
}(AbstractRendererPlugin));

var Renderer = /** @class */ (function (_super) {
    __extends(Renderer, _super);
    function Renderer(config) {
        var _this = _super.call(this, config) || this;
        // register Canvas2DContext
        _this.registerPlugin(new ContextRegisterPlugin());
        _this.registerPlugin(new ImageLoader.Plugin());
        _this.registerPlugin(new CanvasPathGenerator.Plugin());
        // enable rendering with Canvas2D API
        _this.registerPlugin(new CanvasRenderer.Plugin());
        _this.registerPlugin(new DomInteraction.Plugin());
        // enable picking with Canvas2D API
        _this.registerPlugin(new CanvasPicker.Plugin());
        // render HTML component
        _this.registerPlugin(new HTMLRenderer.Plugin());
        return _this;
    }
    return Renderer;
}(AbstractRenderer));

export { Renderer };
//# sourceMappingURL=index.esm.js.map

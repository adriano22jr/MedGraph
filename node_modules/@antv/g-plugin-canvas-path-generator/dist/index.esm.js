import { __read, __extends, __spreadArray } from 'tslib';
import { isDisplayObject, Shape, AbstractRendererPlugin } from '@antv/g-lite';
import { clamp } from '@antv/util';

function generatePath$6(context, parsedStyle) {
    var _a = parsedStyle.cx, cx = _a === void 0 ? 0 : _a, _b = parsedStyle.cy, cy = _b === void 0 ? 0 : _b, r = parsedStyle.r;
    context.arc(cx, cy, r, 0, Math.PI * 2, false);
}

function generatePath$5(context, parsedStyle) {
    var _a = parsedStyle.cx, cx = _a === void 0 ? 0 : _a, _b = parsedStyle.cy, cy = _b === void 0 ? 0 : _b, rx = parsedStyle.rx, ry = parsedStyle.ry;
    // @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/ellipse
    if (context.ellipse) {
        context.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2, false);
    }
    else {
        // 如果不支持，则使用圆来绘制，进行变形
        var r = rx > ry ? rx : ry;
        var scaleX = rx > ry ? 1 : rx / ry;
        var scaleY = rx > ry ? ry / rx : 1;
        context.save();
        context.scale(scaleX, scaleY);
        context.arc(cx, cy, r, 0, Math.PI * 2);
    }
}

function generatePath$4(context, parsedStyle) {
    var x1 = parsedStyle.x1, y1 = parsedStyle.y1, x2 = parsedStyle.x2, y2 = parsedStyle.y2, markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
    var startOffsetX = 0;
    var startOffsetY = 0;
    var endOffsetX = 0;
    var endOffsetY = 0;
    var rad = 0;
    var x;
    var y;
    if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
        x = x2 - x1;
        y = y2 - y1;
        rad = Math.atan2(y, x);
        startOffsetX = Math.cos(rad) * (markerStartOffset || 0);
        startOffsetY = Math.sin(rad) * (markerStartOffset || 0);
    }
    if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
        x = x1 - x2;
        y = y1 - y2;
        rad = Math.atan2(y, x);
        endOffsetX = Math.cos(rad) * (markerEndOffset || 0);
        endOffsetY = Math.sin(rad) * (markerEndOffset || 0);
    }
    context.moveTo(x1 + startOffsetX, y1 + startOffsetY);
    context.lineTo(x2 + endOffsetX, y2 + endOffsetY);
}

function generatePath$3(context, parsedStyle) {
    var markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
    var _a = parsedStyle.d, absolutePath = _a.absolutePath, segments = _a.segments;
    var startOffsetX = 0;
    var startOffsetY = 0;
    var endOffsetX = 0;
    var endOffsetY = 0;
    var rad = 0;
    var x;
    var y;
    if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
        var _b = __read(markerStart.parentNode.getStartTangent(), 2), p1 = _b[0], p2 = _b[1];
        x = p1[0] - p2[0];
        y = p1[1] - p2[1];
        rad = Math.atan2(y, x);
        startOffsetX = Math.cos(rad) * (markerStartOffset || 0);
        startOffsetY = Math.sin(rad) * (markerStartOffset || 0);
    }
    if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
        var _c = __read(markerEnd.parentNode.getEndTangent(), 2), p1 = _c[0], p2 = _c[1];
        x = p1[0] - p2[0];
        y = p1[1] - p2[1];
        rad = Math.atan2(y, x);
        endOffsetX = Math.cos(rad) * (markerEndOffset || 0);
        endOffsetY = Math.sin(rad) * (markerEndOffset || 0);
    }
    for (var i = 0; i < absolutePath.length; i++) {
        var params = absolutePath[i];
        var command = params[0];
        var nextSegment = absolutePath[i + 1];
        var useStartOffset = i === 0 && (startOffsetX !== 0 || startOffsetY !== 0);
        var useEndOffset = (i === absolutePath.length - 1 ||
            (nextSegment && (nextSegment[0] === 'M' || nextSegment[0] === 'Z'))) &&
            endOffsetX !== 0 &&
            endOffsetY !== 0;
        switch (command) {
            case 'M':
                // Use start marker offset
                if (useStartOffset) {
                    context.moveTo(params[1] + startOffsetX, params[2] + startOffsetY);
                    context.lineTo(params[1], params[2]);
                }
                else {
                    context.moveTo(params[1], params[2]);
                }
                break;
            case 'L':
                if (useEndOffset) {
                    context.lineTo(params[1] + endOffsetX, params[2] + endOffsetY);
                }
                else {
                    context.lineTo(params[1], params[2]);
                }
                break;
            case 'Q':
                context.quadraticCurveTo(params[1], params[2], params[3], params[4]);
                if (useEndOffset) {
                    context.lineTo(params[3] + endOffsetX, params[4] + endOffsetY);
                }
                break;
            case 'C':
                context.bezierCurveTo(params[1], params[2], params[3], params[4], params[5], params[6]);
                if (useEndOffset) {
                    context.lineTo(params[5] + endOffsetX, params[6] + endOffsetY);
                }
                break;
            case 'A': {
                var arcParams = segments[i].arcParams;
                var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation, sweepFlag = arcParams.sweepFlag;
                // @see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/ellipse
                if (context.ellipse) {
                    context.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, !!(1 - sweepFlag));
                }
                else {
                    // @see https://stackoverflow.com/a/47494351
                    var r = rx > ry ? rx : ry;
                    var scaleX = rx > ry ? 1 : rx / ry;
                    var scaleY = rx > ry ? ry / rx : 1;
                    context.translate(cx, cy);
                    context.rotate(xRotation);
                    context.scale(scaleX, scaleY);
                    context.arc(0, 0, r, startAngle, endAngle, !!(1 - sweepFlag));
                    context.scale(1 / scaleX, 1 / scaleY);
                    context.rotate(-xRotation);
                    context.translate(-cx, -cy);
                }
                if (useEndOffset) {
                    context.lineTo(params[6] + endOffsetX, params[7] + endOffsetY);
                }
                break;
            }
            case 'Z':
                context.closePath();
                break;
        }
    }
}

function generatePath$2(context, parsedStyle) {
    var markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
    var points = parsedStyle.points.points;
    var length = points.length;
    var x1 = points[0][0];
    var y1 = points[0][1];
    var x2 = points[length - 1][0];
    var y2 = points[length - 1][1];
    var startOffsetX = 0;
    var startOffsetY = 0;
    var endOffsetX = 0;
    var endOffsetY = 0;
    var rad = 0;
    var x;
    var y;
    if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
        x = points[1][0] - points[0][0];
        y = points[1][1] - points[0][1];
        rad = Math.atan2(y, x);
        startOffsetX = Math.cos(rad) * (markerStartOffset || 0);
        startOffsetY = Math.sin(rad) * (markerStartOffset || 0);
    }
    if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
        x = points[length - 1][0] - points[0][0];
        y = points[length - 1][1] - points[0][1];
        rad = Math.atan2(y, x);
        endOffsetX = Math.cos(rad) * (markerEndOffset || 0);
        endOffsetY = Math.sin(rad) * (markerEndOffset || 0);
    }
    context.moveTo(x1 + (startOffsetX || endOffsetX), y1 + (startOffsetY || endOffsetY));
    for (var i = 1; i < length - 1; i++) {
        var point = points[i];
        context.lineTo(point[0], point[1]);
    }
    context.lineTo(x2, y2);
}

function generatePath$1(context, parsedStyle) {
    var markerStart = parsedStyle.markerStart, markerEnd = parsedStyle.markerEnd, markerStartOffset = parsedStyle.markerStartOffset, markerEndOffset = parsedStyle.markerEndOffset;
    var points = parsedStyle.points.points;
    var length = points.length;
    var x1 = points[0][0];
    var y1 = points[0][1];
    var x2 = points[length - 1][0];
    var y2 = points[length - 1][1];
    var startOffsetX = 0;
    var startOffsetY = 0;
    var endOffsetX = 0;
    var endOffsetY = 0;
    var rad = 0;
    var x;
    var y;
    if (markerStart && isDisplayObject(markerStart) && markerStartOffset) {
        x = points[1][0] - points[0][0];
        y = points[1][1] - points[0][1];
        rad = Math.atan2(y, x);
        startOffsetX = Math.cos(rad) * (markerStartOffset || 0);
        startOffsetY = Math.sin(rad) * (markerStartOffset || 0);
    }
    if (markerEnd && isDisplayObject(markerEnd) && markerEndOffset) {
        x = points[length - 2][0] - points[length - 1][0];
        y = points[length - 2][1] - points[length - 1][1];
        rad = Math.atan2(y, x);
        endOffsetX = Math.cos(rad) * (markerEndOffset || 0);
        endOffsetY = Math.sin(rad) * (markerEndOffset || 0);
    }
    context.moveTo(x1 + startOffsetX, y1 + startOffsetY);
    for (var i = 1; i < length - 1; i++) {
        var point = points[i];
        context.lineTo(point[0], point[1]);
    }
    context.lineTo(x2 + endOffsetX, y2 + endOffsetY);
}

function generatePath(context, parsedStyle) {
    var _a = parsedStyle.x, x = _a === void 0 ? 0 : _a, _b = parsedStyle.y, y = _b === void 0 ? 0 : _b, radius = parsedStyle.radius, width = parsedStyle.width, height = parsedStyle.height;
    var w = width;
    var h = height;
    var hasRadius = radius && radius.some(function (r) { return r !== 0; });
    if (!hasRadius) {
        // Canvas support negative width/height of rect
        context.rect(x, y, w, h);
    }
    else {
        var signX = width > 0 ? 1 : -1;
        var signY = height > 0 ? 1 : -1;
        var sweepFlag = signX + signY === 0;
        var _c = __read(radius.map(function (r) {
            return clamp(r, 0, Math.min(Math.abs(w) / 2, Math.abs(h) / 2));
        }), 4), tlr = _c[0], trr = _c[1], brr = _c[2], blr = _c[3];
        context.moveTo(signX * tlr + x, y);
        context.lineTo(w - signX * trr + x, y);
        if (trr !== 0) {
            context.arc(w - signX * trr + x, signY * trr + y, trr, (-signY * Math.PI) / 2, signX > 0 ? 0 : Math.PI, sweepFlag);
        }
        context.lineTo(w + x, h - signY * brr + y);
        if (brr !== 0) {
            context.arc(w - signX * brr + x, h - signY * brr + y, brr, signX > 0 ? 0 : Math.PI, signY > 0 ? Math.PI / 2 : 1.5 * Math.PI, sweepFlag);
        }
        context.lineTo(signX * blr + x, h + y);
        if (blr !== 0) {
            context.arc(signX * blr + x, h - signY * blr + y, blr, signY > 0 ? Math.PI / 2 : -Math.PI / 2, signX > 0 ? Math.PI : 0, sweepFlag);
        }
        context.lineTo(x, signY * tlr + y);
        if (tlr !== 0) {
            context.arc(signX * tlr + x, signY * tlr + y, tlr, signX > 0 ? Math.PI : 0, signY > 0 ? Math.PI * 1.5 : Math.PI / 2, sweepFlag);
        }
    }
}

var Plugin = /** @class */ (function (_super) {
    __extends(Plugin, _super);
    function Plugin() {
        var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
        _this.name = 'canvas-path-generator';
        return _this;
    }
    Plugin.prototype.init = function () {
        var _a;
        var pathGeneratorFactory = (_a = {},
            _a[Shape.CIRCLE] = generatePath$6,
            _a[Shape.ELLIPSE] = generatePath$5,
            _a[Shape.RECT] = generatePath,
            _a[Shape.LINE] = generatePath$4,
            _a[Shape.POLYLINE] = generatePath$1,
            _a[Shape.POLYGON] = generatePath$2,
            _a[Shape.PATH] = generatePath$3,
            _a[Shape.TEXT] = undefined,
            _a[Shape.GROUP] = undefined,
            _a[Shape.IMAGE] = undefined,
            _a[Shape.HTML] = undefined,
            _a[Shape.MESH] = undefined,
            _a);
        // @ts-ignore
        this.context.pathGeneratorFactory = pathGeneratorFactory;
    };
    Plugin.prototype.destroy = function () {
        // @ts-ignore
        delete this.context.pathGeneratorFactory;
    };
    return Plugin;
}(AbstractRendererPlugin));

export { Plugin };
//# sourceMappingURL=index.esm.js.map

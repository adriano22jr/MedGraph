import { getAngle, CameraType, deg2rad, createVec3, runtime, Camera } from '@antv/g-lite';
import { __extends, __spreadArray, __read } from 'tslib';
import { isString, isNumber } from '@antv/util';
import { quat, mat4, vec3 } from 'gl-matrix';

/**
 * Provides camera action & animation.
 */
var AdvancedCamera = /** @class */ (function (_super) {
    __extends(AdvancedCamera, _super);
    function AdvancedCamera() {
        var _this = _super.apply(this, __spreadArray([], __read(arguments), false)) || this;
        /**
         * switch between multiple landmarks
         */
        _this.landmarks = [];
        return _this;
        /**
         * Sets the camera to a distance such that the area covered by the bounding box is viewed.
         */
        // shot(displayObject: DisplayObject) {
        //   const aabb = displayObject.getBounds();
        //   if (!AABB.isEmpty(aabb)) {
        //     this.setElevation(0);
        //     this.setAzimuth(0);
        //     this.setRoll(0);
        //     const { halfExtents, center } = aabb;
        //     const maxDim = Math.max(halfExtents[0] * 2, halfExtents[1] * 2);
        //     const cc = center.map((c: number) => Math.round(c * 1000) / 1000) as [number, number, number];
        //     if (maxDim !== 0) {
        //       const d = (1.5 * maxDim) / Math.tan(this.fov * DEG_2_RAD);
        //       this.setPosition([cc[0], cc[1], cc[2] + d]);
        //     }
        //     this.setFocalPoint(cc);
        //   }
        // }
    }
    /**
     * Changes the azimuth and elevation with respect to the current camera axes
     * @param {Number} azimuth the relative azimuth
     * @param {Number} elevation the relative elevation
     * @param {Number} roll the relative roll
     */
    AdvancedCamera.prototype.rotate = function (azimuth, elevation, roll) {
        this.relElevation = getAngle(elevation);
        this.relAzimuth = getAngle(azimuth);
        this.relRoll = getAngle(roll);
        this.elevation += this.relElevation;
        this.azimuth += this.relAzimuth;
        this.roll += this.relRoll;
        if (this.type === CameraType.EXPLORING) {
            var rotX = quat.setAxisAngle(quat.create(), [1, 0, 0], deg2rad((this.rotateWorld ? 1 : -1) * this.relElevation));
            var rotY = quat.setAxisAngle(quat.create(), [0, 1, 0], deg2rad((this.rotateWorld ? 1 : -1) * this.relAzimuth));
            var rotZ = quat.setAxisAngle(quat.create(), [0, 0, 1], deg2rad(this.relRoll));
            var rotQ = quat.multiply(quat.create(), rotY, rotX);
            rotQ = quat.multiply(quat.create(), rotQ, rotZ);
            var rotMatrix = mat4.fromQuat(mat4.create(), rotQ);
            mat4.translate(this.matrix, this.matrix, [0, 0, -this.distance]);
            mat4.multiply(this.matrix, this.matrix, rotMatrix);
            mat4.translate(this.matrix, this.matrix, [0, 0, this.distance]);
        }
        else {
            if (Math.abs(this.elevation) > 90) {
                return this;
            }
            this.computeMatrix();
        }
        this._getAxes();
        if (this.type === CameraType.ORBITING ||
            this.type === CameraType.EXPLORING) {
            this._getPosition();
        }
        else if (this.type === CameraType.TRACKING) {
            this._getFocalPoint();
        }
        this._update();
        return this;
    };
    /**
     * 沿水平(right) & 垂直(up)平移相机
     */
    AdvancedCamera.prototype.pan = function (tx, ty) {
        var coords = createVec3(tx, ty, 0);
        var pos = vec3.clone(this.position);
        vec3.add(pos, pos, vec3.scale(vec3.create(), this.right, coords[0]));
        vec3.add(pos, pos, vec3.scale(vec3.create(), this.up, coords[1]));
        this._setPosition(pos);
        this.triggerUpdate();
        return this;
    };
    /**
     * 沿 n 轴移动，当距离视点远时移动速度较快，离视点越近速度越慢
     */
    AdvancedCamera.prototype.dolly = function (value) {
        var n = this.forward;
        var pos = vec3.clone(this.position);
        var step = value * this.dollyingStep;
        var updatedDistance = this.distance + value * this.dollyingStep;
        // 限制视点距离范围
        step =
            Math.max(Math.min(updatedDistance, this.maxDistance), this.minDistance) -
                this.distance;
        pos[0] += step * n[0];
        pos[1] += step * n[1];
        pos[2] += step * n[2];
        this._setPosition(pos);
        if (this.type === CameraType.ORBITING ||
            this.type === CameraType.EXPLORING) {
            // 重新计算视点距离
            this._getDistance();
        }
        else if (this.type === CameraType.TRACKING) {
            // 保持视距，移动视点位置
            vec3.add(this.focalPoint, pos, this.distanceVector);
        }
        this.triggerUpdate();
        return this;
    };
    AdvancedCamera.prototype.cancelLandmarkAnimation = function () {
        if (this.landmarkAnimationID !== undefined) {
            this.canvas.cancelAnimationFrame(this.landmarkAnimationID);
        }
    };
    AdvancedCamera.prototype.createLandmark = function (name, params) {
        var _a, _b, _c, _d;
        if (params === void 0) { params = {}; }
        var _e = params.position, position = _e === void 0 ? this.position : _e, _f = params.focalPoint, focalPoint = _f === void 0 ? this.focalPoint : _f, roll = params.roll, zoom = params.zoom;
        var camera = new runtime.CameraContribution();
        camera.setType(this.type, undefined);
        camera.setPosition(position[0], (_a = position[1]) !== null && _a !== void 0 ? _a : this.position[1], (_b = position[2]) !== null && _b !== void 0 ? _b : this.position[2]);
        camera.setFocalPoint(focalPoint[0], (_c = focalPoint[1]) !== null && _c !== void 0 ? _c : this.focalPoint[1], (_d = focalPoint[2]) !== null && _d !== void 0 ? _d : this.focalPoint[2]);
        camera.setRoll(roll !== null && roll !== void 0 ? roll : this.roll);
        camera.setZoom(zoom !== null && zoom !== void 0 ? zoom : this.zoom);
        var landmark = {
            name: name,
            matrix: mat4.clone(camera.getWorldTransform()),
            right: vec3.clone(camera.right),
            up: vec3.clone(camera.up),
            forward: vec3.clone(camera.forward),
            position: vec3.clone(camera.getPosition()),
            focalPoint: vec3.clone(camera.getFocalPoint()),
            distanceVector: vec3.clone(camera.getDistanceVector()),
            distance: camera.getDistance(),
            dollyingStep: camera.getDollyingStep(),
            azimuth: camera.getAzimuth(),
            elevation: camera.getElevation(),
            roll: camera.getRoll(),
            relAzimuth: camera.relAzimuth,
            relElevation: camera.relElevation,
            relRoll: camera.relRoll,
            zoom: camera.getZoom(),
        };
        this.landmarks.push(landmark);
        return landmark;
    };
    AdvancedCamera.prototype.gotoLandmark = function (name, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var landmark = isString(name)
            ? this.landmarks.find(function (l) { return l.name === name; })
            : name;
        if (landmark) {
            var _a = isNumber(options) ? { duration: options } : options, _b = _a.easing, easing = _b === void 0 ? 'linear' : _b, _c = _a.duration, duration_1 = _c === void 0 ? 100 : _c, _d = _a.easingFunction, easingFunction = _d === void 0 ? undefined : _d, _e = _a.onfinish, onfinish_1 = _e === void 0 ? undefined : _e, _f = _a.onframe, onframe_1 = _f === void 0 ? undefined : _f;
            var epsilon_1 = 0.01;
            if (duration_1 === 0) {
                this.syncFromLandmark(landmark);
                if (onfinish_1) {
                    onfinish_1();
                }
                return;
            }
            // cancel ongoing animation
            this.cancelLandmarkAnimation();
            var destPosition_1 = landmark.position;
            var destFocalPoint_1 = landmark.focalPoint;
            var destZoom_1 = landmark.zoom;
            var destRoll_1 = landmark.roll;
            var easingFunc_1 = easingFunction || runtime.EasingFunction(easing);
            var timeStart_1;
            var endAnimation_1 = function () {
                _this.setFocalPoint(destFocalPoint_1);
                _this.setPosition(destPosition_1);
                _this.setRoll(destRoll_1);
                _this.setZoom(destZoom_1);
                _this.computeMatrix();
                _this.triggerUpdate();
                if (onfinish_1) {
                    onfinish_1();
                }
            };
            var animate_1 = function (timestamp) {
                if (timeStart_1 === undefined) {
                    timeStart_1 = timestamp;
                }
                var elapsed = timestamp - timeStart_1;
                if (elapsed > duration_1) {
                    endAnimation_1();
                    return;
                }
                // use the same ease function in animation system
                var t = easingFunc_1(elapsed / duration_1);
                var interFocalPoint = vec3.create();
                var interPosition = vec3.create();
                var interZoom = 1;
                var interRoll = 0;
                vec3.lerp(interFocalPoint, _this.focalPoint, destFocalPoint_1, t);
                vec3.lerp(interPosition, _this.position, destPosition_1, t);
                interRoll = _this.roll * (1 - t) + destRoll_1 * t;
                interZoom = _this.zoom * (1 - t) + destZoom_1 * t;
                _this.setFocalPoint(interFocalPoint);
                _this.setPosition(interPosition);
                _this.setRoll(interRoll);
                _this.setZoom(interZoom);
                var dist = vec3.dist(interFocalPoint, destFocalPoint_1) +
                    vec3.dist(interPosition, destPosition_1);
                if (dist <= epsilon_1 && destZoom_1 == undefined && destRoll_1 == undefined) {
                    endAnimation_1();
                    return;
                }
                _this.computeMatrix();
                _this.triggerUpdate();
                if (elapsed < duration_1) {
                    if (onframe_1) {
                        onframe_1(t);
                    }
                    _this.landmarkAnimationID = _this.canvas.requestAnimationFrame(animate_1);
                }
            };
            this.canvas.requestAnimationFrame(animate_1);
        }
    };
    AdvancedCamera.prototype.syncFromLandmark = function (landmark) {
        this.matrix = mat4.copy(this.matrix, landmark.matrix);
        this.right = vec3.copy(this.right, landmark.right);
        this.up = vec3.copy(this.up, landmark.up);
        this.forward = vec3.copy(this.forward, landmark.forward);
        this.position = vec3.copy(this.position, landmark.position);
        this.focalPoint = vec3.copy(this.focalPoint, landmark.focalPoint);
        this.distanceVector = vec3.copy(this.distanceVector, landmark.distanceVector);
        this.azimuth = landmark.azimuth;
        this.elevation = landmark.elevation;
        this.roll = landmark.roll;
        this.relAzimuth = landmark.relAzimuth;
        this.relElevation = landmark.relElevation;
        this.relRoll = landmark.relRoll;
        this.dollyingStep = landmark.dollyingStep;
        this.distance = landmark.distance;
        this.zoom = landmark.zoom;
    };
    return AdvancedCamera;
}(Camera));

runtime.CameraContribution = AdvancedCamera;

export { AdvancedCamera };
//# sourceMappingURL=index.esm.js.map

'use strict';

var tslib = require('tslib');
var gLite = require('@antv/g-lite');
var DeviceRenderer = require('@antv/g-plugin-device-renderer');
var DomInteraction = require('@antv/g-plugin-dom-interaction');
var HTMLRenderer = require('@antv/g-plugin-html-renderer');
var ImageLoader = require('@antv/g-plugin-image-loader');
var util = require('@antv/util');
var gDeviceApi = require('@antv/g-device-api');
var glMatrix = require('gl-matrix');

function _interopNamespaceDefault(e) {
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n.default = e;
    return Object.freeze(n);
}

var DeviceRenderer__namespace = /*#__PURE__*/_interopNamespaceDefault(DeviceRenderer);
var DomInteraction__namespace = /*#__PURE__*/_interopNamespaceDefault(DomInteraction);
var HTMLRenderer__namespace = /*#__PURE__*/_interopNamespaceDefault(HTMLRenderer);
var ImageLoader__namespace = /*#__PURE__*/_interopNamespaceDefault(ImageLoader);

var WebGLContextService = /** @class */ (function () {
    function WebGLContextService(context) {
        this.canvasConfig = context.config;
        // @ts-ignore
        this.deviceRendererPlugin = context.deviceRendererPlugin;
    }
    WebGLContextService.prototype.init = function () {
        var _a = this.canvasConfig, container = _a.container, canvas = _a.canvas;
        if (canvas) {
            this.$canvas = canvas;
            if (container &&
                canvas.parentElement !== container) {
                container.appendChild(canvas);
            }
            this.$container = canvas.parentElement;
            this.canvasConfig.container = this.$container;
        }
        else if (container) {
            // create container
            this.$container = util.isString(container)
                ? document.getElementById(container)
                : container;
            if (this.$container) {
                // create canvas
                var $canvas = document.createElement('canvas');
                this.$container.appendChild($canvas);
                if (!this.$container.style.position) {
                    this.$container.style.position = 'relative';
                }
                this.$canvas = $canvas;
            }
        }
        this.resize(this.canvasConfig.width, this.canvasConfig.height);
    };
    WebGLContextService.prototype.getDomElement = function () {
        return this.$canvas;
    };
    WebGLContextService.prototype.getContext = function () {
        // @ts-ignore
        return this.deviceRendererPlugin.getDevice().gl;
    };
    WebGLContextService.prototype.getBoundingClientRect = function () {
        if (this.$canvas.getBoundingClientRect) {
            return this.$canvas.getBoundingClientRect();
        }
    };
    WebGLContextService.prototype.destroy = function () {
        // @ts-ignore
        if (this.$container && this.$canvas && this.$canvas.parentNode) {
            // @ts-ignore
            this.$container.removeChild(this.$canvas);
        }
    };
    WebGLContextService.prototype.resize = function (width, height) {
        // use user-defined dpr first
        var devicePixelRatio = this.canvasConfig.devicePixelRatio;
        var dpr = devicePixelRatio || (gLite.isBrowser && window.devicePixelRatio) || 1;
        dpr = dpr >= 1 ? Math.ceil(dpr) : 1;
        this.dpr = dpr;
        if (this.$canvas) {
            var dpr_1 = this.getDPR();
            // set canvas width & height
            this.$canvas.width = dpr_1 * width;
            this.$canvas.height = dpr_1 * height;
            // set CSS style width & height
            gLite.setDOMSize(this.$canvas, width, height);
        }
    };
    WebGLContextService.prototype.getDPR = function () {
        return this.dpr;
    };
    WebGLContextService.prototype.applyCursorStyle = function (cursor) {
        if (this.$container && this.$container.style) {
            this.$container.style.cursor = cursor;
        }
    };
    WebGLContextService.prototype.toDataURL = function (options) {
        if (options === void 0) { options = {}; }
        return tslib.__awaiter(this, void 0, void 0, function () {
            return tslib.__generator(this, function (_a) {
                // @see https://stackoverflow.com/questions/26783586/canvas-todataurl-returns-blank-image
                return [2 /*return*/, this.deviceRendererPlugin.toDataURL(options)];
            });
        });
    };
    return WebGLContextService;
}());

var ContextRegisterPlugin = /** @class */ (function (_super) {
    tslib.__extends(ContextRegisterPlugin, _super);
    function ContextRegisterPlugin(rendererPlugin, config) {
        var _this = _super.call(this) || this;
        _this.rendererPlugin = rendererPlugin;
        _this.config = config;
        _this.name = 'webgl-context-register';
        return _this;
    }
    ContextRegisterPlugin.prototype.init = function () {
        this.context.ContextService = WebGLContextService;
        this.context.deviceRendererPlugin = this.rendererPlugin;
        var config = this.config;
        this.context.deviceContribution = new gDeviceApi.WebGLDeviceContribution(tslib.__assign(tslib.__assign({}, ((config === null || config === void 0 ? void 0 : config.targets)
            ? {
                targets: config.targets,
            }
            : {
                targets: ['webgl2', 'webgl1'],
            })), { onContextLost: config === null || config === void 0 ? void 0 : config.onContextLost, onContextRestored: config === null || config === void 0 ? void 0 : config.onContextRestored, onContextCreationError: config === null || config === void 0 ? void 0 : config.onContextCreationError }));
    };
    ContextRegisterPlugin.prototype.destroy = function () {
        delete this.context.ContextService;
    };
    return ContextRegisterPlugin;
}(gLite.AbstractRendererPlugin));

var DEFAULT_EVENT = new gLite.CustomEvent('');
/**
 * @see https://github.com/mrdoob/three.js/blob/master/src/renderers/webxr/WebXRController.js
 */
var WebXRController = /** @class */ (function () {
    function WebXRController() {
        this.targetRay = null;
    }
    WebXRController.prototype.connect = function (inputSource) {
        // if (inputSource && inputSource.hand) {
        //   const hand = this._hand;
        //   if (hand) {
        //     for (const inputjoint of inputSource.hand.values()) {
        //       // Initialize hand with joints when connected
        //       this._getHandJoint(hand, inputjoint);
        //     }
        //   }
        // }
        this.dispatchEvent({ type: 'connected', data: inputSource });
        return this;
    };
    WebXRController.prototype.disconnect = function (inputSource) {
        this.dispatchEvent({ type: 'disconnected', data: inputSource });
        if (this.targetRay !== null) {
            this.targetRay.style.visible = false;
        }
        // if (this._grip !== null) {
        //   this._grip.visible = false;
        // }
        // if (this._hand !== null) {
        //   this._hand.visible = false;
        // }
        return this;
    };
    WebXRController.prototype.update = function (inputSource, frame, referenceSpace) {
        var inputPose = null;
        // let gripPose = null;
        // let handPose = null;
        var targetRay = this.targetRay;
        // const grip = this._grip;
        // const hand = this._hand;
        if (inputSource && frame.session.visibilityState !== 'visible-blurred') {
            // if (hand && inputSource.hand) {
            //   handPose = true;
            //   for (const inputjoint of inputSource.hand.values()) {
            //     // Update the joints groups with the XRJoint poses
            //     const jointPose = frame.getJointPose(inputjoint, referenceSpace);
            //     // The transform of this joint will be updated with the joint pose on each frame
            //     const joint = this._getHandJoint(hand, inputjoint);
            //     if (jointPose !== null) {
            //       joint.matrix.fromArray(jointPose.transform.matrix);
            //       joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
            //       joint.matrixWorldNeedsUpdate = true;
            //       joint.jointRadius = jointPose.radius;
            //     }
            //     joint.visible = jointPose !== null;
            //   }
            //   // Custom events
            //   // Check pinchz
            //   const indexTip = hand.joints['index-finger-tip'];
            //   const thumbTip = hand.joints['thumb-tip'];
            //   const distance = indexTip.position.distanceTo(thumbTip.position);
            //   const distanceToPinch = 0.02;
            //   const threshold = 0.005;
            //   if (
            //     hand.inputState.pinching &&
            //     distance > distanceToPinch + threshold
            //   ) {
            //     hand.inputState.pinching = false;
            //     this.dispatchEvent({
            //       type: 'pinchend',
            //       handedness: inputSource.handedness,
            //       target: this,
            //     });
            //   } else if (
            //     !hand.inputState.pinching &&
            //     distance <= distanceToPinch - threshold
            //   ) {
            //     hand.inputState.pinching = true;
            //     this.dispatchEvent({
            //       type: 'pinchstart',
            //       handedness: inputSource.handedness,
            //       target: this,
            //     });
            //   }
            // } else {
            //   if (grip !== null && inputSource.gripSpace) {
            //     gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
            //     if (gripPose !== null) {
            //       grip.matrix.fromArray(gripPose.transform.matrix);
            //       grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
            //       grip.matrixWorldNeedsUpdate = true;
            //       if (gripPose.linearVelocity) {
            //         grip.hasLinearVelocity = true;
            //         grip.linearVelocity.copy(gripPose.linearVelocity);
            //       } else {
            //         grip.hasLinearVelocity = false;
            //       }
            //       if (gripPose.angularVelocity) {
            //         grip.hasAngularVelocity = true;
            //         grip.angularVelocity.copy(gripPose.angularVelocity);
            //       } else {
            //         grip.hasAngularVelocity = false;
            //       }
            //     }
            //   }
            // }
            if (targetRay !== null) {
                inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
                // Some runtimes (namely Vive Cosmos with Vive OpenXR Runtime) have only grip space and ray space is equal to it
                // if (inputPose === null && gripPose !== null) {
                //   inputPose = gripPose;
                // }
                if (inputPose !== null) {
                    targetRay.setLocalTransform(inputPose.transform.matrix);
                    if (inputPose.linearVelocity) {
                        targetRay.style.hasLinearVelocity = true;
                        glMatrix.vec3.copy(targetRay.style.linearVelocity, inputPose.linearVelocity);
                    }
                    else {
                        targetRay.style.hasLinearVelocity = false;
                    }
                    if (inputPose.angularVelocity) {
                        targetRay.style.hasAngularVelocity = true;
                        targetRay.style.angularVelocity.copy(inputPose.angularVelocity);
                    }
                    else {
                        targetRay.style.hasAngularVelocity = false;
                    }
                    this.dispatchEvent({ type: 'move' });
                }
            }
        }
        if (targetRay !== null) {
            targetRay.style.visible = inputPose !== null;
        }
        // if (grip !== null) {
        //   grip.visible = gripPose !== null;
        // }
        // if (hand !== null) {
        //   hand.visible = handPose !== null;
        // }
        return this;
    };
    WebXRController.prototype.getTargetRaySpace = function () {
        if (this.targetRay === null) {
            this.targetRay = new gLite.Group();
            this.targetRay.style.visible = false;
            this.targetRay.style.hasLinearVelocity = false;
            this.targetRay.style.linearVelocity = glMatrix.vec3.create();
            this.targetRay.style.hasAngularVelocity = false;
            this.targetRay.style.angularVelocity = glMatrix.vec3.create();
        }
        return this.targetRay;
    };
    WebXRController.prototype.dispatchEvent = function (event) {
        var type = event.type, data = event.data;
        DEFAULT_EVENT.type = type;
        DEFAULT_EVENT.detail = data;
        if (this.targetRay !== null) {
            this.targetRay.dispatchEvent(DEFAULT_EVENT);
        }
        // if (this._grip !== null) {
        //   this._grip.dispatchEvent(event);
        // }
        // if (this._hand !== null) {
        //   this._hand.dispatchEvent(event);
        // }
        return this;
    };
    return WebXRController;
}());

var WebXRManager = /** @class */ (function () {
    function WebXRManager(plugin) {
        var _this = this;
        this.plugin = plugin;
        this.controllers = [];
        this.controllerInputSources = [];
        // getControllerGrip(index: number) {
        //   return this.getOrCreateController(index).getGripSpace();
        // }
        // getHand(index: number) {
        //   return this.getOrCreateController(index).getHandSpace();
        // }
        this.onSessionEnd = function () {
            _this.session.removeEventListener('select', _this.onSessionEvent);
            _this.session.removeEventListener('selectstart', _this.onSessionEvent);
            _this.session.removeEventListener('selectend', _this.onSessionEvent);
            _this.session.removeEventListener('squeeze', _this.onSessionEvent);
            _this.session.removeEventListener('squeezestart', _this.onSessionEvent);
            _this.session.removeEventListener('squeezeend', _this.onSessionEvent);
            _this.session.removeEventListener('end', _this.onSessionEnd);
            _this.session.removeEventListener('inputsourceschange', _this.onInputSourcesChange);
            for (var i = 0; i < _this.controllers.length; i++) {
                var inputSource = _this.controllerInputSources[i];
                if (inputSource === null)
                    continue;
                _this.controllerInputSources[i] = null;
                _this.controllers[i].disconnect(inputSource);
            }
        };
        this.onSessionEvent = function (event) {
            var controllerIndex = _this.controllerInputSources.indexOf(event.inputSource);
            if (controllerIndex === -1) {
                return;
            }
            var controller = _this.controllers[controllerIndex];
            if (controller !== undefined) {
                controller.update(event.inputSource, event.frame, 
                // @ts-ignore
                _this.session.referenceSpace);
                controller.dispatchEvent({ type: event.type, data: event.inputSource });
            }
        };
        this.onInputSourcesChange = function (event) {
            // Notify disconnected
            for (var i = 0; i < event.removed.length; i++) {
                var inputSource = event.removed[i];
                var index = _this.controllerInputSources.indexOf(inputSource);
                if (index >= 0) {
                    _this.controllerInputSources[index] = null;
                    _this.controllers[index].disconnect(inputSource);
                }
            }
            // Notify connected
            for (var i = 0; i < event.added.length; i++) {
                var inputSource = event.added[i];
                var controllerIndex = _this.controllerInputSources.indexOf(inputSource);
                if (controllerIndex === -1) {
                    // Assign input source a controller that currently has no input source
                    for (var i_1 = 0; i_1 < _this.controllers.length; i_1++) {
                        if (i_1 >= _this.controllerInputSources.length) {
                            _this.controllerInputSources.push(inputSource);
                            controllerIndex = i_1;
                            break;
                        }
                        else if (_this.controllerInputSources[i_1] === null) {
                            _this.controllerInputSources[i_1] = inputSource;
                            controllerIndex = i_1;
                            break;
                        }
                    }
                    // If all controllers do currently receive input we ignore new ones
                    if (controllerIndex === -1)
                        break;
                }
                var controller = _this.controllers[controllerIndex];
                if (controller) {
                    controller.connect(inputSource);
                }
            }
        };
    }
    WebXRManager.prototype.setSession = function (canvas, session) {
        return tslib.__awaiter(this, void 0, void 0, function () {
            var gl, attributes, layerInit, _a;
            return tslib.__generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!session) return [3 /*break*/, 5];
                        this.session = session;
                        gl = this.plugin.getDevice()['gl'];
                        attributes = gl.getContextAttributes();
                        if (!(attributes.xrCompatible !== true)) return [3 /*break*/, 2];
                        // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/makeXRCompatible
                        return [4 /*yield*/, gl.makeXRCompatible()];
                    case 1:
                        // @see https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/makeXRCompatible
                        _b.sent();
                        _b.label = 2;
                    case 2:
                        session.addEventListener('select', this.onSessionEvent);
                        session.addEventListener('selectstart', this.onSessionEvent);
                        session.addEventListener('selectend', this.onSessionEvent);
                        session.addEventListener('squeeze', this.onSessionEvent);
                        session.addEventListener('squeezestart', this.onSessionEvent);
                        session.addEventListener('squeezeend', this.onSessionEvent);
                        session.addEventListener('end', this.onSessionEnd);
                        session.addEventListener('inputsourceschange', this.onInputSourcesChange);
                        if (!(session.renderState.layers === undefined)) return [3 /*break*/, 4];
                        layerInit = {
                            antialias: attributes.antialias,
                            alpha: true,
                            depth: attributes.depth,
                            stencil: attributes.stencil,
                            framebufferScaleFactor: 1.0,
                        };
                        this.glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
                        session.updateRenderState({ baseLayer: this.glBaseLayer });
                        _a = this;
                        return [4 /*yield*/, session.requestReferenceSpace(this.referenceSpaceType)];
                    case 3:
                        _a.referenceSpace = _b.sent();
                        // @ts-ignore
                        session.referenceSpace = this.referenceSpace;
                        _b.label = 4;
                    case 4:
                        canvas.requestAnimationFrame =
                            session.requestAnimationFrame.bind(session);
                        _b.label = 5;
                    case 5: return [2 /*return*/];
                }
            });
        });
    };
    WebXRManager.prototype.setReferenceSpaceType = function (referenceSpaceType) {
        this.referenceSpaceType = referenceSpaceType;
    };
    WebXRManager.prototype.getSession = function () {
        return this.session;
    };
    WebXRManager.prototype.getReferenceSpace = function () {
        return this.referenceSpace;
    };
    WebXRManager.prototype.getOrCreateController = function (index) {
        var controller = this.controllers[index];
        if (controller === undefined) {
            controller = new WebXRController();
            this.controllers[index] = controller;
        }
        return controller;
    };
    WebXRManager.prototype.getController = function (index) {
        return this.getOrCreateController(index).getTargetRaySpace();
    };
    return WebXRManager;
}());

/**
 * @see https://github.com/mrdoob/three.js/blob/master/examples/jsm/webxr/ARButton.js
 * @example
 *
 * import { ARButton } from '@antv/g-webgl';
 * const $button = ARButton.createButton(renderer, { domOverlay: { root: document.body } });
 */
var ARButton = /** @class */ (function () {
    function ARButton() {
    }
    ARButton.createButton = function (canvas, renderer, sessionInit) {
        var _this = this;
        if (sessionInit === void 0) { sessionInit = {}; }
        var button = document.createElement('button');
        var disableButton = function () {
            button.style.display = '';
            button.style.cursor = 'auto';
            button.style.left = 'calc(50% - 75px)';
            button.style.width = '150px';
            button.onmouseenter = null;
            button.onmouseleave = null;
            button.onclick = null;
        };
        var showARNotSupported = function () {
            disableButton();
            button.textContent = 'AR NOT SUPPORTED';
        };
        var showARNotAllowed = function (exception) {
            disableButton();
            console.warn('Exception when trying to call xr.isSessionSupported', exception);
            button.textContent = 'AR NOT ALLOWED';
        };
        var stylizeElement = function (element) {
            element.style.position = 'absolute';
            element.style.bottom = '20px';
            element.style.padding = '12px 6px';
            element.style.border = '1px solid #fff';
            element.style.borderRadius = '4px';
            element.style.background = 'rgba(0,0,0,0.1)';
            element.style.color = '#fff';
            element.style.font = 'normal 13px sans-serif';
            element.style.textAlign = 'center';
            element.style.opacity = '0.5';
            element.style.outline = 'none';
            element.style.zIndex = '999';
        };
        var showStartAR = function () {
            var currentSession;
            button.style.display = '';
            button.style.cursor = 'pointer';
            button.style.left = 'calc(50% - 50px)';
            button.style.width = '100px';
            button.textContent = 'START AR';
            var onSessionEnded = function () {
                currentSession.removeEventListener('end', onSessionEnded);
                button.textContent = 'START AR';
                sessionInit.domOverlay.root.style.display = 'none';
                currentSession = undefined;
            };
            var onSessionStarted = function (session) { return tslib.__awaiter(_this, void 0, void 0, function () {
                return tslib.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            session.addEventListener('end', onSessionEnded);
                            renderer.xr.setReferenceSpaceType('local');
                            return [4 /*yield*/, renderer.xr.setSession(canvas, session)];
                        case 1:
                            _a.sent();
                            button.textContent = 'STOP AR';
                            sessionInit.domOverlay.root.style.display = '';
                            currentSession = session;
                            return [2 /*return*/];
                    }
                });
            }); };
            if (sessionInit.domOverlay === undefined) {
                var overlay = document.createElement('div');
                overlay.style.display = 'none';
                document.body.appendChild(overlay);
                var svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', '38');
                svg.setAttribute('height', '38');
                svg.style.position = 'absolute';
                svg.style.right = '20px';
                svg.style.top = '20px';
                svg.addEventListener('click', function () {
                    currentSession.end();
                });
                overlay.appendChild(svg);
                var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', 'M 12,12 L 28,28 M 28,12 12,28');
                path.setAttribute('stroke', '#fff');
                path.setAttribute('stroke-width', '2');
                svg.appendChild(path);
                if (sessionInit.optionalFeatures === undefined) {
                    sessionInit.optionalFeatures = [];
                }
                sessionInit.optionalFeatures.push('dom-overlay');
                sessionInit.domOverlay = { root: overlay };
            }
            /**
             * Bind event listeners to button.
             */
            button.onclick = function () {
                if (!currentSession) {
                    navigator.xr
                        .requestSession('immersive-ar', sessionInit)
                        .then(onSessionStarted);
                }
                else {
                    currentSession.end();
                }
            };
            button.onmouseenter = function () {
                button.style.opacity = '1.0';
            };
            button.onmouseleave = function () {
                button.style.opacity = '0.5';
            };
        };
        if ('xr' in navigator) {
            button.id = 'ARButton';
            button.style.display = 'none';
            stylizeElement(button);
            navigator.xr
                .isSessionSupported('immersive-ar')
                .then(function (supported) {
                supported ? showStartAR() : showARNotSupported();
            })
                .catch(showARNotAllowed);
            return button;
        }
        else {
            var message = document.createElement('a');
            if (window.isSecureContext === false) {
                message.href = document.location.href.replace(/^http:/, 'https:');
                message.innerHTML = 'WEBXR NEEDS HTTPS'; // TODO Improve message
            }
            else {
                message.href = 'https://immersiveweb.dev/';
                message.innerHTML = 'WEBXR NOT AVAILABLE';
            }
            message.style.left = 'calc(50% - 90px)';
            message.style.width = '180px';
            message.style.textDecoration = 'none';
            stylizeElement(message);
            return message;
        }
    };
    return ARButton;
}());

var Renderer = /** @class */ (function (_super) {
    tslib.__extends(Renderer, _super);
    function Renderer(config) {
        var _this = _super.call(this, tslib.__assign({ enableSizeAttenuation: false }, config)) || this;
        var deviceRendererPlugin = new DeviceRenderer__namespace.Plugin(config);
        _this.xr = new WebXRManager(deviceRendererPlugin);
        _this.registerPlugin(new ContextRegisterPlugin(deviceRendererPlugin, config));
        _this.registerPlugin(new ImageLoader__namespace.Plugin());
        _this.registerPlugin(deviceRendererPlugin);
        _this.registerPlugin(new DomInteraction__namespace.Plugin());
        _this.registerPlugin(new HTMLRenderer__namespace.Plugin());
        return _this;
    }
    return Renderer;
}(gLite.AbstractRenderer));

exports.DeviceRenderer = DeviceRenderer__namespace;
exports.DomInteraction = DomInteraction__namespace;
exports.HTMLRenderer = HTMLRenderer__namespace;
exports.ARButton = ARButton;
exports.Renderer = Renderer;
exports.WebXRManager = WebXRManager;
//# sourceMappingURL=index.js.map

'use strict';

var tslib = require('tslib');
var gLite = require('@antv/g-lite');
var gPluginDeviceRenderer = require('@antv/g-plugin-device-renderer');
var gDeviceApi = require('@antv/g-device-api');
var glMatrix = require('gl-matrix');

var ProceduralGeometry = /** @class */ (function (_super) {
    tslib.__extends(ProceduralGeometry, _super);
    function ProceduralGeometry(device, props) {
        if (props === void 0) { props = {}; }
        var _this = _super.call(this, device, props) || this;
        /**
         * flip Y, since +Y is down in G's world coords
         */
        _this.flipYMatrix = glMatrix.mat4.fromScaling(glMatrix.mat4.create(), glMatrix.vec3.fromValues(1, -1, 1));
        _this.topology = _this.createTopology();
        return _this;
    }
    ProceduralGeometry.prototype.applyMa4Position = function (mat, positions) {
        var v = glMatrix.vec4.create();
        for (var i = 0; i < positions.byteLength / 4; i += 3) {
            v[0] = positions[i];
            v[1] = positions[i + 1];
            v[2] = positions[i + 2];
            v[3] = 1;
            glMatrix.vec4.transformMat4(v, v, mat);
            positions[i] = v[0];
            positions[i + 1] = v[1];
            positions[i + 2] = v[2];
        }
        this.updateVertexBuffer(gPluginDeviceRenderer.VertexAttributeBufferIndex.POSITION, gPluginDeviceRenderer.VertexAttributeLocation.POSITION, 0, new Uint8Array(positions.buffer));
    };
    ProceduralGeometry.prototype.applyMa4Normal = function (mat, normals) {
        var v = glMatrix.vec4.create();
        var normalMatrix = glMatrix.mat4.copy(glMatrix.mat4.create(), mat);
        glMatrix.mat4.invert(normalMatrix, normalMatrix);
        glMatrix.mat4.transpose(normalMatrix, normalMatrix);
        for (var i = 0; i < normals.byteLength / 4; i += 3) {
            v[0] = normals[i];
            v[1] = normals[i + 1];
            v[2] = normals[i + 2];
            v[3] = 1;
            glMatrix.vec4.transformMat4(v, v, normalMatrix);
            normals[i] = v[0];
            normals[i + 1] = v[1];
            normals[i + 2] = v[2];
        }
        this.updateVertexBuffer(gPluginDeviceRenderer.VertexAttributeBufferIndex.NORMAL, gPluginDeviceRenderer.VertexAttributeLocation.NORMAL, 0, new Uint8Array(normals.buffer));
    };
    ProceduralGeometry.prototype.rebuildPosition = function () {
        this.topology = this.createTopology();
        var p = Float32Array.from(this.topology.positions);
        this.applyMa4Position(this.flipYMatrix, p);
        this.dirty = true;
    };
    ProceduralGeometry.prototype.applyMat4 = function (mat) {
        this.applyMa4Position(mat, this.vertices[gPluginDeviceRenderer.VertexAttributeBufferIndex.POSITION]);
        this.applyMa4Normal(mat, this.vertices[gPluginDeviceRenderer.VertexAttributeBufferIndex.NORMAL]);
        // transform tangent
    };
    ProceduralGeometry.prototype.computeBoundingBox = function () {
        var positions = this.topology.positions;
        var maxX = -Infinity;
        var maxY = -Infinity;
        var maxZ = -Infinity;
        var minX = Infinity;
        var minY = Infinity;
        var minZ = Infinity;
        for (var i = 0; i < positions.length; i += 3) {
            var x = positions[i];
            var y = positions[i + 1];
            var z = positions[i + 2];
            maxX = Math.max(maxX, x);
            maxY = Math.max(maxY, y);
            maxZ = Math.max(maxZ, z);
            minX = Math.min(minX, x);
            minY = Math.min(minY, y);
            minZ = Math.min(minZ, z);
        }
        var aabb = new gLite.AABB();
        aabb.setMinMax([minX, minY, minZ], [maxX, maxY, maxZ]);
        return aabb;
    };
    ProceduralGeometry.prototype.build = function () {
        var _a = this.topology, indices = _a.indices, positions = _a.positions, normals = _a.normals, uvs = _a.uvs;
        this.setIndexBuffer(new Uint32Array(indices));
        this.vertexCount = indices.length;
        this.setVertexBuffer({
            bufferIndex: gPluginDeviceRenderer.VertexAttributeBufferIndex.POSITION,
            byteStride: 4 * 3,
            stepMode: gDeviceApi.VertexStepMode.VERTEX,
            attributes: [
                {
                    format: gDeviceApi.Format.F32_RGB,
                    bufferByteOffset: 4 * 0,
                    location: gPluginDeviceRenderer.VertexAttributeLocation.POSITION,
                },
            ],
            data: Float32Array.from(positions),
        });
        this.setVertexBuffer({
            bufferIndex: gPluginDeviceRenderer.VertexAttributeBufferIndex.NORMAL,
            byteStride: 4 * 3,
            stepMode: gDeviceApi.VertexStepMode.VERTEX,
            attributes: [
                {
                    format: gDeviceApi.Format.F32_RGB,
                    bufferByteOffset: 4 * 0,
                    location: gPluginDeviceRenderer.VertexAttributeLocation.NORMAL,
                },
            ],
            data: Float32Array.from(normals),
        });
        this.setVertexBuffer({
            bufferIndex: gPluginDeviceRenderer.VertexAttributeBufferIndex.UV,
            byteStride: 4 * 2,
            stepMode: gDeviceApi.VertexStepMode.VERTEX,
            attributes: [
                {
                    format: gDeviceApi.Format.F32_RG,
                    bufferByteOffset: 4 * 0,
                    location: gPluginDeviceRenderer.VertexAttributeLocation.UV,
                },
            ],
            data: Float32Array.from(uvs),
        });
        this.applyMat4(this.flipYMatrix);
        this.dirty = true;
    };
    return ProceduralGeometry;
}(gPluginDeviceRenderer.BufferGeometry));

var primitiveUv1Padding = 4.0 / 64;
var primitiveUv1PaddingScale = 1.0 - primitiveUv1Padding * 2;
function createConeData(baseRadius, peakRadius, height, heightSegments, capSegments, roundedCaps) {
    // Variable declarations
    var i, j, x, y, z, u, v;
    var pos = glMatrix.vec3.create();
    var bottomToTop = glMatrix.vec3.create();
    var norm = glMatrix.vec3.create();
    var top, bottom, tangent;
    var positions = [];
    var normals = [];
    var uvs = [];
    var uvs1 = [];
    var indices = [];
    var theta, cosTheta, sinTheta;
    var phi, sinPhi, cosPhi;
    var first, second, third, fourth;
    var offset;
    // Define the body of the cone/cylinder
    if (height > 0) {
        for (i = 0; i <= heightSegments; i++) {
            for (j = 0; j <= capSegments; j++) {
                // Sweep the cone body from the positive Y axis to match a 3DS Max cone/cylinder
                theta = (j / capSegments) * 2.0 * Math.PI - Math.PI;
                sinTheta = Math.sin(theta);
                cosTheta = Math.cos(theta);
                bottom = glMatrix.vec3.fromValues(sinTheta * baseRadius, -height / 2.0, cosTheta * baseRadius);
                top = glMatrix.vec3.fromValues(sinTheta * peakRadius, height / 2.0, cosTheta * peakRadius);
                glMatrix.vec3.lerp(pos, bottom, top, i / heightSegments);
                glMatrix.vec3.normalize(bottomToTop, glMatrix.vec3.sub(bottomToTop, top, bottom));
                // bottomToTop.sub2(top, bottom).normalize();
                tangent = glMatrix.vec3.fromValues(cosTheta, 0.0, -sinTheta);
                glMatrix.vec3.normalize(norm, glMatrix.vec3.cross(norm, tangent, bottomToTop));
                // norm.cross(tangent, bottomToTop).normalize();
                positions.push(pos[0], pos[1], pos[2]);
                normals.push(norm[0], norm[1], norm[2]);
                u = j / capSegments;
                v = i / heightSegments;
                uvs.push(u, 1.0 - v);
                // Pack UV1 to 1st third
                var _v = v;
                v = u;
                u = _v;
                u /= 3;
                u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
                v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
                uvs1.push(u, 1.0 - v);
                if (i < heightSegments && j < capSegments) {
                    first = i * (capSegments + 1) + j;
                    second = i * (capSegments + 1) + (j + 1);
                    third = (i + 1) * (capSegments + 1) + j;
                    fourth = (i + 1) * (capSegments + 1) + (j + 1);
                    indices.push(first, second, third);
                    indices.push(second, fourth, third);
                }
            }
        }
    }
    if (roundedCaps) {
        var lat = void 0, lon = void 0;
        var latitudeBands = Math.floor(capSegments / 2);
        var longitudeBands = capSegments;
        var capOffset = height / 2;
        // Generate top cap
        for (lat = 0; lat <= latitudeBands; lat++) {
            theta = (lat * Math.PI * 0.5) / latitudeBands;
            sinTheta = Math.sin(theta);
            cosTheta = Math.cos(theta);
            for (lon = 0; lon <= longitudeBands; lon++) {
                // Sweep the sphere from the positive Z axis to match a 3DS Max sphere
                phi = (lon * 2 * Math.PI) / longitudeBands - Math.PI / 2.0;
                sinPhi = Math.sin(phi);
                cosPhi = Math.cos(phi);
                x = cosPhi * sinTheta;
                y = cosTheta;
                z = sinPhi * sinTheta;
                u = 1.0 - lon / longitudeBands;
                v = 1.0 - lat / latitudeBands;
                positions.push(x * peakRadius, y * peakRadius + capOffset, z * peakRadius);
                normals.push(x, y, z);
                uvs.push(u, 1.0 - v);
                // Pack UV1 to 2nd third
                u /= 3;
                v /= 3;
                u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
                v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
                u += 1.0 / 3;
                uvs1.push(u, 1.0 - v);
            }
        }
        offset = (heightSegments + 1) * (capSegments + 1);
        for (lat = 0; lat < latitudeBands; ++lat) {
            for (lon = 0; lon < longitudeBands; ++lon) {
                first = lat * (longitudeBands + 1) + lon;
                second = first + longitudeBands + 1;
                indices.push(offset + first + 1, offset + second, offset + first);
                indices.push(offset + first + 1, offset + second + 1, offset + second);
            }
        }
        // Generate bottom cap
        for (lat = 0; lat <= latitudeBands; lat++) {
            theta = Math.PI * 0.5 + (lat * Math.PI * 0.5) / latitudeBands;
            sinTheta = Math.sin(theta);
            cosTheta = Math.cos(theta);
            for (lon = 0; lon <= longitudeBands; lon++) {
                // Sweep the sphere from the positive Z axis to match a 3DS Max sphere
                phi = (lon * 2 * Math.PI) / longitudeBands - Math.PI / 2.0;
                sinPhi = Math.sin(phi);
                cosPhi = Math.cos(phi);
                x = cosPhi * sinTheta;
                y = cosTheta;
                z = sinPhi * sinTheta;
                u = 1.0 - lon / longitudeBands;
                v = 1.0 - lat / latitudeBands;
                positions.push(x * peakRadius, y * peakRadius - capOffset, z * peakRadius);
                normals.push(x, y, z);
                uvs.push(u, 1.0 - v);
                // Pack UV1 to 3rd third
                u /= 3;
                v /= 3;
                u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
                v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
                u += 2.0 / 3;
                uvs1.push(u, 1.0 - v);
            }
        }
        offset =
            (heightSegments + 1) * (capSegments + 1) +
                (longitudeBands + 1) * (latitudeBands + 1);
        for (lat = 0; lat < latitudeBands; ++lat) {
            for (lon = 0; lon < longitudeBands; ++lon) {
                first = lat * (longitudeBands + 1) + lon;
                second = first + longitudeBands + 1;
                indices.push(offset + first + 1, offset + second, offset + first);
                indices.push(offset + first + 1, offset + second + 1, offset + second);
            }
        }
    }
    else {
        // Generate bottom cap
        offset = (heightSegments + 1) * (capSegments + 1);
        if (baseRadius > 0.0) {
            for (i = 0; i < capSegments; i++) {
                theta = (i / capSegments) * 2.0 * Math.PI;
                x = Math.sin(theta);
                y = -height / 2.0;
                z = Math.cos(theta);
                u = 1.0 - (x + 1.0) / 2.0;
                v = (z + 1.0) / 2.0;
                positions.push(x * baseRadius, y, z * baseRadius);
                normals.push(0.0, -1.0, 0.0);
                uvs.push(u, 1.0 - v);
                // Pack UV1 to 2nd third
                u /= 3;
                v /= 3;
                u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
                v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
                u += 1.0 / 3;
                uvs1.push(u, 1.0 - v);
                if (i > 1) {
                    indices.push(offset, offset + i, offset + i - 1);
                }
            }
        }
        // Generate top cap
        offset += capSegments;
        if (peakRadius > 0.0) {
            for (i = 0; i < capSegments; i++) {
                theta = (i / capSegments) * 2.0 * Math.PI;
                x = Math.sin(theta);
                y = height / 2.0;
                z = Math.cos(theta);
                u = 1.0 - (x + 1.0) / 2.0;
                v = (z + 1.0) / 2.0;
                positions.push(x * peakRadius, y, z * peakRadius);
                normals.push(0.0, 1.0, 0.0);
                uvs.push(u, 1.0 - v);
                // Pack UV1 to 3rd third
                u /= 3;
                v /= 3;
                u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
                v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
                u += 2.0 / 3;
                uvs1.push(u, 1.0 - v);
                if (i > 1) {
                    indices.push(offset, offset + i - 1, offset + i);
                }
            }
        }
    }
    return {
        positions: positions,
        normals: normals,
        uvs: uvs,
        uvs1: uvs1,
        indices: indices,
    };
}

var CubeGeometry = /** @class */ (function (_super) {
    tslib.__extends(CubeGeometry, _super);
    function CubeGeometry(device, props) {
        if (props === void 0) { props = {}; }
        return _super.call(this, device, tslib.__assign({ width: 1, height: 1, depth: 1, widthSegments: 1, heightSegments: 1, depthSegments: 1 }, props)) || this;
    }
    Object.defineProperty(CubeGeometry.prototype, "width", {
        get: function () {
            return this.props.width;
        },
        set: function (v) {
            if (this.props.width !== v) {
                this.props.width = v;
                this.rebuildPosition();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CubeGeometry.prototype, "height", {
        get: function () {
            return this.props.height;
        },
        set: function (v) {
            if (this.props.height !== v) {
                this.props.height = v;
                this.rebuildPosition();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CubeGeometry.prototype, "depth", {
        get: function () {
            return this.props.depth;
        },
        set: function (v) {
            if (this.props.depth !== v) {
                this.props.depth = v;
                this.rebuildPosition();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CubeGeometry.prototype, "widthSegments", {
        get: function () {
            return this.props.widthSegments;
        },
        set: function (v) {
            if (this.props.widthSegments !== v) {
                this.props.widthSegments = v;
                this.build();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CubeGeometry.prototype, "heightSegments", {
        get: function () {
            return this.props.heightSegments;
        },
        set: function (v) {
            if (this.props.heightSegments !== v) {
                this.props.heightSegments = v;
                this.build();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CubeGeometry.prototype, "depthSegments", {
        get: function () {
            return this.props.depthSegments;
        },
        set: function (v) {
            if (this.props.depthSegments !== v) {
                this.props.depthSegments = v;
                this.build();
            }
        },
        enumerable: false,
        configurable: true
    });
    CubeGeometry.prototype.createTopology = function () {
        var _a = this.props, _b = _a.widthSegments, widthSegments = _b === void 0 ? 1 : _b, _c = _a.heightSegments, heightSegments = _c === void 0 ? 1 : _c, _d = _a.depthSegments, depthSegments = _d === void 0 ? 1 : _d, _e = _a.height, height = _e === void 0 ? 1 : _e, _f = _a.width, width = _f === void 0 ? 1 : _f, _g = _a.depth, depth = _g === void 0 ? 1 : _g;
        var ws = widthSegments;
        var hs = heightSegments;
        var ds = depthSegments;
        var hex = width / 2;
        var hey = height / 2;
        var hez = depth / 2;
        var corners = [
            glMatrix.vec3.fromValues(-hex, -hey, hez),
            glMatrix.vec3.fromValues(hex, -hey, hez),
            glMatrix.vec3.fromValues(hex, hey, hez),
            glMatrix.vec3.fromValues(-hex, hey, hez),
            glMatrix.vec3.fromValues(hex, -hey, -hez),
            glMatrix.vec3.fromValues(-hex, -hey, -hez),
            glMatrix.vec3.fromValues(-hex, hey, -hez),
            glMatrix.vec3.fromValues(hex, hey, -hez),
        ];
        var faceAxes = [
            [0, 1, 3], // FRONT
            [4, 5, 7], // BACK
            [3, 2, 6], // TOP
            [1, 0, 4], // BOTTOM
            [1, 4, 2], // RIGHT
            [5, 0, 6], // LEFT
        ];
        var faceNormals = [
            [0, 0, 1], // FRONT
            [0, 0, -1], // BACK
            [0, 1, 0], // TOP
            [0, -1, 0], // BOTTOM
            [1, 0, 0], // RIGHT
            [-1, 0, 0], // LEFT
        ];
        var sides = {
            FRONT: 0,
            BACK: 1,
            TOP: 2,
            BOTTOM: 3,
            RIGHT: 4,
            LEFT: 5,
        };
        var positions = [];
        var normals = [];
        var uvs = [];
        var uvs1 = [];
        var indices = [];
        var vcounter = 0;
        var generateFace = function (side, uSegments, vSegments) {
            var u;
            var v;
            var i;
            var j;
            for (i = 0; i <= uSegments; i++) {
                for (j = 0; j <= vSegments; j++) {
                    var temp1 = glMatrix.vec3.create();
                    var temp2 = glMatrix.vec3.create();
                    var temp3 = glMatrix.vec3.create();
                    var r = glMatrix.vec3.create();
                    glMatrix.vec3.lerp(temp1, corners[faceAxes[side][0]], corners[faceAxes[side][1]], i / uSegments);
                    glMatrix.vec3.lerp(temp2, corners[faceAxes[side][0]], corners[faceAxes[side][2]], j / vSegments);
                    glMatrix.vec3.sub(temp3, temp2, corners[faceAxes[side][0]]);
                    glMatrix.vec3.add(r, temp1, temp3);
                    u = i / uSegments;
                    v = j / vSegments;
                    positions.push(r[0], r[1], r[2]);
                    normals.push(faceNormals[side][0], faceNormals[side][1], faceNormals[side][2]);
                    uvs.push(u, 1.0 - v);
                    // pack as 3x2
                    // 1/3 will be empty, but it's either that or stretched pixels
                    // TODO: generate non-rectangular lightMaps, so we could use space without stretching
                    u /= 3;
                    v /= 3;
                    u = u * primitiveUv1PaddingScale + primitiveUv1Padding;
                    v = v * primitiveUv1PaddingScale + primitiveUv1Padding;
                    u += (side % 3) / 3;
                    v += Math.floor(side / 3) / 3;
                    uvs1.push(u, 1.0 - v);
                    if (i < uSegments && j < vSegments) {
                        indices.push(vcounter + vSegments + 1, vcounter + 1, vcounter);
                        indices.push(vcounter + vSegments + 1, vcounter + vSegments + 2, vcounter + 1);
                    }
                    vcounter++;
                }
            }
        };
        generateFace(sides.FRONT, ws, hs);
        generateFace(sides.BACK, ws, hs);
        generateFace(sides.TOP, ws, ds);
        generateFace(sides.BOTTOM, ws, ds);
        generateFace(sides.RIGHT, ds, hs);
        generateFace(sides.LEFT, ds, hs);
        return {
            indices: indices,
            positions: positions,
            normals: normals,
            uvs: uvs,
            uv1s: uvs1,
        };
    };
    return CubeGeometry;
}(ProceduralGeometry));

var SphereGeometry = /** @class */ (function (_super) {
    tslib.__extends(SphereGeometry, _super);
    function SphereGeometry(device, props) {
        if (props === void 0) { props = {}; }
        return _super.call(this, device, tslib.__assign({ radius: 0.5, latitudeBands: 16, longitudeBands: 16 }, props)) || this;
    }
    Object.defineProperty(SphereGeometry.prototype, "radius", {
        get: function () {
            return this.props.radius;
        },
        set: function (v) {
            if (this.props.radius !== v) {
                this.props.radius = v;
                this.build();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SphereGeometry.prototype, "latitudeBands", {
        get: function () {
            return this.props.latitudeBands;
        },
        set: function (v) {
            if (this.props.latitudeBands !== v) {
                this.props.latitudeBands = v;
                this.build();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(SphereGeometry.prototype, "longitudeBands", {
        get: function () {
            return this.props.longitudeBands;
        },
        set: function (v) {
            if (this.props.longitudeBands !== v) {
                this.props.longitudeBands = v;
                this.build();
            }
        },
        enumerable: false,
        configurable: true
    });
    SphereGeometry.prototype.createTopology = function () {
        var lon;
        var lat;
        var theta;
        var sinTheta;
        var cosTheta;
        var phi;
        var sinPhi;
        var cosPhi;
        var first;
        var second;
        var x;
        var y;
        var z;
        var u;
        var v;
        var _a = this.props, _b = _a.radius, radius = _b === void 0 ? 0.5 : _b, _c = _a.latitudeBands, latitudeBands = _c === void 0 ? 16 : _c, _d = _a.longitudeBands, longitudeBands = _d === void 0 ? 16 : _d;
        var positions = [];
        var normals = [];
        var uvs = [];
        var indices = [];
        for (lat = 0; lat <= latitudeBands; lat++) {
            theta = (lat * Math.PI) / latitudeBands;
            sinTheta = Math.sin(theta);
            cosTheta = Math.cos(theta);
            for (lon = 0; lon <= longitudeBands; lon++) {
                // Sweep the sphere from the positive Z axis to match a 3DS Max sphere
                phi = (lon * 2 * Math.PI) / longitudeBands - Math.PI / 2.0;
                sinPhi = Math.sin(phi);
                cosPhi = Math.cos(phi);
                x = cosPhi * sinTheta;
                y = cosTheta;
                z = sinPhi * sinTheta;
                u = 1.0 - lon / longitudeBands;
                v = 1.0 - lat / latitudeBands;
                positions.push(x * radius, y * radius, z * radius);
                normals.push(x, y, z);
                uvs.push(u, 1.0 - v);
            }
        }
        for (lat = 0; lat < latitudeBands; ++lat) {
            for (lon = 0; lon < longitudeBands; ++lon) {
                first = lat * (longitudeBands + 1) + lon;
                second = first + longitudeBands + 1;
                indices.push(first + 1, second, first);
                indices.push(first + 1, second + 1, second);
            }
        }
        return {
            indices: indices,
            positions: positions,
            normals: normals,
            uvs: uvs,
            uv1s: uvs,
        };
    };
    return SphereGeometry;
}(ProceduralGeometry));

var TorusGeometry = /** @class */ (function (_super) {
    tslib.__extends(TorusGeometry, _super);
    function TorusGeometry(device, props) {
        if (props === void 0) { props = {}; }
        return _super.call(this, device, tslib.__assign({ tubeRadius: 0.2, ringRadius: 0.3, segments: 30, sides: 20 }, props)) || this;
    }
    Object.defineProperty(TorusGeometry.prototype, "tubeRadius", {
        get: function () {
            return this.props.tubeRadius;
        },
        set: function (v) {
            if (this.props.tubeRadius !== v) {
                this.props.tubeRadius = v;
                this.build();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TorusGeometry.prototype, "ringRadius", {
        get: function () {
            return this.props.ringRadius;
        },
        set: function (v) {
            if (this.props.ringRadius !== v) {
                this.props.ringRadius = v;
                this.build();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TorusGeometry.prototype, "segments", {
        get: function () {
            return this.props.segments;
        },
        set: function (v) {
            if (this.props.segments !== v) {
                this.props.segments = v;
                this.build();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TorusGeometry.prototype, "sides", {
        get: function () {
            return this.props.sides;
        },
        set: function (v) {
            if (this.props.sides !== v) {
                this.props.sides = v;
                this.build();
            }
        },
        enumerable: false,
        configurable: true
    });
    TorusGeometry.prototype.createTopology = function () {
        var x;
        var y;
        var z;
        var nx;
        var ny;
        var nz;
        var u;
        var v;
        var i;
        var j;
        var _a = this.props, _b = _a.tubeRadius, tubeRadius = _b === void 0 ? 0.2 : _b, _c = _a.ringRadius, ringRadius = _c === void 0 ? 0.3 : _c, _d = _a.segments, segments = _d === void 0 ? 30 : _d, _e = _a.sides, sides = _e === void 0 ? 20 : _e;
        var rc = tubeRadius;
        var rt = ringRadius;
        var positions = [];
        var normals = [];
        var uvs = [];
        // const uvs1: number[] = [];
        var indices = [];
        for (i = 0; i <= sides; i++) {
            for (j = 0; j <= segments; j++) {
                x =
                    Math.cos((2.0 * Math.PI * j) / segments) *
                        (rt + rc * Math.cos((2.0 * Math.PI * i) / sides));
                y = Math.sin((2.0 * Math.PI * i) / sides) * rc;
                z =
                    Math.sin((2.0 * Math.PI * j) / segments) *
                        (rt + rc * Math.cos((2.0 * Math.PI * i) / sides));
                nx =
                    Math.cos((2.0 * Math.PI * j) / segments) *
                        Math.cos((2.0 * Math.PI * i) / sides);
                ny = Math.sin((2.0 * Math.PI * i) / sides);
                nz =
                    Math.sin((2.0 * Math.PI * j) / segments) *
                        Math.cos((2.0 * Math.PI * i) / sides);
                u = i / sides;
                v = 1.0 - j / segments;
                positions.push(x, y, z);
                normals.push(nx, ny, nz);
                uvs.push(u, 1.0 - v);
                if (i < sides && j < segments) {
                    var first = i * (segments + 1) + j;
                    var second = (i + 1) * (segments + 1) + j;
                    var third = i * (segments + 1) + (j + 1);
                    var fourth = (i + 1) * (segments + 1) + (j + 1);
                    indices.push(first, second, third);
                    indices.push(second, fourth, third);
                }
            }
        }
        return {
            indices: indices,
            positions: positions,
            normals: normals,
            uvs: uvs,
            uv1s: uvs,
        };
    };
    return TorusGeometry;
}(ProceduralGeometry));

var PlaneGeometry = /** @class */ (function (_super) {
    tslib.__extends(PlaneGeometry, _super);
    function PlaneGeometry(device, props) {
        if (props === void 0) { props = {}; }
        return _super.call(this, device, tslib.__assign({ width: 1, depth: 1, widthSegments: 5, depthSegments: 5 }, props)) || this;
    }
    Object.defineProperty(PlaneGeometry.prototype, "width", {
        get: function () {
            return this.props.width;
        },
        set: function (v) {
            if (this.props.width !== v) {
                this.props.width = v;
                this.rebuildPosition();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PlaneGeometry.prototype, "depth", {
        get: function () {
            return this.props.depth;
        },
        set: function (v) {
            if (this.props.depth !== v) {
                this.props.depth = v;
                this.rebuildPosition();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PlaneGeometry.prototype, "widthSegments", {
        get: function () {
            return this.props.widthSegments;
        },
        set: function (v) {
            if (this.props.widthSegments !== v) {
                this.props.widthSegments = v;
                this.build();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PlaneGeometry.prototype, "depthSegments", {
        get: function () {
            return this.props.depthSegments;
        },
        set: function (v) {
            if (this.props.depthSegments !== v) {
                this.props.depthSegments = v;
                this.build();
            }
        },
        enumerable: false,
        configurable: true
    });
    PlaneGeometry.prototype.createTopology = function () {
        var positions = [];
        var normals = [];
        var uvs = [];
        var indices = [];
        var _a = this.props, _b = _a.widthSegments, widthSegments = _b === void 0 ? 5 : _b, _c = _a.depthSegments, depthSegments = _c === void 0 ? 5 : _c, _d = _a.width, width = _d === void 0 ? 1 : _d, _e = _a.depth, depth = _e === void 0 ? 1 : _e;
        var he = { x: width / 2, y: depth / 2 };
        var ws = widthSegments;
        var ls = depthSegments;
        // Variable declarations
        var i;
        var j;
        var x;
        var y;
        var z;
        var u;
        var v;
        // Generate plane as follows (assigned UVs denoted at corners):
        // (0,1)x---------x(1,1)
        //      |         |
        //      |         |
        //      |    O--X |length
        //      |    |    |
        //      |    Z    |
        // (0,0)x---------x(1,0)
        // width
        var vcounter = 0;
        for (i = 0; i <= ws; i++) {
            for (j = 0; j <= ls; j++) {
                x = -he.x + (2.0 * he.x * i) / ws;
                y = 0.0;
                z = -(-he.y + (2.0 * he.y * j) / ls);
                u = i / ws;
                v = j / ls;
                positions.push(x, y, z);
                normals.push(0.0, 1.0, 0.0);
                uvs.push(u, 1.0 - v);
                if (i < ws && j < ls) {
                    indices.push(vcounter + ls + 1, vcounter + 1, vcounter);
                    indices.push(vcounter + ls + 1, vcounter + ls + 2, vcounter + 1);
                }
                vcounter++;
            }
        }
        return {
            indices: indices,
            positions: positions,
            normals: normals,
            uvs: uvs,
            uv1s: uvs,
        };
    };
    return PlaneGeometry;
}(ProceduralGeometry));

var CylinderGeometry = /** @class */ (function (_super) {
    tslib.__extends(CylinderGeometry, _super);
    function CylinderGeometry(device, props) {
        if (props === void 0) { props = {}; }
        return _super.call(this, device, tslib.__assign({ radius: 0.5, height: 1, heightSegments: 5, capSegments: 20 }, props)) || this;
    }
    Object.defineProperty(CylinderGeometry.prototype, "radius", {
        get: function () {
            return this.props.radius;
        },
        set: function (v) {
            if (this.props.radius !== v) {
                this.props.radius = v;
                this.rebuildPosition();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CylinderGeometry.prototype, "height", {
        get: function () {
            return this.props.height;
        },
        set: function (v) {
            if (this.props.height !== v) {
                this.props.height = v;
                this.rebuildPosition();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CylinderGeometry.prototype, "heightSegments", {
        get: function () {
            return this.props.heightSegments;
        },
        set: function (v) {
            if (this.props.heightSegments !== v) {
                this.props.heightSegments = v;
                this.build();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CylinderGeometry.prototype, "capSegments", {
        get: function () {
            return this.props.capSegments;
        },
        set: function (v) {
            if (this.props.capSegments !== v) {
                this.props.capSegments = v;
                this.build();
            }
        },
        enumerable: false,
        configurable: true
    });
    CylinderGeometry.prototype.createTopology = function () {
        var _a = this.props, radius = _a.radius, height = _a.height, heightSegments = _a.heightSegments, capSegments = _a.capSegments;
        var _b = createConeData(radius, radius, height, heightSegments, capSegments, false), indices = _b.indices, positions = _b.positions, normals = _b.normals, uvs = _b.uvs, uvs1 = _b.uvs1;
        return {
            indices: indices,
            positions: positions,
            normals: normals,
            uvs: uvs,
            uv1s: uvs1,
        };
    };
    return CylinderGeometry;
}(ProceduralGeometry));

var ConeGeometry = /** @class */ (function (_super) {
    tslib.__extends(ConeGeometry, _super);
    function ConeGeometry(device, props) {
        if (props === void 0) { props = {}; }
        return _super.call(this, device, tslib.__assign({ baseRadius: 0.5, peakRadius: 0, height: 1, heightSegments: 5, capSegments: 18 }, props)) || this;
    }
    Object.defineProperty(ConeGeometry.prototype, "baseRadius", {
        get: function () {
            return this.props.baseRadius;
        },
        set: function (v) {
            if (this.props.baseRadius !== v) {
                this.props.baseRadius = v;
                this.rebuildPosition();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConeGeometry.prototype, "peakRadius", {
        get: function () {
            return this.props.peakRadius;
        },
        set: function (v) {
            if (this.props.peakRadius !== v) {
                this.props.peakRadius = v;
                this.rebuildPosition();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConeGeometry.prototype, "height", {
        get: function () {
            return this.props.height;
        },
        set: function (v) {
            if (this.props.height !== v) {
                this.props.height = v;
                this.rebuildPosition();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConeGeometry.prototype, "heightSegments", {
        get: function () {
            return this.props.heightSegments;
        },
        set: function (v) {
            if (this.props.heightSegments !== v) {
                this.props.heightSegments = v;
                this.build();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(ConeGeometry.prototype, "capSegments", {
        get: function () {
            return this.props.capSegments;
        },
        set: function (v) {
            if (this.props.capSegments !== v) {
                this.props.capSegments = v;
                this.build();
            }
        },
        enumerable: false,
        configurable: true
    });
    ConeGeometry.prototype.createTopology = function () {
        var _a = this.props, baseRadius = _a.baseRadius, peakRadius = _a.peakRadius, height = _a.height, heightSegments = _a.heightSegments, capSegments = _a.capSegments;
        var _b = createConeData(baseRadius, peakRadius, height, heightSegments, capSegments, false), indices = _b.indices, positions = _b.positions, normals = _b.normals, uvs = _b.uvs, uvs1 = _b.uvs1;
        return {
            indices: indices,
            positions: positions,
            normals: normals,
            uvs: uvs,
            uv1s: uvs1,
        };
    };
    return ConeGeometry;
}(ProceduralGeometry));

var CapsuleGeometry = /** @class */ (function (_super) {
    tslib.__extends(CapsuleGeometry, _super);
    function CapsuleGeometry(device, props) {
        if (props === void 0) { props = {}; }
        return _super.call(this, device, tslib.__assign({ radius: 0.5, height: 1, heightSegments: 1, sides: 20 }, props)) || this;
    }
    Object.defineProperty(CapsuleGeometry.prototype, "radius", {
        get: function () {
            return this.props.radius;
        },
        set: function (v) {
            if (this.props.radius !== v) {
                this.props.radius = v;
                this.rebuildPosition();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CapsuleGeometry.prototype, "height", {
        get: function () {
            return this.props.height;
        },
        set: function (v) {
            if (this.props.height !== v) {
                this.props.height = v;
                this.rebuildPosition();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CapsuleGeometry.prototype, "heightSegments", {
        get: function () {
            return this.props.heightSegments;
        },
        set: function (v) {
            if (this.props.heightSegments !== v) {
                this.props.heightSegments = v;
                this.build();
            }
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(CapsuleGeometry.prototype, "sides", {
        get: function () {
            return this.props.sides;
        },
        set: function (v) {
            if (this.props.sides !== v) {
                this.props.sides = v;
                this.build();
            }
        },
        enumerable: false,
        configurable: true
    });
    CapsuleGeometry.prototype.createTopology = function () {
        var _a = this.props, radius = _a.radius, height = _a.height, heightSegments = _a.heightSegments, sides = _a.sides;
        var _b = createConeData(radius, radius, height - 2 * radius, heightSegments, sides, true), indices = _b.indices, positions = _b.positions, normals = _b.normals, uvs = _b.uvs, uvs1 = _b.uvs1;
        return {
            indices: indices,
            positions: positions,
            normals: normals,
            uvs: uvs,
            uv1s: uvs1,
        };
    };
    return CapsuleGeometry;
}(ProceduralGeometry));

var AmbientLight = /** @class */ (function (_super) {
    tslib.__extends(AmbientLight, _super);
    function AmbientLight(_a) {
        if (_a === void 0) { _a = {}; }
        var _this = this;
        var style = _a.style, rest = tslib.__rest(_a, ["style"]);
        _this = _super.call(this, tslib.__assign({ style: tslib.__assign({ fill: 'black' }, style) }, rest)) || this;
        _this.define = 'NUM_AMBIENT_LIGHTS';
        _this.order = -1;
        return _this;
    }
    // getUniformWordCount() {
    //   return 4;
    // }
    AmbientLight.prototype.uploadUBO = function (uniforms, index) {
        var fill = this.parsedStyle.fill;
        if (gLite.isCSSRGB(fill)) {
            var fillColor = [
                Number(fill.r) / 255,
                Number(fill.g) / 255,
                Number(fill.b) / 255,
            ];
            uniforms.push({
                name: 'u_AmbientLightColor',
                value: fillColor,
            });
        }
    };
    return AmbientLight;
}(gPluginDeviceRenderer.Light));

var DirectionalLight = /** @class */ (function (_super) {
    tslib.__extends(DirectionalLight, _super);
    function DirectionalLight(_a) {
        if (_a === void 0) { _a = {}; }
        var _this = this;
        var style = _a.style, rest = tslib.__rest(_a, ["style"]);
        _this = _super.call(this, tslib.__assign({ style: tslib.__assign({ direction: glMatrix.vec3.fromValues(0, -1, 0) }, style) }, rest)) || this;
        _this.define = 'NUM_DIR_LIGHTS';
        _this.order = 10;
        return _this;
    }
    DirectionalLight.prototype.getUniformWordCount = function () {
        return 4 + 4;
    };
    DirectionalLight.prototype.uploadUBO = function (uniforms, index) {
        var _a = this.parsedStyle, fill = _a.fill, direction = _a.direction, intensity = _a.intensity;
        if (gLite.isCSSRGB(fill)) {
            var fillColor = [
                Number(fill.r) / 255,
                Number(fill.g) / 255,
                Number(fill.b) / 255,
            ];
            uniforms.push({
                name: "directionalLights[".concat(index, "].direction"),
                value: direction,
            });
            uniforms.push({
                name: "directionalLights[".concat(index, "].intensity"),
                value: intensity,
            });
            uniforms.push({
                name: "directionalLights[".concat(index, "].color"),
                value: fillColor,
            });
        }
    };
    return DirectionalLight;
}(gPluginDeviceRenderer.Light));

var vert$3 = "#define GLSLIFY 1\nlayout(std140) uniform ub_SceneParams {\n  mat4 u_ProjectionMatrix;\n  mat4 u_ViewMatrix;\n  vec3 u_CameraPosition;\n  float u_DevicePixelRatio;\n  vec2 u_Viewport;\n  float u_IsOrtho;\n  float u_IsPicking;\n};\nlayout(std140) uniform ub_MaterialParams {\n  #ifdef USE_WIREFRAME\n    vec3 u_WireframeLineColor;\n    float u_WireframeLineWidth;\n  #endif\n\n  #ifdef USE_FOG\n    vec4 u_FogInfos;\n    vec3 u_FogColor;\n  #endif\n\n  vec4 u_Placeholder;\n};\n\nlayout(location = MODEL_MATRIX0) in vec4 a_ModelMatrix0;\nlayout(location = MODEL_MATRIX1) in vec4 a_ModelMatrix1;\nlayout(location = MODEL_MATRIX2) in vec4 a_ModelMatrix2;\nlayout(location = MODEL_MATRIX3) in vec4 a_ModelMatrix3;\nlayout(location = PACKED_COLOR) in vec4 a_PackedColor;\nlayout(location = PACKED_STYLE1) in vec4 a_StylePacked1;\nlayout(location = PACKED_STYLE2) in vec4 a_StylePacked2;\nlayout(location = PICKING_COLOR) in vec4 a_PickingColor;\n\nout vec4 v_PickingResult;\nout vec4 v_Color;\nout vec4 v_StrokeColor;\nout vec4 v_StylePacked1;\nout vec4 v_StylePacked2;\n\n#define COLOR_SCALE 1. / 255.\nvoid setPickingColor(vec3 pickingColor) {\n  v_PickingResult.rgb = pickingColor * COLOR_SCALE;\n}\n\nvec2 unpack_float(const float packedValue) {\n  int packedIntValue = int(packedValue);\n  int v0 = packedIntValue / 256;\n  return vec2(v0, packedIntValue - v0 * 256);\n}\nvec4 decode_color(const vec2 encodedColor) {\n  return vec4(\n    unpack_float(encodedColor[0]) / 255.0,\n    unpack_float(encodedColor[1]) / 255.0\n  );\n}\nvec4 project(vec4 pos, mat4 pm, mat4 vm, mat4 mm) {\n  return pm * vm * mm * pos;\n}\n\nlayout(location = POSITION) in vec3 a_Position;\n\n#ifdef USE_UV\n  layout(location = UV) in vec2 a_Uv;\n  out vec2 v_Uv;\n#endif\n\n#ifdef USE_WIREFRAME\n  layout(location = BARYCENTRIC) in vec3 a_Barycentric;\n  out vec3 v_Barycentric;\n#endif\n\nvoid main() {\n  // WGSL will remove unused uniforms.\n  float a = u_Placeholder.x;\n\n  vec4 a_Color = decode_color(a_PackedColor.xy);\nvec4 a_StrokeColor = decode_color(a_PackedColor.zw);\n\nmat4 u_ModelMatrix = mat4(a_ModelMatrix0, a_ModelMatrix1, a_ModelMatrix2, a_ModelMatrix3);\nvec4 u_StrokeColor = a_StrokeColor;\nfloat u_Opacity = a_StylePacked1.x;\nfloat u_FillOpacity = a_StylePacked1.y;\nfloat u_StrokeOpacity = a_StylePacked1.z;\nfloat u_StrokeWidth = a_StylePacked1.w;\nfloat u_ZIndex = a_PickingColor.w;\nvec2 u_Anchor = a_StylePacked2.yz;\nfloat u_IncreasedLineWidthForHitTesting = a_StylePacked2.w;\n\nsetPickingColor(a_PickingColor.xyz);\n\nv_Color = a_Color;\nv_StrokeColor = a_StrokeColor;\nv_StylePacked1 = a_StylePacked1;\nv_StylePacked2 = a_StylePacked2;\n\n// #ifdef CLIPSPACE_NEAR_ZERO\n//     gl_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n// #endif\n\n  gl_Position = project(vec4(a_Position, 1.0), u_ProjectionMatrix, u_ViewMatrix, u_ModelMatrix);\n\n  #ifdef USE_UV\n  v_Uv = a_Uv;\n#endif\n\n  #ifdef USE_WIREFRAME\n  v_Barycentric = a_Barycentric;\n#endif\n\n}"; // eslint-disable-line

var frag$3 = "#define GLSLIFY 1\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n\n#ifndef saturate\n  #define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\n\nfloat pow2( float x ) { return x*x; }\nfloat pow3( float x ) { return x*x*x; }\nfloat pow4( float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand( vec2 uv ) {\n  const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n  highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\n  return fract( sin( sn ) * c );\n}\n\nmat3 transposeMat3(mat3 inMatrix) {\n  vec3 i0 = inMatrix[0];\n  vec3 i1 = inMatrix[1];\n  vec3 i2 = inMatrix[2];\n\n  mat3 outMatrix = mat3(\n    vec3(i0.x, i1.x, i2.x),\n    vec3(i0.y, i1.y, i2.y),\n    vec3(i0.z, i1.z, i2.z)\n    );\n\n  return outMatrix;\n}\n\n// https://github.com/glslify/glsl-inverse/blob/master/index.glsl\nmat3 inverseMat3(mat3 inMatrix) {\n  float a00 = inMatrix[0][0], a01 = inMatrix[0][1], a02 = inMatrix[0][2];\n  float a10 = inMatrix[1][0], a11 = inMatrix[1][1], a12 = inMatrix[1][2];\n  float a20 = inMatrix[2][0], a21 = inMatrix[2][1], a22 = inMatrix[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n          b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n          b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nstruct DirectionalLight {\n  vec3 direction;\n  float intensity;\n  vec3 color;\n};\n\nstruct IncidentLight {\n  vec3 color;\n  vec3 direction;\n  bool visible;\n};\n\nstruct ReflectedLight {\n  vec3 directDiffuse;\n  vec3 directSpecular;\n  vec3 indirectDiffuse;\n  vec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n  vec3 position;\n  vec3 normal;\n  vec3 viewDir;\n};\nlayout(std140) uniform ub_SceneParams {\n  mat4 u_ProjectionMatrix;\n  mat4 u_ViewMatrix;\n  vec3 u_CameraPosition;\n  float u_DevicePixelRatio;\n  vec2 u_Viewport;\n  float u_IsOrtho;\n  float u_IsPicking;\n};\nlayout(std140) uniform ub_MaterialParams {\n  #ifdef USE_WIREFRAME\n    vec3 u_WireframeLineColor;\n    float u_WireframeLineWidth;\n  #endif\n\n  #ifdef USE_FOG\n    vec4 u_FogInfos;\n    vec3 u_FogColor;\n  #endif\n\n  vec4 u_Placeholder;\n};\n\nin vec4 v_PickingResult;\nin vec4 v_Color;\nin vec4 v_StrokeColor;\nin vec4 v_StylePacked1;\nin vec4 v_StylePacked2;\n#ifdef USE_UV\n  in vec2 v_Uv;\n#endif\n#ifdef USE_MAP\n  uniform sampler2D u_Map;\n#endif\n#ifdef USE_WIREFRAME\n  in vec3 v_Barycentric;\n\n  float edgeFactor() {\n    vec3 d = fwidth(v_Barycentric);\n    vec3 a3 = smoothstep(vec3(0.0), d * u_WireframeLineWidth, v_Barycentric);\n    return min(min(a3.x, a3.y), a3.z);\n  }\n#endif\n\n#ifdef USE_FOG\n  #define FOGMODE_NONE 0.\n  #define FOGMODE_EXP 1.\n  #define FOGMODE_EXP2 2.\n  #define FOGMODE_LINEAR 3.\n\n  // in float v_FogDepth;\n\n  float dBlendModeFogFactor = 1.0;\n\n  vec3 addFog(vec3 color) {\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    // float depth = v_FogDepth;\n    float fogFactor;\n    float fogStart = u_FogInfos.y;\n    float fogEnd = u_FogInfos.z;\n    float fogDensity = u_FogInfos.w;\n\n    if (u_FogInfos.x == FOGMODE_NONE) {\n      fogFactor = 1.0;\n    } else if (u_FogInfos.x == FOGMODE_EXP) {\n      fogFactor = exp(-depth * fogDensity);\n    } else if (u_FogInfos.x == FOGMODE_EXP2) {\n      fogFactor = exp(-depth * depth * fogDensity * fogDensity);\n    } else if (u_FogInfos.x == FOGMODE_LINEAR) {\n      fogFactor = (fogEnd - depth) / (fogEnd - fogStart);\n    }\n\n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n    return mix(u_FogColor * dBlendModeFogFactor, color, fogFactor);\n  }\n#endif\n\nout vec4 outputColor;\n\nvoid main() {\n  vec4 u_Color = v_Color;\nvec4 u_StrokeColor = v_StrokeColor;\nfloat u_Opacity = v_StylePacked1.x;\nfloat u_FillOpacity = v_StylePacked1.y;\nfloat u_StrokeOpacity = v_StylePacked1.z;\nfloat u_StrokeWidth = v_StylePacked1.w;\nfloat u_Visible = v_StylePacked2.x;\nvec3 u_PickingColor = v_PickingResult.xyz;\n\nif (u_Visible < 0.5) {\n    discard;\n}\n  #ifdef USE_MAP\n  #ifdef USE_PATTERN\n    vec4 texelColor = texture(SAMPLER_2D(u_Map), v_Uv);\n    u_Color = texelColor;\n  #else\n    vec4 texelColor = texture(SAMPLER_2D(u_Map), v_Uv);\n    u_Color = texelColor;\n  #endif\n#endif\n\n  if (u_IsPicking > 0.5) {\n    if (u_PickingColor.x == 0.0 && u_PickingColor.y == 0.0 && u_PickingColor.z == 0.0) {\n      discard;\n    }\n    outputColor = vec4(u_PickingColor, 1.0);\n  } else {\n    outputColor = u_Color;\n    outputColor.a = outputColor.a * u_Opacity;\n    vec4 diffuseColor = outputColor;\n\n    ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n    reflectedLight.indirectDiffuse += vec3( 1.0 );\n    reflectedLight.indirectDiffuse *= outputColor.rgb;\n\n    vec3 outgoingLight = reflectedLight.indirectDiffuse;\n    \n    outputColor = vec4(outgoingLight, diffuseColor.a);\n\n    #ifdef USE_WIREFRAME\n  vec3 color = mix(outputColor.xyz, u_WireframeLineColor, (1.0 - edgeFactor()));\n  outputColor.xyz = color;\n#endif\n    #ifdef USE_FOG\n  outputColor.rgb = addFog(outputColor.rgb);\n#endif\n  }\n}"; // eslint-disable-line

var Uniform$3;
(function (Uniform) {
    Uniform["MAP"] = "u_Map";
    Uniform["PLACE_HOLDER"] = "u_Placeholder";
})(Uniform$3 || (Uniform$3 = {}));
/**
 * not affected by lights
 * @see https://threejs.org/docs/#api/en/materials/MeshBasicMaterial
 */
var MeshBasicMaterial = /** @class */ (function (_super) {
    tslib.__extends(MeshBasicMaterial, _super);
    function MeshBasicMaterial(device, props) {
        var _a;
        var _this = _super.call(this, device, tslib.__assign({ vertexShader: vert$3, fragmentShader: frag$3, cullMode: gDeviceApi.CullMode.BACK }, props)) || this;
        _this.defines = tslib.__assign(tslib.__assign({}, _this.defines), { USE_UV: true, USE_MAP: false, USE_WIREFRAME: false, USE_FOG: false, USE_LIGHT: false });
        var _b = props || {}, map = _b.map, wireframe = _b.wireframe;
        if (map) {
            _this.map = map;
        }
        _this.wireframe = wireframe;
        _this.setUniforms((_a = {},
            _a[Uniform$3.PLACE_HOLDER] = [0, 0, 0, 0],
            _a));
        return _this;
    }
    Object.defineProperty(MeshBasicMaterial.prototype, "map", {
        /**
         * color map, will override fill color
         */
        get: function () {
            return this.props.map;
        },
        set: function (v) {
            var _a;
            if (this.props.map !== v) {
                this.props.map = v;
                this.programDirty = true;
            }
            this.setUniforms((_a = {},
                _a[Uniform$3.MAP] = v,
                _a));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MeshBasicMaterial.prototype, "aoMap", {
        /**
         * AO map
         */
        get: function () {
            return this.props.aoMap;
        },
        set: function (v) {
            this.props.aoMap = v;
        },
        enumerable: false,
        configurable: true
    });
    return MeshBasicMaterial;
}(gPluginDeviceRenderer.Material));

var frag$2 = "#define GLSLIFY 1\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n\n#ifndef saturate\n  #define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\n\nfloat pow2( float x ) { return x*x; }\nfloat pow3( float x ) { return x*x*x; }\nfloat pow4( float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand( vec2 uv ) {\n  const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n  highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\n  return fract( sin( sn ) * c );\n}\n\nmat3 transposeMat3(mat3 inMatrix) {\n  vec3 i0 = inMatrix[0];\n  vec3 i1 = inMatrix[1];\n  vec3 i2 = inMatrix[2];\n\n  mat3 outMatrix = mat3(\n    vec3(i0.x, i1.x, i2.x),\n    vec3(i0.y, i1.y, i2.y),\n    vec3(i0.z, i1.z, i2.z)\n    );\n\n  return outMatrix;\n}\n\n// https://github.com/glslify/glsl-inverse/blob/master/index.glsl\nmat3 inverseMat3(mat3 inMatrix) {\n  float a00 = inMatrix[0][0], a01 = inMatrix[0][1], a02 = inMatrix[0][2];\n  float a10 = inMatrix[1][0], a11 = inMatrix[1][1], a12 = inMatrix[1][2];\n  float a20 = inMatrix[2][0], a21 = inMatrix[2][1], a22 = inMatrix[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n          b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n          b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nstruct DirectionalLight {\n  vec3 direction;\n  float intensity;\n  vec3 color;\n};\n\nstruct IncidentLight {\n  vec3 color;\n  vec3 direction;\n  bool visible;\n};\n\nstruct ReflectedLight {\n  vec3 directDiffuse;\n  vec3 directSpecular;\n  vec3 indirectDiffuse;\n  vec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n  vec3 position;\n  vec3 normal;\n  vec3 viewDir;\n};\nlayout(std140) uniform ub_SceneParams {\n  mat4 u_ProjectionMatrix;\n  mat4 u_ViewMatrix;\n  vec3 u_CameraPosition;\n  float u_DevicePixelRatio;\n  vec2 u_Viewport;\n  float u_IsOrtho;\n  float u_IsPicking;\n};\nlayout(std140) uniform ub_MaterialParams {\n  #ifdef USE_WIREFRAME\n    vec3 u_WireframeLineColor;\n    float u_WireframeLineWidth;\n  #endif\n\n  #ifdef USE_FOG\n    vec4 u_FogInfos;\n    vec3 u_FogColor;\n  #endif\n\n  vec3 u_Emissive;\n  float u_Shininess;\n  vec3 u_Specular;\n\n  #ifdef USE_LIGHT\n    #ifdef USE_BUMPMAP\n      float u_BumpScale;\n    #endif\n\n    #ifdef NUM_AMBIENT_LIGHTS\n      vec3 u_AmbientLightColor;\n    #endif\n\n    #ifdef NUM_DIR_LIGHTS\n      DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n    #endif\n  #endif\n};\n\nin vec4 v_PickingResult;\nin vec4 v_Color;\nin vec4 v_StrokeColor;\nin vec4 v_StylePacked1;\nin vec4 v_StylePacked2;\n#ifdef USE_UV\n  in vec2 v_Uv;\n#endif\n#ifdef USE_MAP\n  uniform sampler2D u_Map;\n#endif\n#if defined(USE_BUMPMAP) && defined(USE_LIGHT)\n  uniform sampler2D u_BumpMap;\n\n  // Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n  // http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\n  // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n  vec2 dHdxy_fwd() {\n    vec2 dSTdx = dFdx( v_Uv );\n    vec2 dSTdy = dFdy( v_Uv );\n\n    float Hll = u_BumpScale * texture(SAMPLER_2D(u_BumpMap), v_Uv ).x;\n    float dBx = u_BumpScale * texture(SAMPLER_2D(u_BumpMap), v_Uv + dSTdx ).x - Hll;\n    float dBy = u_BumpScale * texture(SAMPLER_2D(u_BumpMap), v_Uv + dSTdy ).x - Hll;\n\n    return vec2( dBx, dBy );\n  }\n\n  vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\n    // Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n    vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n    vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n    vec3 vN = surf_norm;\t\t// normalized\n\n    vec3 R1 = cross( vSigmaY, vN );\n    vec3 R2 = cross( vN, vSigmaX );\n\n    float fDet = dot( vSigmaX, R1 ) * faceDirection;\n\n    vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n    return normalize( abs( fDet ) * surf_norm - vGrad );\n  }\n#endif\n#ifdef USE_SPECULARMAP\n  uniform sampler2D u_SpecularMap;\n#endif\nvec3 BRDF_Lambert(vec3 diffuseColor) {\n  return RECIPROCAL_PI * diffuseColor;\n}\n\nvec3 F_Schlick(\n  vec3 f0,\n  float f90,\n  float dotVH\n) {\n  // Original approximation by Christophe Schlick '94\n  // float fresnel = pow( 1.0 - dotVH, 5.0 );\n\n  // Optimized variant (presented by Epic at SIGGRAPH '13)\n  // https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n  float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n  return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\n\nfloat G_BlinnPhong_Implicit( /* float dotNL, float dotNV */ ) {\n  // geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\n  return 0.25;\n}\n\nfloat D_BlinnPhong(\n  float shininess,\n  float dotNH\n) {\n  return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\n\nvec3 BRDF_BlinnPhong(\n  vec3 lightDir,\n  vec3 viewDir,\n  vec3 normal,\n  vec3 specularColor,\n  float shininess\n) {\n  vec3 halfDir = normalize( lightDir + viewDir );\n\n  float dotNH = saturate( dot( normal, halfDir ) );\n  float dotVH = saturate( dot( viewDir, halfDir ) );\n\n  vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\n  float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n  float D = D_BlinnPhong( shininess, dotNH );\n\n  return F * ( G * D );\n}\n\n#ifdef USE_WIREFRAME\n  in vec3 v_Barycentric;\n\n  float edgeFactor() {\n    vec3 d = fwidth(v_Barycentric);\n    vec3 a3 = smoothstep(vec3(0.0), d * u_WireframeLineWidth, v_Barycentric);\n    return min(min(a3.x, a3.y), a3.z);\n  }\n#endif\n\n#ifdef USE_FOG\n  #define FOGMODE_NONE 0.\n  #define FOGMODE_EXP 1.\n  #define FOGMODE_EXP2 2.\n  #define FOGMODE_LINEAR 3.\n\n  // in float v_FogDepth;\n\n  float dBlendModeFogFactor = 1.0;\n\n  vec3 addFog(vec3 color) {\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    // float depth = v_FogDepth;\n    float fogFactor;\n    float fogStart = u_FogInfos.y;\n    float fogEnd = u_FogInfos.z;\n    float fogDensity = u_FogInfos.w;\n\n    if (u_FogInfos.x == FOGMODE_NONE) {\n      fogFactor = 1.0;\n    } else if (u_FogInfos.x == FOGMODE_EXP) {\n      fogFactor = exp(-depth * fogDensity);\n    } else if (u_FogInfos.x == FOGMODE_EXP2) {\n      fogFactor = exp(-depth * depth * fogDensity * fogDensity);\n    } else if (u_FogInfos.x == FOGMODE_LINEAR) {\n      fogFactor = (fogEnd - depth) / (fogEnd - fogStart);\n    }\n\n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n    return mix(u_FogColor * dBlendModeFogFactor, color, fogFactor);\n  }\n#endif\n\n#ifdef USE_LIGHT\n  void getDirectionalLightInfo(\n    DirectionalLight directionalLight, \n    GeometricContext geometry,\n    out IncidentLight light\n  ) {\n    light.color = directionalLight.color * directionalLight.intensity;\n    light.direction = normalize(directionalLight.direction);\n    light.visible = true;\n  }\n\n  vec3 getAmbientLightIrradiance( vec3 ambientLightColor ) {\n    vec3 irradiance = ambientLightColor;\n    return irradiance;\n  }\n#endif\nstruct BlinnPhongMaterial {\n  vec3 diffuseColor;\n  vec3 specularColor;\n  float specularShininess;\n  float specularStrength;\n};\n\nvoid RE_Direct_BlinnPhong(\n  IncidentLight directLight,\n  GeometricContext geometry,\n  BlinnPhongMaterial material,\n  inout ReflectedLight reflectedLight\n) {\n  float dotNL = saturate(dot(geometry.normal, directLight.direction));\n  vec3 irradiance = dotNL * directLight.color;\n\n  reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\n  reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\n\nvoid RE_IndirectDiffuse_BlinnPhong(\n  vec3 irradiance,\n  GeometricContext geometry,\n  BlinnPhongMaterial material,\n  inout ReflectedLight reflectedLight\n) {\n  reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n\n#define RE_Direct           RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse  RE_IndirectDiffuse_BlinnPhong\n\nin vec3 v_ViewPosition;\nin vec3 v_Normal;\n\nout vec4 outputColor;\n\nvoid main() {\n  vec4 u_Color = v_Color;\nvec4 u_StrokeColor = v_StrokeColor;\nfloat u_Opacity = v_StylePacked1.x;\nfloat u_FillOpacity = v_StylePacked1.y;\nfloat u_StrokeOpacity = v_StylePacked1.z;\nfloat u_StrokeWidth = v_StylePacked1.w;\nfloat u_Visible = v_StylePacked2.x;\nvec3 u_PickingColor = v_PickingResult.xyz;\n\nif (u_Visible < 0.5) {\n    discard;\n}\n\n  // diffusemap\n  #ifdef USE_MAP\n  #ifdef USE_PATTERN\n    vec4 texelColor = texture(SAMPLER_2D(u_Map), v_Uv);\n    u_Color = texelColor;\n  #else\n    vec4 texelColor = texture(SAMPLER_2D(u_Map), v_Uv);\n    u_Color = texelColor;\n  #endif\n#endif\n  // specularmap\n  float specularStrength = 1.0;\n\n#ifdef USE_SPECULARMAP\n  vec4 texelSpecular = texture(SAMPLER_2D(u_SpecularMap), v_Uv);\n  specularStrength = texelSpecular.r;\n#endif\n  // bumpmap & normalmap\n  float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\nvec3 normal = normalize(v_Normal);\n#ifdef USE_DOUBLESIDE\n  normal = normal * faceDirection;\n#endif\n\n// #ifdef USE_TANGENT\n//   vec3 tangent = normalize( vTangent );\n//   vec3 bitangent = normalize( vBitangent );\n\n//   #ifdef DOUBLE_SIDED\n//     tangent = tangent * faceDirection;\n//     bitangent = bitangent * faceDirection;\n//   #endif\n\n// #if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\n// mat3 vTBN = mat3( tangent, bitangent, normal );\n\n// #endif\n// #endif\n  #ifdef OBJECTSPACE_NORMALMAP\n  // normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n\n  // #ifdef FLIP_SIDED\n  //   normal = - normal;\n  // #endif\n\n  // #ifdef DOUBLE_SIDED\n  //   normal = normal * faceDirection;\n  // #endif\n\n  // normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n  // vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n  // mapN.xy *= normalScale;\n\n  // #ifdef USE_TANGENT\n  //   normal = normalize( vTBN * mapN );\n  // #else\n  //   normal = perturbNormal2Arb( - v_ViewPosition, normal, mapN, faceDirection );\n  // #endif\n\n#elif defined(USE_BUMPMAP) && defined(USE_LIGHT)\n  normal = perturbNormalArb( - v_ViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif\n\n  if (u_IsPicking > 0.5) {\n    if (u_PickingColor.x == 0.0 && u_PickingColor.y == 0.0 && u_PickingColor.z == 0.0) {\n      discard;\n    }\n    outputColor = vec4(u_PickingColor, 1.0);\n  } else {\n    outputColor = u_Color;\n    outputColor.a = outputColor.a * u_Opacity;\n\n    vec4 diffuseColor = outputColor;\n    ReflectedLight reflectedLight = ReflectedLight(vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ));\n    vec3 totalEmissiveRadiance = u_Emissive;\n\n    // calculate lighting accumulation\n    BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = u_Specular;\nmaterial.specularShininess = u_Shininess;\nmaterial.specularStrength = specularStrength;\n    GeometricContext geometry;\ngeometry.position = - v_ViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = u_IsOrtho == 1.0 ? vec3(0, 0, 1) : normalize(v_ViewPosition);\n\nIncidentLight directLight;\n#if defined( NUM_DIR_LIGHTS ) && ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n  DirectionalLight directionalLight;\n  #if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n    DirectionalLightShadow directionalLightShadow;\n  #endif\n\n  #pragma unroll_loop_start\n  for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n    directionalLight = directionalLights[ i ];\n\n    getDirectionalLightInfo( directionalLight, geometry, directLight );\n\n    #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n      directionalLightShadow = directionalLightShadows[ i ];\n      directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n    #endif\n\n    RE_Direct( directLight, geometry, material, reflectedLight );\n  }\n  #pragma unroll_loop_end\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n  vec3 iblIrradiance = vec3(0.0);\n  vec3 ambient = vec3(0.0);\n  #ifdef NUM_AMBIENT_LIGHTS\n    ambient = u_AmbientLightColor;\n  #endif\n  vec3 irradiance = getAmbientLightIrradiance(ambient);\n\n  // irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n  // #if ( NUM_HEMI_LIGHTS > 0 )\n  //   #pragma unroll_loop_start\n  //   for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n  //     irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n  //   }\n  //   #pragma unroll_loop_end\n  // #endif\n#endif\n\n#if defined( RE_IndirectSpecular )\n  vec3 radiance = vec3( 0.0 );\n  vec3 clearcoatRadiance = vec3( 0.0 );\n#endif\n\n    #if defined( RE_IndirectDiffuse )\n  RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n\n#if defined( RE_IndirectSpecular )\n  RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif\n\n    vec3 outgoingLight = reflectedLight.directDiffuse +\n      reflectedLight.indirectDiffuse + \n      reflectedLight.directSpecular + \n      reflectedLight.indirectSpecular + \n      totalEmissiveRadiance;\n\n    outputColor = vec4(outgoingLight, diffuseColor.a);\n\n    #ifdef USE_WIREFRAME\n  vec3 color = mix(outputColor.xyz, u_WireframeLineColor, (1.0 - edgeFactor()));\n  outputColor.xyz = color;\n#endif\n    #ifdef USE_FOG\n  outputColor.rgb = addFog(outputColor.rgb);\n#endif\n  }\n}"; // eslint-disable-line

var vert$2 = "#define GLSLIFY 1\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n\n#ifndef saturate\n  #define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\n\nfloat pow2( float x ) { return x*x; }\nfloat pow3( float x ) { return x*x*x; }\nfloat pow4( float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand( vec2 uv ) {\n  const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n  highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\n  return fract( sin( sn ) * c );\n}\n\nmat3 transposeMat3(mat3 inMatrix) {\n  vec3 i0 = inMatrix[0];\n  vec3 i1 = inMatrix[1];\n  vec3 i2 = inMatrix[2];\n\n  mat3 outMatrix = mat3(\n    vec3(i0.x, i1.x, i2.x),\n    vec3(i0.y, i1.y, i2.y),\n    vec3(i0.z, i1.z, i2.z)\n    );\n\n  return outMatrix;\n}\n\n// https://github.com/glslify/glsl-inverse/blob/master/index.glsl\nmat3 inverseMat3(mat3 inMatrix) {\n  float a00 = inMatrix[0][0], a01 = inMatrix[0][1], a02 = inMatrix[0][2];\n  float a10 = inMatrix[1][0], a11 = inMatrix[1][1], a12 = inMatrix[1][2];\n  float a20 = inMatrix[2][0], a21 = inMatrix[2][1], a22 = inMatrix[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n          b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n          b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nstruct DirectionalLight {\n  vec3 direction;\n  float intensity;\n  vec3 color;\n};\n\nstruct IncidentLight {\n  vec3 color;\n  vec3 direction;\n  bool visible;\n};\n\nstruct ReflectedLight {\n  vec3 directDiffuse;\n  vec3 directSpecular;\n  vec3 indirectDiffuse;\n  vec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n  vec3 position;\n  vec3 normal;\n  vec3 viewDir;\n};\nlayout(std140) uniform ub_SceneParams {\n  mat4 u_ProjectionMatrix;\n  mat4 u_ViewMatrix;\n  vec3 u_CameraPosition;\n  float u_DevicePixelRatio;\n  vec2 u_Viewport;\n  float u_IsOrtho;\n  float u_IsPicking;\n};\nlayout(std140) uniform ub_MaterialParams {\n  #ifdef USE_WIREFRAME\n    vec3 u_WireframeLineColor;\n    float u_WireframeLineWidth;\n  #endif\n\n  #ifdef USE_FOG\n    vec4 u_FogInfos;\n    vec3 u_FogColor;\n  #endif\n\n  vec3 u_Emissive;\n  float u_Shininess;\n  vec3 u_Specular;\n\n  #ifdef USE_LIGHT\n    #ifdef USE_BUMPMAP\n      float u_BumpScale;\n    #endif\n\n    #ifdef NUM_AMBIENT_LIGHTS\n      vec3 u_AmbientLightColor;\n    #endif\n\n    #ifdef NUM_DIR_LIGHTS\n      DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n    #endif\n  #endif\n};\n\nlayout(location = MODEL_MATRIX0) in vec4 a_ModelMatrix0;\nlayout(location = MODEL_MATRIX1) in vec4 a_ModelMatrix1;\nlayout(location = MODEL_MATRIX2) in vec4 a_ModelMatrix2;\nlayout(location = MODEL_MATRIX3) in vec4 a_ModelMatrix3;\nlayout(location = PACKED_COLOR) in vec4 a_PackedColor;\nlayout(location = PACKED_STYLE1) in vec4 a_StylePacked1;\nlayout(location = PACKED_STYLE2) in vec4 a_StylePacked2;\nlayout(location = PICKING_COLOR) in vec4 a_PickingColor;\n\nout vec4 v_PickingResult;\nout vec4 v_Color;\nout vec4 v_StrokeColor;\nout vec4 v_StylePacked1;\nout vec4 v_StylePacked2;\n\n#define COLOR_SCALE 1. / 255.\nvoid setPickingColor(vec3 pickingColor) {\n  v_PickingResult.rgb = pickingColor * COLOR_SCALE;\n}\n\nvec2 unpack_float(const float packedValue) {\n  int packedIntValue = int(packedValue);\n  int v0 = packedIntValue / 256;\n  return vec2(v0, packedIntValue - v0 * 256);\n}\nvec4 decode_color(const vec2 encodedColor) {\n  return vec4(\n    unpack_float(encodedColor[0]) / 255.0,\n    unpack_float(encodedColor[1]) / 255.0\n  );\n}\nvec4 project(vec4 pos, mat4 pm, mat4 vm, mat4 mm) {\n  return pm * vm * mm * pos;\n}\n\nlayout(location = POSITION) in vec3 a_Position;\nlayout(location = NORMAL) in vec3 a_Normal;\n\n#ifdef USE_UV\n  layout(location = UV) in vec2 a_Uv;\n  out vec2 v_Uv;\n#endif\n\n#ifdef USE_WIREFRAME\n  layout(location = BARYCENTRIC) in vec3 a_Barycentric;\n  out vec3 v_Barycentric;\n#endif\n\nout vec3 v_ViewPosition;\nout vec3 v_Normal;\n\nvoid main() {\n  vec4 a_Color = decode_color(a_PackedColor.xy);\nvec4 a_StrokeColor = decode_color(a_PackedColor.zw);\n\nmat4 u_ModelMatrix = mat4(a_ModelMatrix0, a_ModelMatrix1, a_ModelMatrix2, a_ModelMatrix3);\nvec4 u_StrokeColor = a_StrokeColor;\nfloat u_Opacity = a_StylePacked1.x;\nfloat u_FillOpacity = a_StylePacked1.y;\nfloat u_StrokeOpacity = a_StylePacked1.z;\nfloat u_StrokeWidth = a_StylePacked1.w;\nfloat u_ZIndex = a_PickingColor.w;\nvec2 u_Anchor = a_StylePacked2.yz;\nfloat u_IncreasedLineWidthForHitTesting = a_StylePacked2.w;\n\nsetPickingColor(a_PickingColor.xyz);\n\nv_Color = a_Color;\nv_StrokeColor = a_StrokeColor;\nv_StylePacked1 = a_StylePacked1;\nv_StylePacked2 = a_StylePacked2;\n\n// #ifdef CLIPSPACE_NEAR_ZERO\n//     gl_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n// #endif\n\n  vec4 position = vec4(a_Position, 1.0);\n\n  gl_Position = project(position, u_ProjectionMatrix, u_ViewMatrix, u_ModelMatrix);\n\n  vec4 mvPosition = u_ViewMatrix * u_ModelMatrix * position;\n  v_ViewPosition = - mvPosition.xyz;\n\n  // v_ViewPosition = vec3(mvPosition) / mvPosition.w;\n\n  mat3 normalWorld = mat3(transposeMat3(inverseMat3(mat3(u_ViewMatrix * u_ModelMatrix))));\n  v_Normal = normalize(normalWorld * a_Normal);\n\n  #ifdef USE_UV\n  v_Uv = a_Uv;\n#endif\n\n  #ifdef USE_WIREFRAME\n  v_Barycentric = a_Barycentric;\n#endif\n\n}"; // eslint-disable-line

var Uniform$2;
(function (Uniform) {
    Uniform["EMISSIVE"] = "u_Emissive";
    Uniform["SHININESS"] = "u_Shininess";
    Uniform["SPECULAR"] = "u_Specular";
    Uniform["BUMP_SCALE"] = "u_BumpScale";
    Uniform["SPECULAR_MAP"] = "u_SpecularMap";
    Uniform["BUMP_MAP"] = "u_BumpMap";
})(Uniform$2 || (Uniform$2 = {}));
var MeshPhongMaterial = /** @class */ (function (_super) {
    tslib.__extends(MeshPhongMaterial, _super);
    function MeshPhongMaterial(device, props) {
        var _a;
        var _this = _super.call(this, device, tslib.__assign({ vertexShader: vert$2, fragmentShader: frag$2, emissive: 'black', shininess: 30, specular: '#111111', bumpScale: 1, doubleSide: false }, props)) || this;
        var _b = _this, specularMap = _b.specularMap, bumpMap = _b.bumpMap, doubleSide = _b.doubleSide, emissive = _b.emissive, shininess = _b.shininess, specular = _b.specular;
        var emissiveColor = gLite.parseColor(emissive);
        var specularColor = gLite.parseColor(specular);
        _this.setUniforms((_a = {
                u_Placeholder: null
            },
            _a[Uniform$2.EMISSIVE] = [
                Number(emissiveColor.r) / 255,
                Number(emissiveColor.g) / 255,
                Number(emissiveColor.b) / 255,
            ],
            _a[Uniform$2.SHININESS] = shininess,
            _a[Uniform$2.SPECULAR] = [
                Number(specularColor.r) / 255,
                Number(specularColor.g) / 255,
                Number(specularColor.b) / 255,
            ],
            _a));
        if (specularMap) {
            _this.specularMap = specularMap;
        }
        if (bumpMap) {
            _this.bumpMap = bumpMap;
        }
        _this.doubleSide = doubleSide;
        _this.defines = tslib.__assign(tslib.__assign({}, _this.defines), { USE_LIGHT: true });
        return _this;
    }
    Object.defineProperty(MeshPhongMaterial.prototype, "emissive", {
        get: function () {
            return this.props.emissive;
        },
        set: function (v) {
            var _a;
            this.props.emissive = v;
            var emissiveColor = gLite.parseColor(v);
            this.setUniforms((_a = {},
                _a[Uniform$2.EMISSIVE] = [
                    Number(emissiveColor.r) / 255,
                    Number(emissiveColor.g) / 255,
                    Number(emissiveColor.b) / 255,
                ],
                _a));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MeshPhongMaterial.prototype, "shininess", {
        get: function () {
            return this.props.shininess;
        },
        set: function (v) {
            var _a;
            this.props.shininess = v;
            this.setUniforms((_a = {},
                _a[Uniform$2.SHININESS] = v,
                _a));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MeshPhongMaterial.prototype, "specular", {
        get: function () {
            return this.props.specular;
        },
        set: function (v) {
            var _a;
            this.props.specular = v;
            var specularColor = gLite.parseColor(v);
            this.setUniforms((_a = {},
                _a[Uniform$2.SPECULAR] = [
                    Number(specularColor.r) / 255,
                    Number(specularColor.g) / 255,
                    Number(specularColor.b) / 255,
                ],
                _a));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MeshPhongMaterial.prototype, "specularMap", {
        get: function () {
            return this.props.specularMap;
        },
        set: function (v) {
            var _a;
            if (this.props.map !== v) {
                this.props.specularMap = v;
                this.programDirty = true;
            }
            this.defines.USE_SPECULARMAP = !!v;
            this.setUniforms((_a = {},
                _a[Uniform$2.SPECULAR_MAP] = v,
                _a));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MeshPhongMaterial.prototype, "bumpMap", {
        get: function () {
            return this.props.bumpMap;
        },
        set: function (v) {
            var _a;
            if (this.props.map !== v) {
                this.props.bumpMap = v;
                this.programDirty = true;
            }
            this.defines.USE_BUMPMAP = !!v;
            this.setUniforms((_a = {},
                _a[Uniform$2.BUMP_MAP] = v,
                _a[Uniform$2.BUMP_SCALE] = this.bumpScale,
                _a));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MeshPhongMaterial.prototype, "bumpScale", {
        get: function () {
            return this.props.bumpScale;
        },
        set: function (v) {
            var _a;
            this.props.bumpScale = v;
            this.setUniforms((_a = {},
                _a[Uniform$2.BUMP_SCALE] = v,
                _a));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MeshPhongMaterial.prototype, "doubleSide", {
        get: function () {
            return this.props.doubleSide;
        },
        set: function (v) {
            this.props.doubleSide = v;
            this.defines.USE_DOUBLESIDE = v;
        },
        enumerable: false,
        configurable: true
    });
    return MeshPhongMaterial;
}(MeshBasicMaterial));

var frag$1 = "#define GLSLIFY 1\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n\n#ifndef saturate\n  #define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\n\nfloat pow2( float x ) { return x*x; }\nfloat pow3( float x ) { return x*x*x; }\nfloat pow4( float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand( vec2 uv ) {\n  const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n  highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\n  return fract( sin( sn ) * c );\n}\n\nmat3 transposeMat3(mat3 inMatrix) {\n  vec3 i0 = inMatrix[0];\n  vec3 i1 = inMatrix[1];\n  vec3 i2 = inMatrix[2];\n\n  mat3 outMatrix = mat3(\n    vec3(i0.x, i1.x, i2.x),\n    vec3(i0.y, i1.y, i2.y),\n    vec3(i0.z, i1.z, i2.z)\n    );\n\n  return outMatrix;\n}\n\n// https://github.com/glslify/glsl-inverse/blob/master/index.glsl\nmat3 inverseMat3(mat3 inMatrix) {\n  float a00 = inMatrix[0][0], a01 = inMatrix[0][1], a02 = inMatrix[0][2];\n  float a10 = inMatrix[1][0], a11 = inMatrix[1][1], a12 = inMatrix[1][2];\n  float a20 = inMatrix[2][0], a21 = inMatrix[2][1], a22 = inMatrix[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n          b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n          b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nstruct DirectionalLight {\n  vec3 direction;\n  float intensity;\n  vec3 color;\n};\n\nstruct IncidentLight {\n  vec3 color;\n  vec3 direction;\n  bool visible;\n};\n\nstruct ReflectedLight {\n  vec3 directDiffuse;\n  vec3 directSpecular;\n  vec3 indirectDiffuse;\n  vec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n  vec3 position;\n  vec3 normal;\n  vec3 viewDir;\n};\nlayout(std140) uniform ub_SceneParams {\n  mat4 u_ProjectionMatrix;\n  mat4 u_ViewMatrix;\n  vec3 u_CameraPosition;\n  float u_DevicePixelRatio;\n  vec2 u_Viewport;\n  float u_IsOrtho;\n  float u_IsPicking;\n};\nlayout(std140) uniform ub_MaterialParams {\n  #ifdef USE_WIREFRAME\n    vec3 u_WireframeLineColor;\n    float u_WireframeLineWidth;\n  #endif\n\n  #ifdef USE_FOG\n    vec4 u_FogInfos;\n    vec3 u_FogColor;\n  #endif\n\n  vec3 u_Emissive;\n\n  #ifdef USE_LIGHT\n    #ifdef USE_BUMPMAP\n      float u_BumpScale;\n    #endif\n\n    #ifdef NUM_AMBIENT_LIGHTS\n      vec3 u_AmbientLightColor;\n    #endif\n\n    #ifdef NUM_DIR_LIGHTS\n      DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n    #endif\n  #endif\n};\n\nin vec4 v_PickingResult;\nin vec4 v_Color;\nin vec4 v_StrokeColor;\nin vec4 v_StylePacked1;\nin vec4 v_StylePacked2;\n#ifdef USE_UV\n  in vec2 v_Uv;\n#endif\n#ifdef USE_MAP\n  uniform sampler2D u_Map;\n#endif\n#if defined(USE_BUMPMAP) && defined(USE_LIGHT)\n  uniform sampler2D u_BumpMap;\n\n  // Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen\n  // http://api.unrealengine.com/attachments/Engine/Rendering/LightingAndShadows/BumpMappingWithoutTangentSpace/mm_sfgrad_bump.pdf\n\n  // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)\n\n  vec2 dHdxy_fwd() {\n    vec2 dSTdx = dFdx( v_Uv );\n    vec2 dSTdy = dFdy( v_Uv );\n\n    float Hll = u_BumpScale * texture(SAMPLER_2D(u_BumpMap), v_Uv ).x;\n    float dBx = u_BumpScale * texture(SAMPLER_2D(u_BumpMap), v_Uv + dSTdx ).x - Hll;\n    float dBy = u_BumpScale * texture(SAMPLER_2D(u_BumpMap), v_Uv + dSTdy ).x - Hll;\n\n    return vec2( dBx, dBy );\n  }\n\n  vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\n    // Workaround for Adreno 3XX dFd*( vec3 ) bug. See #9988\n\n    vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n    vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n    vec3 vN = surf_norm;\t\t// normalized\n\n    vec3 R1 = cross( vSigmaY, vN );\n    vec3 R2 = cross( vN, vSigmaX );\n\n    float fDet = dot( vSigmaX, R1 ) * faceDirection;\n\n    vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n    return normalize( abs( fDet ) * surf_norm - vGrad );\n  }\n#endif\n#ifdef USE_SPECULARMAP\n  uniform sampler2D u_SpecularMap;\n#endif\nvec3 BRDF_Lambert(vec3 diffuseColor) {\n  return RECIPROCAL_PI * diffuseColor;\n}\n\nvec3 F_Schlick(\n  vec3 f0,\n  float f90,\n  float dotVH\n) {\n  // Original approximation by Christophe Schlick '94\n  // float fresnel = pow( 1.0 - dotVH, 5.0 );\n\n  // Optimized variant (presented by Epic at SIGGRAPH '13)\n  // https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf\n  float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n  return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\n\nfloat G_BlinnPhong_Implicit( /* float dotNL, float dotNV */ ) {\n  // geometry term is (n dot l)(n dot v) / 4(n dot l)(n dot v)\n  return 0.25;\n}\n\nfloat D_BlinnPhong(\n  float shininess,\n  float dotNH\n) {\n  return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\n\nvec3 BRDF_BlinnPhong(\n  vec3 lightDir,\n  vec3 viewDir,\n  vec3 normal,\n  vec3 specularColor,\n  float shininess\n) {\n  vec3 halfDir = normalize( lightDir + viewDir );\n\n  float dotNH = saturate( dot( normal, halfDir ) );\n  float dotVH = saturate( dot( viewDir, halfDir ) );\n\n  vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\n  float G = G_BlinnPhong_Implicit( /* dotNL, dotNV */ );\n\n  float D = D_BlinnPhong( shininess, dotNH );\n\n  return F * ( G * D );\n}\n\n#ifdef USE_WIREFRAME\n  in vec3 v_Barycentric;\n\n  float edgeFactor() {\n    vec3 d = fwidth(v_Barycentric);\n    vec3 a3 = smoothstep(vec3(0.0), d * u_WireframeLineWidth, v_Barycentric);\n    return min(min(a3.x, a3.y), a3.z);\n  }\n#endif\n\n#ifdef USE_FOG\n  #define FOGMODE_NONE 0.\n  #define FOGMODE_EXP 1.\n  #define FOGMODE_EXP2 2.\n  #define FOGMODE_LINEAR 3.\n\n  // in float v_FogDepth;\n\n  float dBlendModeFogFactor = 1.0;\n\n  vec3 addFog(vec3 color) {\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    // float depth = v_FogDepth;\n    float fogFactor;\n    float fogStart = u_FogInfos.y;\n    float fogEnd = u_FogInfos.z;\n    float fogDensity = u_FogInfos.w;\n\n    if (u_FogInfos.x == FOGMODE_NONE) {\n      fogFactor = 1.0;\n    } else if (u_FogInfos.x == FOGMODE_EXP) {\n      fogFactor = exp(-depth * fogDensity);\n    } else if (u_FogInfos.x == FOGMODE_EXP2) {\n      fogFactor = exp(-depth * depth * fogDensity * fogDensity);\n    } else if (u_FogInfos.x == FOGMODE_LINEAR) {\n      fogFactor = (fogEnd - depth) / (fogEnd - fogStart);\n    }\n\n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n    return mix(u_FogColor * dBlendModeFogFactor, color, fogFactor);\n  }\n#endif\n\n#ifdef USE_LIGHT\n  void getDirectionalLightInfo(\n    DirectionalLight directionalLight, \n    GeometricContext geometry,\n    out IncidentLight light\n  ) {\n    light.color = directionalLight.color * directionalLight.intensity;\n    light.direction = normalize(directionalLight.direction);\n    light.visible = true;\n  }\n\n  vec3 getAmbientLightIrradiance( vec3 ambientLightColor ) {\n    vec3 irradiance = ambientLightColor;\n    return irradiance;\n  }\n#endif\nstruct LambertMaterial {\n  vec3 diffuseColor;\n  float specularStrength;\n};\n\nvoid RE_Direct_Lambert(\n  IncidentLight directLight,\n  GeometricContext geometry,\n  LambertMaterial material,\n  inout ReflectedLight reflectedLight\n) {\n  float dotNL = saturate(dot(geometry.normal, directLight.direction));\n  vec3 irradiance = dotNL * directLight.color;\n\n  reflectedLight.directDiffuse += irradiance * BRDF_Lambert(material.diffuseColor);\n}\n\nvoid RE_IndirectDiffuse_Lambert(\n  vec3 irradiance,\n  GeometricContext geometry,\n  LambertMaterial material,\n  inout ReflectedLight reflectedLight\n) {\n  reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert(material.diffuseColor);\n}\n\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert\n\nin vec3 v_ViewPosition;\nin vec3 v_Normal;\n\nout vec4 outputColor;\n\nvoid main() {\n  vec4 u_Color = v_Color;\nvec4 u_StrokeColor = v_StrokeColor;\nfloat u_Opacity = v_StylePacked1.x;\nfloat u_FillOpacity = v_StylePacked1.y;\nfloat u_StrokeOpacity = v_StylePacked1.z;\nfloat u_StrokeWidth = v_StylePacked1.w;\nfloat u_Visible = v_StylePacked2.x;\nvec3 u_PickingColor = v_PickingResult.xyz;\n\nif (u_Visible < 0.5) {\n    discard;\n}\n\n  // diffusemap\n  #ifdef USE_MAP\n  #ifdef USE_PATTERN\n    vec4 texelColor = texture(SAMPLER_2D(u_Map), v_Uv);\n    u_Color = texelColor;\n  #else\n    vec4 texelColor = texture(SAMPLER_2D(u_Map), v_Uv);\n    u_Color = texelColor;\n  #endif\n#endif\n  // specularmap\n  float specularStrength = 1.0;\n\n#ifdef USE_SPECULARMAP\n  vec4 texelSpecular = texture(SAMPLER_2D(u_SpecularMap), v_Uv);\n  specularStrength = texelSpecular.r;\n#endif\n  // bumpmap & normalmap\n  float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\nvec3 normal = normalize(v_Normal);\n#ifdef USE_DOUBLESIDE\n  normal = normal * faceDirection;\n#endif\n\n// #ifdef USE_TANGENT\n//   vec3 tangent = normalize( vTangent );\n//   vec3 bitangent = normalize( vBitangent );\n\n//   #ifdef DOUBLE_SIDED\n//     tangent = tangent * faceDirection;\n//     bitangent = bitangent * faceDirection;\n//   #endif\n\n// #if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\n// mat3 vTBN = mat3( tangent, bitangent, normal );\n\n// #endif\n// #endif\n  #ifdef OBJECTSPACE_NORMALMAP\n  // normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n\n  // #ifdef FLIP_SIDED\n  //   normal = - normal;\n  // #endif\n\n  // #ifdef DOUBLE_SIDED\n  //   normal = normal * faceDirection;\n  // #endif\n\n  // normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n  // vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n  // mapN.xy *= normalScale;\n\n  // #ifdef USE_TANGENT\n  //   normal = normalize( vTBN * mapN );\n  // #else\n  //   normal = perturbNormal2Arb( - v_ViewPosition, normal, mapN, faceDirection );\n  // #endif\n\n#elif defined(USE_BUMPMAP) && defined(USE_LIGHT)\n  normal = perturbNormalArb( - v_ViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif\n\n  if (u_IsPicking > 0.5) {\n    if (u_PickingColor.x == 0.0 && u_PickingColor.y == 0.0 && u_PickingColor.z == 0.0) {\n      discard;\n    }\n    outputColor = vec4(u_PickingColor, 1.0);\n  } else {\n    outputColor = u_Color;\n    outputColor.a = outputColor.a * u_Opacity;\n\n    vec4 diffuseColor = outputColor;\n    ReflectedLight reflectedLight = ReflectedLight(vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ));\n    vec3 totalEmissiveRadiance = u_Emissive;\n\n    // calculate lighting accumulation\n    LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;\n    GeometricContext geometry;\ngeometry.position = - v_ViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = u_IsOrtho == 1.0 ? vec3(0, 0, 1) : normalize(v_ViewPosition);\n\nIncidentLight directLight;\n#if defined( NUM_DIR_LIGHTS ) && ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n  DirectionalLight directionalLight;\n  #if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n    DirectionalLightShadow directionalLightShadow;\n  #endif\n\n  #pragma unroll_loop_start\n  for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n    directionalLight = directionalLights[ i ];\n\n    getDirectionalLightInfo( directionalLight, geometry, directLight );\n\n    #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n      directionalLightShadow = directionalLightShadows[ i ];\n      directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n    #endif\n\n    RE_Direct( directLight, geometry, material, reflectedLight );\n  }\n  #pragma unroll_loop_end\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n  vec3 iblIrradiance = vec3(0.0);\n  vec3 ambient = vec3(0.0);\n  #ifdef NUM_AMBIENT_LIGHTS\n    ambient = u_AmbientLightColor;\n  #endif\n  vec3 irradiance = getAmbientLightIrradiance(ambient);\n\n  // irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n  // #if ( NUM_HEMI_LIGHTS > 0 )\n  //   #pragma unroll_loop_start\n  //   for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n  //     irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n  //   }\n  //   #pragma unroll_loop_end\n  // #endif\n#endif\n\n#if defined( RE_IndirectSpecular )\n  vec3 radiance = vec3( 0.0 );\n  vec3 clearcoatRadiance = vec3( 0.0 );\n#endif\n\n    #if defined( RE_IndirectDiffuse )\n  RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n\n#if defined( RE_IndirectSpecular )\n  RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif\n\n    vec3 outgoingLight = reflectedLight.directDiffuse +\n      reflectedLight.indirectDiffuse + \n      totalEmissiveRadiance;\n\n    outputColor = vec4(outgoingLight, diffuseColor.a);\n\n    #ifdef USE_WIREFRAME\n  vec3 color = mix(outputColor.xyz, u_WireframeLineColor, (1.0 - edgeFactor()));\n  outputColor.xyz = color;\n#endif\n    #ifdef USE_FOG\n  outputColor.rgb = addFog(outputColor.rgb);\n#endif\n  }\n}"; // eslint-disable-line

var vert$1 = "#define GLSLIFY 1\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n\n#ifndef saturate\n  #define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\n\nfloat pow2( float x ) { return x*x; }\nfloat pow3( float x ) { return x*x*x; }\nfloat pow4( float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand( vec2 uv ) {\n  const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n  highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\n  return fract( sin( sn ) * c );\n}\n\nmat3 transposeMat3(mat3 inMatrix) {\n  vec3 i0 = inMatrix[0];\n  vec3 i1 = inMatrix[1];\n  vec3 i2 = inMatrix[2];\n\n  mat3 outMatrix = mat3(\n    vec3(i0.x, i1.x, i2.x),\n    vec3(i0.y, i1.y, i2.y),\n    vec3(i0.z, i1.z, i2.z)\n    );\n\n  return outMatrix;\n}\n\n// https://github.com/glslify/glsl-inverse/blob/master/index.glsl\nmat3 inverseMat3(mat3 inMatrix) {\n  float a00 = inMatrix[0][0], a01 = inMatrix[0][1], a02 = inMatrix[0][2];\n  float a10 = inMatrix[1][0], a11 = inMatrix[1][1], a12 = inMatrix[1][2];\n  float a20 = inMatrix[2][0], a21 = inMatrix[2][1], a22 = inMatrix[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n          b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n          b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nstruct DirectionalLight {\n  vec3 direction;\n  float intensity;\n  vec3 color;\n};\n\nstruct IncidentLight {\n  vec3 color;\n  vec3 direction;\n  bool visible;\n};\n\nstruct ReflectedLight {\n  vec3 directDiffuse;\n  vec3 directSpecular;\n  vec3 indirectDiffuse;\n  vec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n  vec3 position;\n  vec3 normal;\n  vec3 viewDir;\n};\nlayout(std140) uniform ub_SceneParams {\n  mat4 u_ProjectionMatrix;\n  mat4 u_ViewMatrix;\n  vec3 u_CameraPosition;\n  float u_DevicePixelRatio;\n  vec2 u_Viewport;\n  float u_IsOrtho;\n  float u_IsPicking;\n};\nlayout(std140) uniform ub_MaterialParams {\n  #ifdef USE_WIREFRAME\n    vec3 u_WireframeLineColor;\n    float u_WireframeLineWidth;\n  #endif\n\n  #ifdef USE_FOG\n    vec4 u_FogInfos;\n    vec3 u_FogColor;\n  #endif\n\n  vec3 u_Emissive;\n\n  #ifdef USE_LIGHT\n    #ifdef USE_BUMPMAP\n      float u_BumpScale;\n    #endif\n\n    #ifdef NUM_AMBIENT_LIGHTS\n      vec3 u_AmbientLightColor;\n    #endif\n\n    #ifdef NUM_DIR_LIGHTS\n      DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n    #endif\n  #endif\n};\n\nlayout(location = MODEL_MATRIX0) in vec4 a_ModelMatrix0;\nlayout(location = MODEL_MATRIX1) in vec4 a_ModelMatrix1;\nlayout(location = MODEL_MATRIX2) in vec4 a_ModelMatrix2;\nlayout(location = MODEL_MATRIX3) in vec4 a_ModelMatrix3;\nlayout(location = PACKED_COLOR) in vec4 a_PackedColor;\nlayout(location = PACKED_STYLE1) in vec4 a_StylePacked1;\nlayout(location = PACKED_STYLE2) in vec4 a_StylePacked2;\nlayout(location = PICKING_COLOR) in vec4 a_PickingColor;\n\nout vec4 v_PickingResult;\nout vec4 v_Color;\nout vec4 v_StrokeColor;\nout vec4 v_StylePacked1;\nout vec4 v_StylePacked2;\n\n#define COLOR_SCALE 1. / 255.\nvoid setPickingColor(vec3 pickingColor) {\n  v_PickingResult.rgb = pickingColor * COLOR_SCALE;\n}\n\nvec2 unpack_float(const float packedValue) {\n  int packedIntValue = int(packedValue);\n  int v0 = packedIntValue / 256;\n  return vec2(v0, packedIntValue - v0 * 256);\n}\nvec4 decode_color(const vec2 encodedColor) {\n  return vec4(\n    unpack_float(encodedColor[0]) / 255.0,\n    unpack_float(encodedColor[1]) / 255.0\n  );\n}\nvec4 project(vec4 pos, mat4 pm, mat4 vm, mat4 mm) {\n  return pm * vm * mm * pos;\n}\n\nlayout(location = POSITION) in vec3 a_Position;\nlayout(location = NORMAL) in vec3 a_Normal;\n\n#ifdef USE_UV\n  layout(location = UV) in vec2 a_Uv;\n  out vec2 v_Uv;\n#endif\n\n#ifdef USE_WIREFRAME\n  layout(location = BARYCENTRIC) in vec3 a_Barycentric;\n  out vec3 v_Barycentric;\n#endif\n\nout vec3 v_ViewPosition;\nout vec3 v_Normal;\n\nvoid main() {\n  vec4 a_Color = decode_color(a_PackedColor.xy);\nvec4 a_StrokeColor = decode_color(a_PackedColor.zw);\n\nmat4 u_ModelMatrix = mat4(a_ModelMatrix0, a_ModelMatrix1, a_ModelMatrix2, a_ModelMatrix3);\nvec4 u_StrokeColor = a_StrokeColor;\nfloat u_Opacity = a_StylePacked1.x;\nfloat u_FillOpacity = a_StylePacked1.y;\nfloat u_StrokeOpacity = a_StylePacked1.z;\nfloat u_StrokeWidth = a_StylePacked1.w;\nfloat u_ZIndex = a_PickingColor.w;\nvec2 u_Anchor = a_StylePacked2.yz;\nfloat u_IncreasedLineWidthForHitTesting = a_StylePacked2.w;\n\nsetPickingColor(a_PickingColor.xyz);\n\nv_Color = a_Color;\nv_StrokeColor = a_StrokeColor;\nv_StylePacked1 = a_StylePacked1;\nv_StylePacked2 = a_StylePacked2;\n\n// #ifdef CLIPSPACE_NEAR_ZERO\n//     gl_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n// #endif\n\n  vec4 position = vec4(a_Position, 1.0);\n\n  gl_Position = project(position, u_ProjectionMatrix, u_ViewMatrix, u_ModelMatrix);\n\n  vec4 mvPosition = u_ViewMatrix * u_ModelMatrix * position;\n  v_ViewPosition = - mvPosition.xyz;\n\n  // v_ViewPosition = vec3(mvPosition) / mvPosition.w;\n\n  mat3 normalWorld = mat3(transposeMat3(inverseMat3(mat3(u_ViewMatrix * u_ModelMatrix))));\n  v_Normal = normalize(normalWorld * a_Normal);\n\n  #ifdef USE_UV\n  v_Uv = a_Uv;\n#endif\n\n  #ifdef USE_WIREFRAME\n  v_Barycentric = a_Barycentric;\n#endif\n\n}"; // eslint-disable-line

var Uniform$1;
(function (Uniform) {
    Uniform["EMISSIVE"] = "u_Emissive";
    Uniform["BUMP_SCALE"] = "u_BumpScale";
    Uniform["BUMP_MAP"] = "u_BumpMap";
})(Uniform$1 || (Uniform$1 = {}));
var MeshLambertMaterial = /** @class */ (function (_super) {
    tslib.__extends(MeshLambertMaterial, _super);
    function MeshLambertMaterial(device, props) {
        var _a;
        var _this = _super.call(this, device, tslib.__assign({ vertexShader: vert$1, fragmentShader: frag$1, emissive: 'black', bumpScale: 1, doubleSide: false }, props)) || this;
        var _b = _this, bumpMap = _b.bumpMap, doubleSide = _b.doubleSide, emissive = _b.emissive;
        var emissiveColor = gLite.parseColor(emissive);
        _this.setUniforms((_a = {
                u_Placeholder: null
            },
            _a[Uniform$1.EMISSIVE] = [
                Number(emissiveColor.r) / 255,
                Number(emissiveColor.g) / 255,
                Number(emissiveColor.b) / 255,
            ],
            _a));
        if (bumpMap) {
            _this.bumpMap = bumpMap;
        }
        _this.doubleSide = doubleSide;
        _this.defines = tslib.__assign(tslib.__assign({}, _this.defines), { USE_LIGHT: true });
        return _this;
    }
    Object.defineProperty(MeshLambertMaterial.prototype, "emissive", {
        get: function () {
            return this.props.emissive;
        },
        set: function (v) {
            var _a;
            this.props.emissive = v;
            var emissiveColor = gLite.parseColor(v);
            this.setUniforms((_a = {},
                _a[Uniform$1.EMISSIVE] = [
                    Number(emissiveColor.r) / 255,
                    Number(emissiveColor.g) / 255,
                    Number(emissiveColor.b) / 255,
                ],
                _a));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MeshLambertMaterial.prototype, "bumpMap", {
        get: function () {
            return this.props.bumpMap;
        },
        set: function (v) {
            var _a;
            if (this.props.map !== v) {
                this.props.bumpMap = v;
                this.programDirty = true;
            }
            this.defines.USE_BUMPMAP = !!v;
            this.setUniforms((_a = {},
                _a[Uniform$1.BUMP_MAP] = v,
                _a[Uniform$1.BUMP_SCALE] = this.bumpScale,
                _a));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MeshLambertMaterial.prototype, "bumpScale", {
        get: function () {
            return this.props.bumpScale;
        },
        set: function (v) {
            var _a;
            this.props.bumpScale = v;
            this.setUniforms((_a = {},
                _a[Uniform$1.BUMP_SCALE] = v,
                _a));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(MeshLambertMaterial.prototype, "doubleSide", {
        get: function () {
            return this.props.doubleSide;
        },
        set: function (v) {
            this.props.doubleSide = v;
            this.defines.USE_DOUBLESIDE = v;
        },
        enumerable: false,
        configurable: true
    });
    return MeshLambertMaterial;
}(MeshBasicMaterial));

var vert = "#define GLSLIFY 1\nlayout(std140) uniform ub_SceneParams {\n  mat4 u_ProjectionMatrix;\n  mat4 u_ViewMatrix;\n  vec3 u_CameraPosition;\n  float u_DevicePixelRatio;\n  vec2 u_Viewport;\n  float u_IsOrtho;\n  float u_IsPicking;\n};\nlayout(std140) uniform ub_MaterialParams {\n  #ifdef USE_WIREFRAME\n    vec3 u_WireframeLineColor;\n    float u_WireframeLineWidth;\n  #endif\n\n  #ifdef USE_FOG\n    vec4 u_FogInfos;\n    vec3 u_FogColor;\n  #endif\n\n  float u_Size;\n  vec4 u_Placeholder;\n};\n\nlayout(location = MODEL_MATRIX0) in vec4 a_ModelMatrix0;\nlayout(location = MODEL_MATRIX1) in vec4 a_ModelMatrix1;\nlayout(location = MODEL_MATRIX2) in vec4 a_ModelMatrix2;\nlayout(location = MODEL_MATRIX3) in vec4 a_ModelMatrix3;\nlayout(location = PACKED_COLOR) in vec4 a_PackedColor;\nlayout(location = PACKED_STYLE1) in vec4 a_StylePacked1;\nlayout(location = PACKED_STYLE2) in vec4 a_StylePacked2;\nlayout(location = PICKING_COLOR) in vec4 a_PickingColor;\n\nout vec4 v_PickingResult;\nout vec4 v_Color;\nout vec4 v_StrokeColor;\nout vec4 v_StylePacked1;\nout vec4 v_StylePacked2;\n\n#define COLOR_SCALE 1. / 255.\nvoid setPickingColor(vec3 pickingColor) {\n  v_PickingResult.rgb = pickingColor * COLOR_SCALE;\n}\n\nvec2 unpack_float(const float packedValue) {\n  int packedIntValue = int(packedValue);\n  int v0 = packedIntValue / 256;\n  return vec2(v0, packedIntValue - v0 * 256);\n}\nvec4 decode_color(const vec2 encodedColor) {\n  return vec4(\n    unpack_float(encodedColor[0]) / 255.0,\n    unpack_float(encodedColor[1]) / 255.0\n  );\n}\nvec4 project(vec4 pos, mat4 pm, mat4 vm, mat4 mm) {\n  return pm * vm * mm * pos;\n}\n\nlayout(location = POSITION) in vec3 a_Position;\n\n#ifdef USE_UV\n  layout(location = UV) in vec2 a_Uv;\n  out vec2 v_Uv;\n#endif\n\n#ifdef USE_WIREFRAME\n  layout(location = BARYCENTRIC) in vec3 a_Barycentric;\n  out vec3 v_Barycentric;\n#endif\n\nvoid main() {\n  vec4 a_Color = decode_color(a_PackedColor.xy);\nvec4 a_StrokeColor = decode_color(a_PackedColor.zw);\n\nmat4 u_ModelMatrix = mat4(a_ModelMatrix0, a_ModelMatrix1, a_ModelMatrix2, a_ModelMatrix3);\nvec4 u_StrokeColor = a_StrokeColor;\nfloat u_Opacity = a_StylePacked1.x;\nfloat u_FillOpacity = a_StylePacked1.y;\nfloat u_StrokeOpacity = a_StylePacked1.z;\nfloat u_StrokeWidth = a_StylePacked1.w;\nfloat u_ZIndex = a_PickingColor.w;\nvec2 u_Anchor = a_StylePacked2.yz;\nfloat u_IncreasedLineWidthForHitTesting = a_StylePacked2.w;\n\nsetPickingColor(a_PickingColor.xyz);\n\nv_Color = a_Color;\nv_StrokeColor = a_StrokeColor;\nv_StylePacked1 = a_StylePacked1;\nv_StylePacked2 = a_StylePacked2;\n\n// #ifdef CLIPSPACE_NEAR_ZERO\n//     gl_Position.z = (gl_Position.z + gl_Position.w) * 0.5;\n// #endif\n\n  gl_PointSize = u_Size;\n  gl_Position = project(vec4(a_Position, 1.0), u_ProjectionMatrix, u_ViewMatrix, u_ModelMatrix);\n\n  #ifdef USE_UV\n  v_Uv = a_Uv;\n#endif\n\n  #ifdef USE_WIREFRAME\n  v_Barycentric = a_Barycentric;\n#endif\n\n}"; // eslint-disable-line

var frag = "#define GLSLIFY 1\n#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n\n#ifndef saturate\n  #define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\n\nfloat pow2( float x ) { return x*x; }\nfloat pow3( float x ) { return x*x*x; }\nfloat pow4( float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\n\n// expects values in the range of [0,1]x[0,1], returns values in the [0,1] range.\n// do not collapse into a single function per: http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\nhighp float rand( vec2 uv ) {\n  const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n  highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\n  return fract( sin( sn ) * c );\n}\n\nmat3 transposeMat3(mat3 inMatrix) {\n  vec3 i0 = inMatrix[0];\n  vec3 i1 = inMatrix[1];\n  vec3 i2 = inMatrix[2];\n\n  mat3 outMatrix = mat3(\n    vec3(i0.x, i1.x, i2.x),\n    vec3(i0.y, i1.y, i2.y),\n    vec3(i0.z, i1.z, i2.z)\n    );\n\n  return outMatrix;\n}\n\n// https://github.com/glslify/glsl-inverse/blob/master/index.glsl\nmat3 inverseMat3(mat3 inMatrix) {\n  float a00 = inMatrix[0][0], a01 = inMatrix[0][1], a02 = inMatrix[0][2];\n  float a10 = inMatrix[1][0], a11 = inMatrix[1][1], a12 = inMatrix[1][2];\n  float a20 = inMatrix[2][0], a21 = inMatrix[2][1], a22 = inMatrix[2][2];\n\n  float b01 = a22 * a11 - a12 * a21;\n  float b11 = -a22 * a10 + a12 * a20;\n  float b21 = a21 * a10 - a11 * a20;\n\n  float det = a00 * b01 + a01 * b11 + a02 * b21;\n\n  return mat3(b01, (-a22 * a01 + a02 * a21), (a12 * a01 - a02 * a11),\n          b11, (a22 * a00 - a02 * a20), (-a12 * a00 + a02 * a10),\n          b21, (-a21 * a00 + a01 * a20), (a11 * a00 - a01 * a10)) / det;\n}\n\nstruct DirectionalLight {\n  vec3 direction;\n  float intensity;\n  vec3 color;\n};\n\nstruct IncidentLight {\n  vec3 color;\n  vec3 direction;\n  bool visible;\n};\n\nstruct ReflectedLight {\n  vec3 directDiffuse;\n  vec3 directSpecular;\n  vec3 indirectDiffuse;\n  vec3 indirectSpecular;\n};\n\nstruct GeometricContext {\n  vec3 position;\n  vec3 normal;\n  vec3 viewDir;\n};\nlayout(std140) uniform ub_SceneParams {\n  mat4 u_ProjectionMatrix;\n  mat4 u_ViewMatrix;\n  vec3 u_CameraPosition;\n  float u_DevicePixelRatio;\n  vec2 u_Viewport;\n  float u_IsOrtho;\n  float u_IsPicking;\n};\nlayout(std140) uniform ub_MaterialParams {\n  #ifdef USE_WIREFRAME\n    vec3 u_WireframeLineColor;\n    float u_WireframeLineWidth;\n  #endif\n\n  #ifdef USE_FOG\n    vec4 u_FogInfos;\n    vec3 u_FogColor;\n  #endif\n\n  float u_Size;\n  vec4 u_Placeholder;\n};\n\nin vec4 v_PickingResult;\nin vec4 v_Color;\nin vec4 v_StrokeColor;\nin vec4 v_StylePacked1;\nin vec4 v_StylePacked2;\n#ifdef USE_MAP\n  uniform sampler2D u_Map;\n#endif\n#ifdef USE_FOG\n  #define FOGMODE_NONE 0.\n  #define FOGMODE_EXP 1.\n  #define FOGMODE_EXP2 2.\n  #define FOGMODE_LINEAR 3.\n\n  // in float v_FogDepth;\n\n  float dBlendModeFogFactor = 1.0;\n\n  vec3 addFog(vec3 color) {\n    float depth = gl_FragCoord.z / gl_FragCoord.w;\n    // float depth = v_FogDepth;\n    float fogFactor;\n    float fogStart = u_FogInfos.y;\n    float fogEnd = u_FogInfos.z;\n    float fogDensity = u_FogInfos.w;\n\n    if (u_FogInfos.x == FOGMODE_NONE) {\n      fogFactor = 1.0;\n    } else if (u_FogInfos.x == FOGMODE_EXP) {\n      fogFactor = exp(-depth * fogDensity);\n    } else if (u_FogInfos.x == FOGMODE_EXP2) {\n      fogFactor = exp(-depth * depth * fogDensity * fogDensity);\n    } else if (u_FogInfos.x == FOGMODE_LINEAR) {\n      fogFactor = (fogEnd - depth) / (fogEnd - fogStart);\n    }\n\n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n    return mix(u_FogColor * dBlendModeFogFactor, color, fogFactor);\n  }\n#endif\n\nout vec4 outputColor;\n\nvoid main() {\n  vec4 u_Color = v_Color;\nvec4 u_StrokeColor = v_StrokeColor;\nfloat u_Opacity = v_StylePacked1.x;\nfloat u_FillOpacity = v_StylePacked1.y;\nfloat u_StrokeOpacity = v_StylePacked1.z;\nfloat u_StrokeWidth = v_StylePacked1.w;\nfloat u_Visible = v_StylePacked2.x;\nvec3 u_PickingColor = v_PickingResult.xyz;\n\nif (u_Visible < 0.5) {\n    discard;\n}\n  #ifdef USE_MAP\n  vec2 uv = vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y);\n\tvec4 mapTexel = texture(SAMPLER_2D(u_Map), uv);\n  u_Color *= mapTexel;\n#endif\n\n  if (u_IsPicking > 0.5) {\n    if (u_PickingColor.x == 0.0 && u_PickingColor.y == 0.0 && u_PickingColor.z == 0.0) {\n      discard;\n    }\n    outputColor = vec4(u_PickingColor, 1.0);\n  } else {\n    outputColor = u_Color;\n    outputColor.a = outputColor.a * u_Opacity;\n    vec4 diffuseColor = outputColor;\n\n    vec3 outgoingLight = diffuseColor.rgb;\n    \n    outputColor = vec4(outgoingLight, diffuseColor.a);\n\n    #ifdef USE_FOG\n  outputColor.rgb = addFog(outputColor.rgb);\n#endif\n  }\n}"; // eslint-disable-line

var Uniform;
(function (Uniform) {
    Uniform["MAP"] = "u_Map";
    Uniform["PLACE_HOLDER"] = "u_Placeholder";
    Uniform["SIZE"] = "u_Size";
})(Uniform || (Uniform = {}));
/**
 * not affected by lights
 * @see https://threejs.org/docs/#api/en/materials/PointMaterial
 */
var PointMaterial = /** @class */ (function (_super) {
    tslib.__extends(PointMaterial, _super);
    function PointMaterial(device, props) {
        var _a;
        var _this = _super.call(this, device, tslib.__assign({ vertexShader: vert, fragmentShader: frag, cullMode: gDeviceApi.CullMode.BACK }, props)) || this;
        _this.defines = tslib.__assign(tslib.__assign({}, _this.defines), { USE_UV: true, USE_MAP: false, USE_WIREFRAME: false, USE_FOG: false, USE_LIGHT: false });
        var _b = props || {}, map = _b.map, size = _b.size;
        if (map) {
            _this.map = map;
        }
        _this.setUniforms((_a = {},
            _a[Uniform.PLACE_HOLDER] = [0, 0, 0, 0],
            _a[Uniform.SIZE] = size || 1,
            _a));
        return _this;
    }
    Object.defineProperty(PointMaterial.prototype, "map", {
        /**
         * color map, will override fill color
         */
        get: function () {
            return this.props.map;
        },
        set: function (v) {
            var _a;
            if (this.props.map !== v) {
                this.props.map = v;
                this.programDirty = true;
            }
            this.setUniforms((_a = {},
                _a[Uniform.MAP] = v,
                _a));
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(PointMaterial.prototype, "size", {
        get: function () {
            return this.props.size;
        },
        set: function (v) {
            var _a;
            this.props.size = v;
            this.setUniforms((_a = {},
                _a[Uniform.SIZE] = v,
                _a));
        },
        enumerable: false,
        configurable: true
    });
    return PointMaterial;
}(gPluginDeviceRenderer.Material));

var Plugin = /** @class */ (function (_super) {
    tslib.__extends(Plugin, _super);
    function Plugin() {
        var _this = _super.apply(this, tslib.__spreadArray([], tslib.__read(arguments), false)) || this;
        _this.name = '3d';
        return _this;
    }
    Plugin.prototype.init = function () { };
    Plugin.prototype.destroy = function () { };
    return Plugin;
}(gLite.AbstractRendererPlugin));

Object.defineProperty(exports, 'BufferGeometry', {
    enumerable: true,
    get: function () { return gPluginDeviceRenderer.BufferGeometry; }
});
Object.defineProperty(exports, 'Fog', {
    enumerable: true,
    get: function () { return gPluginDeviceRenderer.Fog; }
});
Object.defineProperty(exports, 'FogType', {
    enumerable: true,
    get: function () { return gPluginDeviceRenderer.FogType; }
});
Object.defineProperty(exports, 'Light', {
    enumerable: true,
    get: function () { return gPluginDeviceRenderer.Light; }
});
Object.defineProperty(exports, 'Material', {
    enumerable: true,
    get: function () { return gPluginDeviceRenderer.Material; }
});
Object.defineProperty(exports, 'Mesh', {
    enumerable: true,
    get: function () { return gPluginDeviceRenderer.Mesh; }
});
Object.defineProperty(exports, 'ShaderMaterial', {
    enumerable: true,
    get: function () { return gPluginDeviceRenderer.ShaderMaterial; }
});
Object.defineProperty(exports, 'VertexAttributeBufferIndex', {
    enumerable: true,
    get: function () { return gPluginDeviceRenderer.VertexAttributeBufferIndex; }
});
Object.defineProperty(exports, 'VertexAttributeLocation', {
    enumerable: true,
    get: function () { return gPluginDeviceRenderer.VertexAttributeLocation; }
});
Object.defineProperty(exports, 'AddressMode', {
    enumerable: true,
    get: function () { return gDeviceApi.AddressMode; }
});
Object.defineProperty(exports, 'BlendFactor', {
    enumerable: true,
    get: function () { return gDeviceApi.BlendFactor; }
});
Object.defineProperty(exports, 'BlendMode', {
    enumerable: true,
    get: function () { return gDeviceApi.BlendMode; }
});
Object.defineProperty(exports, 'BufferFrequencyHint', {
    enumerable: true,
    get: function () { return gDeviceApi.BufferFrequencyHint; }
});
Object.defineProperty(exports, 'ChannelWriteMask', {
    enumerable: true,
    get: function () { return gDeviceApi.ChannelWriteMask; }
});
Object.defineProperty(exports, 'CompareFunction', {
    enumerable: true,
    get: function () { return gDeviceApi.CompareFunction; }
});
Object.defineProperty(exports, 'CullMode', {
    enumerable: true,
    get: function () { return gDeviceApi.CullMode; }
});
Object.defineProperty(exports, 'Format', {
    enumerable: true,
    get: function () { return gDeviceApi.Format; }
});
Object.defineProperty(exports, 'FrontFace', {
    enumerable: true,
    get: function () { return gDeviceApi.FrontFace; }
});
Object.defineProperty(exports, 'GL', {
    enumerable: true,
    get: function () { return gDeviceApi.GL; }
});
Object.defineProperty(exports, 'MipmapFilterMode', {
    enumerable: true,
    get: function () { return gDeviceApi.MipmapFilterMode; }
});
Object.defineProperty(exports, 'PrimitiveTopology', {
    enumerable: true,
    get: function () { return gDeviceApi.PrimitiveTopology; }
});
Object.defineProperty(exports, 'SamplerFormatKind', {
    enumerable: true,
    get: function () { return gDeviceApi.SamplerFormatKind; }
});
Object.defineProperty(exports, 'StencilOp', {
    enumerable: true,
    get: function () { return gDeviceApi.StencilOp; }
});
Object.defineProperty(exports, 'TextureDimension', {
    enumerable: true,
    get: function () { return gDeviceApi.TextureDimension; }
});
Object.defineProperty(exports, 'TextureUsage', {
    enumerable: true,
    get: function () { return gDeviceApi.TextureUsage; }
});
Object.defineProperty(exports, 'VertexStepMode', {
    enumerable: true,
    get: function () { return gDeviceApi.VertexStepMode; }
});
exports.AmbientLight = AmbientLight;
exports.CapsuleGeometry = CapsuleGeometry;
exports.ConeGeometry = ConeGeometry;
exports.CubeGeometry = CubeGeometry;
exports.CylinderGeometry = CylinderGeometry;
exports.DirectionalLight = DirectionalLight;
exports.MeshBasicMaterial = MeshBasicMaterial;
exports.MeshLambertMaterial = MeshLambertMaterial;
exports.MeshPhongMaterial = MeshPhongMaterial;
exports.PlaneGeometry = PlaneGeometry;
exports.Plugin = Plugin;
exports.PointMaterial = PointMaterial;
exports.ProceduralGeometry = ProceduralGeometry;
exports.SphereGeometry = SphereGeometry;
exports.TorusGeometry = TorusGeometry;
//# sourceMappingURL=index.js.map

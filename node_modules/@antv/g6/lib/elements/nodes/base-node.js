"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseNode = void 0;
const g_1 = require("@antv/g");
const element_1 = require("../../utils/element");
const node_1 = require("../../utils/node");
const palette_1 = require("../../utils/palette");
const point_1 = require("../../utils/point");
const position_1 = require("../../utils/position");
const prefix_1 = require("../../utils/prefix");
const size_1 = require("../../utils/size");
const style_1 = require("../../utils/style");
const text_1 = require("../../utils/text");
const transform_1 = require("../../utils/transform");
const base_element_1 = require("../base-element");
const shapes_1 = require("../shapes");
/**
 * <zh/> 节点元素的基类
 *
 * <en/> Base node class
 * @remarks
 * <zh/> 自定义节点时，建议将此类作为基类。这样，你只需要关注如何实现 keyShape 的绘制逻辑
 *
 * <zh/> 设计文档：https://www.yuque.com/antv/g6/gl1iof1xpzg6ed98
 *
 * <en/> When customizing a node, it is recommended to use this class as the base class. This way, you can directly focus on how to implement the drawing logic of keyShape
 *
 * <en/> Design document: https://www.yuque.com/antv/g6/gl1iof1xpzg6ed98
 */
class BaseNode extends base_element_1.BaseElement {
    type = 'node';
    static defaultStyleProps = {
        x: 0,
        y: 0,
        size: 32,
        droppable: true,
        draggable: true,
        port: true,
        ports: [],
        portZIndex: 2,
        portLinkToCenter: false,
        badge: true,
        badges: [],
        badgeZIndex: 3,
        halo: false,
        haloDroppable: false,
        haloLineDash: 0,
        haloLineWidth: 12,
        haloStrokeOpacity: 0.25,
        haloPointerEvents: 'none',
        haloZIndex: -1,
        icon: true,
        iconZIndex: 1,
        label: true,
        labelIsBillboard: true,
        labelMaxWidth: '200%',
        labelPlacement: 'bottom',
        labelWordWrap: false,
        labelZIndex: 0,
    };
    constructor(options) {
        super((0, style_1.mergeOptions)({ style: BaseNode.defaultStyleProps }, options));
    }
    getSize(attributes = this.attributes) {
        const { size } = attributes;
        return (0, size_1.parseSize)(size);
    }
    getKeyStyle(attributes) {
        const style = this.getGraphicStyle(attributes);
        return Object.assign((0, prefix_1.omitStyleProps)(style, ['label', 'halo', 'icon', 'badge', 'port']));
    }
    getLabelStyle(attributes) {
        if (attributes.label === false || !attributes.labelText)
            return false;
        const { placement, maxWidth, offsetX, offsetY, ...labelStyle } = (0, prefix_1.subStyleProps)(this.getGraphicStyle(attributes), 'label');
        const keyShape = this.getShape('key');
        const keyBounds = keyShape.getLocalBounds();
        return Object.assign((0, element_1.getTextStyleByPlacement)(keyBounds, placement, offsetX, offsetY), { wordWrapWidth: (0, text_1.getWordWrapWidthByBox)(keyBounds, maxWidth) }, labelStyle);
    }
    getHaloStyle(attributes) {
        if (attributes.halo === false)
            return false;
        const { fill, ...keyStyle } = this.getKeyStyle(attributes);
        const haloStyle = (0, prefix_1.subStyleProps)(this.getGraphicStyle(attributes), 'halo');
        return { ...keyStyle, stroke: fill, ...haloStyle };
    }
    getIconStyle(attributes) {
        if (attributes.icon === false || (!attributes.iconText && !attributes.iconSrc))
            return false;
        const iconStyle = (0, prefix_1.subStyleProps)(this.getGraphicStyle(attributes), 'icon');
        const keyShape = this.getShape('key');
        const [x, y] = (0, position_1.getXYByPlacement)(keyShape.getLocalBounds(), 'center');
        return Object.assign({ x, y }, (0, node_1.inferIconStyle)(attributes.size, iconStyle), iconStyle);
    }
    getBadgesStyle(attributes) {
        const badges = (0, prefix_1.subObject)(this.shapeMap, 'badge-');
        const badgesShapeStyle = {};
        Object.keys(badges).forEach((key) => {
            badgesShapeStyle[key] = false;
        });
        if (attributes.badge === false || !attributes.badges?.length)
            return badgesShapeStyle;
        const { badges: badgeOptions = [], badgePalette, opacity = 1, ...restAttributes } = attributes;
        const colors = (0, palette_1.getPaletteColors)(badgePalette);
        const badgeStyle = (0, prefix_1.subStyleProps)(this.getGraphicStyle(restAttributes), 'badge');
        badgeOptions.forEach((option, i) => {
            badgesShapeStyle[i] = {
                backgroundFill: colors ? colors[i % colors?.length] : undefined,
                opacity,
                ...badgeStyle,
                ...this.getBadgeStyle(option),
            };
        });
        return badgesShapeStyle;
    }
    getBadgeStyle(style) {
        const keyShape = this.getShape('key');
        const { placement = 'top', offsetX, offsetY, ...restStyle } = style;
        const textStyle = (0, element_1.getTextStyleByPlacement)(keyShape.getLocalBounds(), placement, offsetX, offsetY, true);
        return { ...textStyle, ...restStyle };
    }
    getPortsStyle(attributes) {
        const ports = this.getPorts();
        const portsShapeStyle = {};
        Object.keys(ports).forEach((key) => {
            portsShapeStyle[key] = false;
        });
        if (attributes.port === false || !attributes.ports?.length)
            return portsShapeStyle;
        const portStyle = (0, prefix_1.subStyleProps)(this.getGraphicStyle(attributes), 'port');
        const { ports: portOptions = [] } = attributes;
        portOptions.forEach((option, index) => {
            const key = option.key || index;
            const mergedStyle = { ...portStyle, ...option };
            if ((0, element_1.isSimplePort)(mergedStyle)) {
                portsShapeStyle[key] = false;
            }
            else {
                const [x, y] = this.getPortXY(attributes, option);
                portsShapeStyle[key] = { transform: `translate(${x}, ${y})`, ...mergedStyle };
            }
        });
        return portsShapeStyle;
    }
    getPortXY(attributes, style) {
        const { placement = 'left' } = style;
        const bounds = this.getShape('key').getLocalBounds();
        return (0, element_1.getPortXYByPlacement)(bounds, placement);
    }
    /**
     * Get the ports for the node.
     * @returns Ports shape map.
     */
    getPorts() {
        return (0, prefix_1.subObject)(this.shapeMap, 'port-');
    }
    /**
     * Get the center point of the node.
     * @returns The center point of the node.
     */
    getCenter() {
        return this.getShape('key').getBounds().center;
    }
    /**
     * Get the point on the outer contour of the node that is the intersection with a line starting in the center the ending in the point `p`.
     * @param point - The point to intersect with the node.
     * @returns The intersection point.
     */
    getIntersectPoint(point) {
        const keyShapeBounds = this.getShape('key').getBounds();
        return (0, point_1.getRectIntersectPoint)(point, keyShapeBounds);
    }
    drawHaloShape(attributes, container) {
        const keyShape = this.getShape('key');
        this.upsert('halo', keyShape.constructor, this.getHaloStyle(attributes), container);
    }
    drawIconShape(attributes, container) {
        this.upsert('icon', shapes_1.Icon, this.getIconStyle(attributes), container);
    }
    drawBadgeShapes(attributes, container) {
        const badgesStyle = this.getBadgesStyle(attributes);
        Object.keys(badgesStyle).forEach((key) => {
            this.upsert(`badge-${key}`, shapes_1.Badge, badgesStyle[key], container);
        });
    }
    drawPortShapes(attributes, container) {
        const portsStyle = this.getPortsStyle(attributes);
        Object.keys(portsStyle).forEach((key) => {
            this.upsert(`port-${key}`, g_1.Circle, portsStyle[key], container);
        });
    }
    drawLabelShape(attributes, container) {
        this.upsert('label', shapes_1.Label, this.getLabelStyle(attributes), container);
    }
    render(attributes = this.parsedAttributes, container = this) {
        // Use `transform: translate3d()` instead of `x/y/z`
        const { x = 0, y = 0, z = 0, transform } = attributes;
        if (x !== 0 || y !== 0 || z !== 0) {
            this.style.transform = (0, transform_1.replaceTranslateInTransform)(x, y, z, transform);
        }
        // 1. key shape
        const keyShape = this.drawKeyShape(attributes, container);
        if (!keyShape)
            return;
        // 2. halo, use shape same with keyShape
        this.drawHaloShape(attributes, container);
        // 3. icon
        this.drawIconShape(attributes, container);
        // 4. badges
        this.drawBadgeShapes(attributes, container);
        // 5. label
        this.drawLabelShape(attributes, container);
        // 6. ports
        this.drawPortShapes(attributes, container);
    }
    onframe() {
        this.drawBadgeShapes(this.parsedAttributes, this);
        this.drawLabelShape(this.parsedAttributes, this);
    }
}
exports.BaseNode = BaseNode;
//# sourceMappingURL=base-node.js.map
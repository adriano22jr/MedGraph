"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Polyline = void 0;
const bbox_1 = require("../../utils/bbox");
const edge_1 = require("../../utils/edge");
const element_1 = require("../../utils/element");
const prefix_1 = require("../../utils/prefix");
const orth_1 = require("../../utils/router/orth");
const style_1 = require("../../utils/style");
const base_edge_1 = require("./base-edge");
/**
 * <zh/> 折线
 *
 * <en/> Polyline
 */
class Polyline extends base_edge_1.BaseEdge {
    static defaultStyleProps = {
        radius: 0,
        controlPoints: [],
        router: false,
        routerName: 'orth',
        routerPadding: 10,
    };
    constructor(options) {
        super((0, style_1.mergeOptions)({ style: Polyline.defaultStyleProps }, options));
    }
    getKeyPath(attributes) {
        const { radius } = attributes;
        const { sourceNode, targetNode } = this;
        // 1. 获取连接点（若有连接桩，取连接桩中心；反之，取节点中心）和连接桩 | Get connection points (if port, take port center; otherwise, take node center) and ports
        const { sourcePoint, targetPoint, sourcePort, targetPort } = this.getEndpointsAndPorts(attributes);
        // 2. 计算控制点 | Calculate control points
        const controlPoints = this.getControlPoints(attributes, sourcePoint, targetPoint);
        // 3. 计算实际的连接点 | Calculate the actual connection points
        const newSourcePoint = (0, element_1.getConnectionPoint)(sourcePort || sourceNode, controlPoints[0] || targetPort || targetNode);
        const newTargetPoint = (0, element_1.getConnectionPoint)(targetPort || targetNode, controlPoints[controlPoints.length - 1] || sourcePort || sourceNode);
        // 4. 获取路径 | Get the path
        return (0, edge_1.getPolylinePath)([newSourcePoint, ...controlPoints, newTargetPoint], radius);
    }
    getEndpointsAndPorts(attributes) {
        const { sourcePort: sourcePortKey, targetPort: targetPortKey } = attributes;
        const { sourceNode, targetNode } = this;
        const [sourcePort, targetPort] = (0, element_1.findPorts)(sourceNode, targetNode, sourcePortKey, targetPortKey);
        return {
            sourcePoint: sourcePort ? (0, element_1.getPortPosition)(sourcePort) : sourceNode.getCenter(),
            targetPoint: targetPort ? (0, element_1.getPortPosition)(targetPort) : targetNode.getCenter(),
            sourcePort,
            targetPort,
        };
    }
    getControlPoints(attributes, sourcePoint, targetPoint) {
        const { controlPoints, router, routerPadding } = attributes;
        const { sourceNode, targetNode } = this;
        if (!router)
            return [...controlPoints];
        const sourceBBox = (0, bbox_1.getNodeBBox)(sourceNode, routerPadding);
        const targetBBox = (0, bbox_1.getNodeBBox)(targetNode, routerPadding);
        return (0, orth_1.orth)(sourcePoint, targetPoint, sourceBBox, targetBBox, controlPoints, routerPadding);
    }
    getLoopPath(attributes) {
        const { sourcePort: sourcePortKey, targetPort: targetPortKey, radius } = attributes;
        const node = this.sourceNode;
        const bbox = (0, bbox_1.getNodeBBox)(node);
        // 默认转折点距离为 bbox 的最大宽高的 1/4 | Default distance of the turning point is 1/4 of the maximum width and height of the bbox
        const defaultDist = Math.max((0, bbox_1.getBBoxWidth)(bbox), (0, bbox_1.getBBoxHeight)(bbox)) / 4;
        const { placement, clockwise, dist = defaultDist, } = (0, prefix_1.subStyleProps)(this.getGraphicStyle(attributes), 'loop');
        return (0, edge_1.getPolylineLoopPath)(node, radius, placement, clockwise, dist, sourcePortKey, targetPortKey);
    }
}
exports.Polyline = Polyline;
//# sourceMappingURL=polyline.js.map
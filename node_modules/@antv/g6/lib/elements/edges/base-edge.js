"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseEdge = void 0;
const g_1 = require("@antv/g");
const util_1 = require("@antv/util");
const bbox_1 = require("../../utils/bbox");
const edge_1 = require("../../utils/edge");
const element_1 = require("../../utils/element");
const prefix_1 = require("../../utils/prefix");
const size_1 = require("../../utils/size");
const style_1 = require("../../utils/style");
const Symbol = __importStar(require("../../utils/symbol"));
const text_1 = require("../../utils/text");
const base_element_1 = require("../base-element");
const shapes_1 = require("../shapes");
/**
 * <zh/> 边元素基类
 *
 * <en/> Base class of the edge
 */
class BaseEdge extends base_element_1.BaseElement {
    type = 'edge';
    static defaultStyleProps = {
        badge: true,
        badgeOffsetX: 0,
        badgeOffsetY: 0,
        badgePlacement: 'suffix',
        isBillboard: true,
        label: true,
        labelAutoRotate: true,
        labelIsBillboard: true,
        labelMaxWidth: '80%',
        labelOffsetX: 4,
        labelOffsetY: 0,
        labelPlacement: 'center',
        labelTextBaseline: 'middle',
        labelWordWrap: false,
        halo: false,
        haloDroppable: false,
        haloLineDash: 0,
        haloLineWidth: 12,
        haloPointerEvents: 'none',
        haloStrokeOpacity: 0.25,
        haloZIndex: -1,
        loop: true,
        startArrow: false,
        startArrowLineDash: 0,
        startArrowLineJoin: 'round',
        startArrowLineWidth: 1,
        startArrowTransformOrigin: 'center',
        startArrowType: 'vee',
        endArrow: false,
        endArrowLineDash: 0,
        endArrowLineJoin: 'round',
        endArrowLineWidth: 1,
        endArrowTransformOrigin: 'center',
        endArrowType: 'vee',
        loopPlacement: 'top',
        loopClockwise: true,
    };
    constructor(options) {
        super((0, style_1.mergeOptions)({ style: BaseEdge.defaultStyleProps }, options));
    }
    get sourceNode() {
        const { context, sourceNode: source } = this.parsedAttributes;
        return context.element.getElement(source);
    }
    get targetNode() {
        const { context, targetNode: target } = this.parsedAttributes;
        return context.element.getElement(target);
    }
    getKeyStyle(attributes) {
        const { loop, ...style } = this.getGraphicStyle(attributes);
        const { sourceNode, targetNode } = this;
        const d = loop && (0, element_1.isSameNode)(sourceNode, targetNode) ? this.getLoopPath(attributes) : this.getKeyPath(attributes);
        return {
            d,
            ...(0, prefix_1.omitStyleProps)(style, ['halo', 'label', 'startArrow', 'endArrow']),
        };
    }
    getLoopPath(attributes) {
        const { sourcePort, targetPort } = attributes;
        const node = this.sourceNode;
        const bbox = (0, bbox_1.getNodeBBox)(node);
        const defaultDist = Math.max((0, bbox_1.getBBoxWidth)(bbox), (0, bbox_1.getBBoxHeight)(bbox));
        const { placement, clockwise, dist = defaultDist, } = (0, prefix_1.subStyleProps)(this.getGraphicStyle(attributes), 'loop');
        return (0, edge_1.getCubicLoopPath)(node, placement, clockwise, dist, sourcePort, targetPort);
    }
    getEndpoints(attributes) {
        const { sourcePort: sourcePortKey, targetPort: targetPortKey } = attributes;
        const { sourceNode, targetNode } = this;
        const [sourcePort, targetPort] = (0, element_1.findPorts)(sourceNode, targetNode, sourcePortKey, targetPortKey);
        const sourcePoint = (0, element_1.getConnectionPoint)(sourcePort || sourceNode, targetPort || targetNode);
        const targetPoint = (0, element_1.getConnectionPoint)(targetPort || targetNode, sourcePort || sourceNode);
        return [sourcePoint, targetPoint];
    }
    getHaloStyle(attributes) {
        if (attributes.halo === false)
            return false;
        const keyStyle = this.getKeyStyle(attributes);
        const haloStyle = (0, prefix_1.subStyleProps)(this.getGraphicStyle(attributes), 'halo');
        return { ...keyStyle, ...haloStyle };
    }
    getLabelStyle(attributes) {
        if (attributes.label === false || !attributes.labelText)
            return false;
        const labelStyle = (0, prefix_1.subStyleProps)(this.getGraphicStyle(attributes), 'label');
        const { placement, offsetX, offsetY, autoRotate, maxWidth, ...restStyle } = labelStyle;
        const labelPositionStyle = (0, edge_1.getLabelPositionStyle)(this.shapeMap.key, placement, autoRotate, offsetX, offsetY);
        const bbox = this.shapeMap.key.getLocalBounds();
        const wordWrapWidth = (0, text_1.getWordWrapWidthByEnds)([bbox.min, bbox.max], maxWidth);
        return Object.assign({ wordWrapWidth }, labelPositionStyle, restStyle);
    }
    getBadgeStyle(attributes) {
        if (attributes.badge === false || !attributes.badgeText)
            return false;
        const { offsetX, offsetY, placement, ...badgeStyle } = (0, prefix_1.subStyleProps)(attributes, 'badge');
        return Object.assign(badgeStyle, (0, edge_1.getBadgePositionStyle)(this.shapeMap, placement, attributes.labelPlacement, offsetX, offsetY));
    }
    drawArrow(attributes, type) {
        const isStart = type === 'start';
        const arrowType = type === 'start' ? 'startArrow' : 'endArrow';
        const enable = attributes[arrowType];
        const keyShape = this.shapeMap.key;
        if (enable) {
            const arrowStyle = this.getArrowStyle(attributes, isStart);
            const [marker, markerOffset, arrowOffset] = isStart
                ? ['markerStart', 'markerStartOffset', 'startArrowOffset']
                : ['markerEnd', 'markerEndOffset', 'endArrowOffset'];
            const arrow = keyShape.parsedStyle[marker];
            // update
            if (arrow)
                arrow.attr(arrowStyle);
            // create
            else {
                const Ctor = arrowStyle.src ? g_1.Image : g_1.Path;
                const arrowShape = new Ctor({ style: arrowStyle });
                keyShape.style[marker] = arrowShape;
            }
            keyShape.style[markerOffset] = attributes[arrowOffset] || arrowStyle.width / 2 + +arrowStyle.lineWidth;
        }
        else {
            // destroy
            const marker = isStart ? 'markerStart' : 'markerEnd';
            keyShape.style[marker]?.destroy();
            keyShape.style[marker] = null;
        }
    }
    getArrowStyle(attributes, isStart) {
        const keyStyle = this.getShape('key').attributes;
        const arrowType = isStart ? 'startArrow' : 'endArrow';
        const { size, type, ...arrowStyle } = (0, prefix_1.subStyleProps)(this.getGraphicStyle(attributes), arrowType);
        const [width, height] = (0, size_1.parseSize)((0, edge_1.getArrowSize)(keyStyle.lineWidth, size));
        const arrowFn = (0, util_1.isFunction)(type) ? type : Symbol[type] || Symbol.triangle;
        const d = arrowFn(width, height);
        return Object.assign((0, util_1.pick)(keyStyle, ['stroke', 'strokeOpacity', 'fillOpacity']), { width, height }, { ...(d && { d, fill: type === 'simple' ? '' : keyStyle.stroke }) }, arrowStyle);
    }
    drawLabelShape(attributes, container) {
        this.upsert('label', shapes_1.Label, this.getLabelStyle(attributes), container);
    }
    drawHaloShape(attributes, container) {
        this.upsert('halo', g_1.Path, this.getHaloStyle(attributes), container);
    }
    drawBadgeShape(attributes, container) {
        this.upsert('badge', shapes_1.Badge, this.getBadgeStyle(attributes), container);
    }
    drawKeyShape(attributes, container) {
        const key = this.upsert('key', g_1.Path, this.getKeyStyle(attributes), container);
        this.drawArrow(attributes, 'start');
        this.drawArrow(attributes, 'end');
        return key;
    }
    render(attributes = this.parsedAttributes, container = this) {
        // 1. key shape
        const keyShape = this.drawKeyShape(attributes, container);
        if (!keyShape)
            return;
        // 2. label
        this.drawLabelShape(attributes, container);
        // 3. halo
        this.drawHaloShape(attributes, container);
        // 4. badge
        this.drawBadgeShape(attributes, container);
    }
    onframe() {
        this.drawKeyShape(this.parsedAttributes, this);
        this.drawHaloShape(this.parsedAttributes, this);
        this.drawLabelShape(this.parsedAttributes, this);
        this.drawBadgeShape(this.parsedAttributes, this);
    }
    animate(keyframes, options) {
        const animation = super.animate(keyframes, options);
        if (!animation)
            return animation;
        // 设置 currentTime 时触发更新
        // Trigger update when setting currentTime
        return new Proxy(animation, {
            set: (target, propKey, value) => {
                // 需要推迟 onframe 调用时机，等待节点位置更新完成
                // Need to delay the timing of the onframe call, wait for the node position update to complete
                if (propKey === 'currentTime')
                    Promise.resolve().then(() => this.onframe());
                return Reflect.set(target, propKey, value);
            },
        });
    }
}
exports.BaseEdge = BaseEdge;
//# sourceMappingURL=base-edge.js.map
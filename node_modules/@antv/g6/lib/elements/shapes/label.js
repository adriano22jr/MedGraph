"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Label = void 0;
const g_1 = require("@antv/g");
const padding_1 = require("../../utils/padding");
const prefix_1 = require("../../utils/prefix");
const style_1 = require("../../utils/style");
const base_shape_1 = require("./base-shape");
class Label extends base_shape_1.BaseShape {
    static defaultStyleProps = {
        padding: 0,
        fontSize: 12,
        wordWrap: true,
        maxLines: 1,
        wordWrapWidth: 128,
        textOverflow: '...',
        textBaseline: 'middle',
        backgroundOpacity: 0.75,
        backgroundZIndex: -1,
        backgroundLineWidth: 0,
    };
    constructor(options) {
        super((0, style_1.mergeOptions)({ style: Label.defaultStyleProps }, options));
    }
    isTextStyle(key) {
        return (0, prefix_1.startsWith)(key, 'label');
    }
    isBackgroundStyle(key) {
        return (0, prefix_1.startsWith)(key, 'background');
    }
    getTextStyle(attributes) {
        const { padding, ...style } = this.getGraphicStyle(attributes);
        return (0, prefix_1.omitStyleProps)(style, 'background');
    }
    getBackgroundStyle(attributes) {
        if (attributes.background === false)
            return false;
        const style = this.getGraphicStyle(attributes);
        const { wordWrap, wordWrapWidth, padding } = style;
        const backgroundStyle = (0, prefix_1.subStyleProps)(style, 'background');
        const { min: [minX, minY], center: [centerX, centerY], halfExtents: [halfWidth, halfHeight], } = this.shapeMap.text.getGeometryBounds();
        const [top, right, bottom, left] = (0, padding_1.parsePadding)(padding);
        const totalWidth = halfWidth * 2 + left + right;
        const { width, height } = backgroundStyle;
        if (width && height) {
            Object.assign(backgroundStyle, { x: centerX - Number(width) / 2, y: centerY - Number(height) / 2 });
        }
        else {
            Object.assign(backgroundStyle, {
                x: minX - left,
                y: minY - top,
                width: wordWrap ? Math.min(totalWidth, wordWrapWidth) : totalWidth,
                height: halfHeight * 2 + top + bottom,
            });
        }
        // parse percentage radius
        const { radius } = backgroundStyle;
        // if radius look like '10%', convert it to number
        if (typeof radius === 'string' && radius.endsWith('%')) {
            const percentage = Number(radius.replace('%', '')) / 100;
            backgroundStyle.radius = Math.min(+backgroundStyle.width, +backgroundStyle.height) * percentage;
        }
        return backgroundStyle;
    }
    render(attributes = this.parsedAttributes, container = this) {
        this.upsert('text', g_1.Text, this.getTextStyle(attributes), container);
        this.upsert('background', g_1.Rect, this.getBackgroundStyle(attributes), container);
    }
    getGeometryBounds() {
        const shape = this.getShape('background') || this.getShape('text');
        return shape.getGeometryBounds();
    }
}
exports.Label = Label;
//# sourceMappingURL=label.js.map
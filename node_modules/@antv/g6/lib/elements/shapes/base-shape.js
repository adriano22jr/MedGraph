"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BaseShape = void 0;
const g_1 = require("@antv/g");
const util_1 = require("@antv/util");
const animation_1 = require("../../utils/animation");
const element_1 = require("../../utils/element");
const prefix_1 = require("../../utils/prefix");
const visibility_1 = require("../../utils/visibility");
class BaseShape extends g_1.CustomElement {
    constructor(options) {
        super(options);
        this.render(this.attributes, this);
        this.setVisibility();
        this.bindEvents();
    }
    get parsedAttributes() {
        return this.attributes;
    }
    /**
     * <zh> 图形实例映射表
     *
     * <en> shape instance map
     */
    shapeMap = {};
    /**
     * <zh> 动画实例映射表
     *
     * <en> animation instance map
     */
    animateMap = {};
    /**
     * <zh> 创建、更新或删除图形
     *
     * <en> create, update or remove shape
     * @param className - <zh> 图形名称 | <en> shape name
     * @param Ctor - <zh> 图形类型 | <en> shape type
     * @param style - <zh> 图形样式 | <en> shape style
     * @param container - <zh> 容器 | <en> container
     * @returns <zh> 图形实例 | <en> shape instance
     */
    upsert(className, Ctor, style, container) {
        const target = this.shapeMap[className];
        // remove
        // 如果 style 为 false，则删除图形 / remove shape if style is false
        if (style === false) {
            if (target) {
                container.removeChild(target);
                delete this.shapeMap[className];
            }
            return;
        }
        // create
        if (!target) {
            const instance = new Ctor({ className, style });
            container.appendChild(instance);
            this.shapeMap[className] = instance;
            return instance;
        }
        // update
        (0, element_1.updateStyle)(target, style);
        return target;
    }
    update(attr = {}) {
        this.attr(Object.assign({}, this.attributes, attr));
        this.render(this.attributes, this);
        this.setVisibility();
    }
    bindEvents() { }
    /**
     * <zh/> 从给定的属性对象中提取图形样式属性。删除特定的属性，如位置、变换和类名
     *
     * <en/> Extracts the graphic style properties from a given attribute object.
     * Removes specific properties like position, transformation, and class name.
     * @param attributes - <zh/> 属性对象 | <en/> attribute object
     * @returns <zh/> 仅包含样式属性的对象 | <en/> An object containing only the style properties.
     */
    getGraphicStyle(attributes) {
        const { x, y, z, class: cls, className, transform, transformOrigin, context, zIndex, ...style } = attributes;
        return style;
    }
    /**
     * Get the prefix pairs for composite shapes used to handle animation
     * @returns tuples array where each tuple contains a key corresponding to a method `get${key}Style` and its shape prefix
     */
    get compositeShapes() {
        return [
            ['badges', 'badge-'],
            ['ports', 'port-'],
        ];
    }
    /*
     * <zh/> 是否自动托管动画
     *
     * <en/> Whether to automatically host animation
     */
    hostingAnimation = true;
    animate(keyframes, options) {
        if (keyframes.length === 0)
            return null;
        const animationMap = [];
        const result = super.animate(keyframes, options);
        if (!this.hostingAnimation)
            return result;
        if (result)
            animationMap.push(result);
        if (Array.isArray(keyframes) && keyframes.length > 0) {
            // 如果 keyframes 中仅存在 skippedAttrs 中的属性，则仅更新父元素属性（跳过子图形）
            // if only skippedAttrs exist in keyframes, only update parent element attributes (skip child shapes)
            const skippedAttrs = ['transform', 'transformOrigin', 'x', 'y', 'z', 'zIndex'];
            if (Object.keys(keyframes[0]).some((attr) => !skippedAttrs.includes(attr))) {
                Object.entries(this.shapeMap).forEach(([key, shape]) => {
                    // 如果存在方法名为 `get${key}Style` 的方法，则使用该方法获取样式，并自动为该图形实例创建动画
                    // if there is a method named `get${key}Style`, use this method to get style and automatically create animation for the shape instance
                    const methodName = `get${(0, util_1.upperFirst)(key)}Style`;
                    const method = this[methodName];
                    if ((0, util_1.isFunction)(method)) {
                        const subKeyframes = keyframes.map((style) => method.call(this, { ...this.attributes, ...style }));
                        const result = shape.animate((0, animation_1.preprocessKeyframes)(subKeyframes), options);
                        if (result)
                            animationMap.push(result);
                    }
                });
                const handleCompositeShapeAnimation = (shapeSet, name) => {
                    if (!(0, util_1.isEmpty)(shapeSet)) {
                        const methodName = `get${(0, util_1.upperFirst)(name)}Style`;
                        const method = this[methodName];
                        if ((0, util_1.isFunction)(method)) {
                            const itemsKeyframes = keyframes.map((style) => method.call(this, { ...this.attributes, ...style }));
                            Object.entries(itemsKeyframes[0]).map(([key]) => {
                                const subKeyframes = itemsKeyframes.map((styles) => styles[key]);
                                const shape = shapeSet[key];
                                if (shape) {
                                    const result = shape.animate((0, animation_1.preprocessKeyframes)(subKeyframes), options);
                                    if (result)
                                        animationMap.push(result);
                                }
                            });
                        }
                    }
                };
                this.compositeShapes.forEach(([key, prefix]) => {
                    const shapeSet = (0, prefix_1.subObject)(this.shapeMap, prefix);
                    handleCompositeShapeAnimation(shapeSet, key);
                });
            }
        }
        return (0, animation_1.createAnimationsProxy)(animationMap);
    }
    getShape(name) {
        return this.shapeMap[name];
    }
    setVisibility() {
        const { visibility } = this.attributes;
        (0, visibility_1.setVisibility)(this, visibility);
    }
    destroy() {
        this.shapeMap = {};
        this.animateMap = {};
        super.destroy();
    }
}
exports.BaseShape = BaseShape;
//# sourceMappingURL=base-shape.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.executor = void 0;
const util_1 = require("@antv/util");
const animation_1 = require("../utils/animation");
const transform_1 = require("../utils/transform");
/**
 * <zh/> 动画语法执行器
 *
 * <en/> Animation syntax executor
 * @param element - <zh/> 要执行动画的图形 | <en/> shape to execute animation
 * @param keyframes - <zh/> 动画关键帧 | <en/> animation keyframes
 * @param options - <zh/> 动画语法 | <en/> animation syntax
 * @returns <zh/> 动画实例 | <en/> animation instance
 */
const executor = (element, keyframes, options) => {
    if (!options.length)
        return null;
    const [originalStyle, modifiedStyle] = keyframes;
    /**
     * <zh/> 获取图形关键帧样式
     *
     * <en/> Get the keyframe style of the shape
     * @param shapeID - <zh/> 图形 ID | <en/> shape ID
     * @returns <zh/> 图形关键帧样式 | <en/> keyframe style of the shape
     */
    const getKeyframeStyle = (shapeID) => {
        if (shapeID) {
            const shape = element.getShape(shapeID);
            if (!shape)
                return null;
            const name = `get${(0, util_1.upperFirst)(shapeID)}Style`;
            const styler = element?.[name]?.bind(element) || ((attrs) => attrs);
            const fromStyle = styler?.(originalStyle) || {};
            const toStyle = styler?.(modifiedStyle) || {};
            return { shape, fromStyle, toStyle };
        }
        else {
            const shape = element;
            return { shape, fromStyle: originalStyle, toStyle: modifiedStyle };
        }
    };
    let mainResult;
    const subResults = options
        .map(({ fields, shape: shapeID, states: enabledStates, ...effectTiming }) => {
        const keyframeStyle = getKeyframeStyle(shapeID);
        if (!keyframeStyle)
            return null;
        const { shape, fromStyle, toStyle } = keyframeStyle;
        const keyframes = [{}, {}];
        fields.forEach((attr) => {
            Object.assign(keyframes[0], { [attr]: fromStyle[attr] ?? (0, animation_1.inferDefaultValue)(attr) });
            Object.assign(keyframes[1], { [attr]: toStyle[attr] ?? (0, animation_1.inferDefaultValue)(attr) });
        });
        // x/y -> translate
        if (keyframes.some((keyframe) => Object.keys(keyframe).some((attr) => ['x', 'y', 'z'].includes(attr)))) {
            const { x = 0, y = 0, z = 0, transform = '' } = shape.attributes || {};
            keyframes.forEach((keyframe) => {
                keyframe.transform = (0, transform_1.replaceTranslateInTransform)(keyframe.x || x, keyframe.y || y, keyframe.z || z, transform);
            });
        }
        const result = shape.animate((0, animation_1.preprocessKeyframes)(keyframes), effectTiming);
        if (shapeID === undefined)
            mainResult = result;
        return result;
    })
        .filter(Boolean);
    const result = mainResult || subResults?.[0];
    if (!result)
        return null;
    return (0, animation_1.createAnimationsProxy)(result, subResults.filter((result) => result !== result));
};
exports.executor = executor;
//# sourceMappingURL=executor.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isParallelEdges = exports.getParallelEdges = exports.groupByEndpoints = exports.ProcessParallelEdges = void 0;
const util_1 = require("@antv/util");
const change_1 = require("../utils/change");
const id_1 = require("../utils/id");
const transform_1 = require("../utils/transform");
const base_transform_1 = require("./base-transform");
const get_edge_actual_ends_1 = require("./get-edge-actual-ends");
const CUBIC_EDGE_TYPE = 'quadratic';
const CUBIC_LOOP_PLACEMENTS = [
    'top',
    'top-right',
    'right',
    'right-bottom',
    'bottom',
    'bottom-left',
    'left',
    'left-top',
];
/**
 * <zh/> 处理平行边，即多条边共享同一源节点和目标节点
 *
 * <en/> Process parallel edges which share the same source and target nodes
 */
class ProcessParallelEdges extends base_transform_1.BaseTransform {
    static defaultOptions = {
        mode: 'bundle',
        edges: undefined,
        distance: 15, // only valid for bundling mode
    };
    cacheMergeStyle = new Map();
    constructor(context, options) {
        super(context, Object.assign({}, ProcessParallelEdges.defaultOptions, options));
    }
    beforeDraw(input) {
        const edges = this.getAffectedParallelEdges(input);
        if (edges.size === 0)
            return input;
        this.options.mode === 'bundle'
            ? this.applyBundlingStyle(input, edges, this.options.distance)
            : this.applyMergingStyle(input, edges);
        return input;
    }
    getAffectedParallelEdges = (input) => {
        const { add: { edges: edgesToAdd }, update: { nodes: nodesToUpdate, edges: edgesToUpdate, combos: combosToUpdate }, remove: { edges: edgesToRemove }, } = input;
        const { model } = this.context;
        const edges = new Map();
        const addRelatedEdges = (_, id) => {
            const relatedEdgesData = model.getRelatedEdgesData(id);
            relatedEdgesData.forEach((edge) => !edges.has((0, id_1.idOf)(edge)) && edges.set((0, id_1.idOf)(edge), edge));
        };
        nodesToUpdate.forEach(addRelatedEdges);
        combosToUpdate.forEach(addRelatedEdges);
        const pushParallelEdges = (edge) => {
            const edgeData = model.getEdgeData().map((edge) => (0, get_edge_actual_ends_1.getEdgeEndsContext)(model, edge));
            const parallelEdges = (0, exports.getParallelEdges)(edge, edgeData, true);
            parallelEdges.forEach((e) => !edges.has((0, id_1.idOf)(e)) && edges.set((0, id_1.idOf)(e), e));
        };
        if (edgesToRemove.size)
            edgesToRemove.forEach(pushParallelEdges);
        if (edgesToAdd.size)
            edgesToAdd.forEach(pushParallelEdges);
        if (edgesToUpdate.size) {
            const changes = (0, change_1.groupByChangeType)((0, change_1.reduceDataChanges)(model.getChanges())).update.edges;
            edgesToUpdate.forEach((edge) => {
                pushParallelEdges(edge);
                // 当边的端点发生变化时，将原始边及其平行边一并添加到更新列表 | Add the original edge and its parallel edges to the update list when the endpoints of the edge change
                const originalEdge = changes.find((e) => (0, id_1.idOf)(e.value) === (0, id_1.idOf)(edge))?.original;
                if (originalEdge && !(0, exports.isParallelEdges)(edge, originalEdge)) {
                    pushParallelEdges(originalEdge);
                }
            });
        }
        if (!(0, util_1.isEmpty)(this.options.edges)) {
            edges.forEach((_, id) => !this.options.edges.includes(id) && edges.delete(id));
        }
        // <zh/> 按照用户指定的顺序排序，防止捆绑时的抖动 | <en/> Sort by user-set order to prevent jitter during bundling
        const edgeIds = model.getEdgeData().map(id_1.idOf);
        return new Map([...edges].sort((a, b) => edgeIds.indexOf(a[0]) - edgeIds.indexOf(b[0])));
    };
    applyBundlingStyle = (input, edges, distance) => {
        const { edgeMap, reverses } = (0, exports.groupByEndpoints)(edges);
        edgeMap.forEach((arcEdges) => {
            arcEdges.forEach((edge, i, edgeArr) => {
                const computeStyle = () => {
                    const length = edgeArr.length;
                    const style = {};
                    if (edge.source === edge.target) {
                        const len = CUBIC_LOOP_PLACEMENTS.length;
                        style.loopPlacement = CUBIC_LOOP_PLACEMENTS[i % len];
                        style.loopDist = Math.floor(i / len) * distance + 50;
                    }
                    else if (length === 1) {
                        style.curveOffset = 0;
                    }
                    else {
                        const sign = (i % 2 === 0 ? 1 : -1) * (reverses[`${edge.source}|${edge.target}|${i}`] ? -1 : 1);
                        style.curveOffset =
                            length % 2 === 1
                                ? sign * Math.ceil(i / 2) * distance * 2
                                : sign * (Math.floor(i / 2) * distance * 2 + distance);
                    }
                    return Object.assign({}, edge.style, style);
                };
                const mergedEdgeData = Object.assign(edge, { type: CUBIC_EDGE_TYPE, style: computeStyle() });
                const element = this.context.element?.getElement((0, id_1.idOf)(edge));
                if (element)
                    (0, transform_1.reassignTo)(input, 'update', 'edge', mergedEdgeData, true);
                else
                    (0, transform_1.reassignTo)(input, 'add', 'edge', mergedEdgeData, true);
            });
        });
    };
    resetEdgeStyle = (edge) => {
        const style = edge.style || {};
        const cacheStyle = this.cacheMergeStyle.get((0, id_1.idOf)(edge)) || {};
        Object.keys(cacheStyle).forEach((key) => {
            if ((0, util_1.isEqual)(style[key], cacheStyle[key])) {
                if (edge[key]) {
                    style[key] = edge[key];
                }
                else {
                    delete style[key];
                }
            }
        });
        return Object.assign(edge, { style });
    };
    applyMergingStyle = (input, edges) => {
        const { edgeMap, reverses } = (0, exports.groupByEndpoints)(edges);
        edgeMap.forEach((edges) => {
            if (edges.length === 1) {
                const edge = edges[0];
                const element = this.context.element?.getElement((0, id_1.idOf)(edge));
                (0, transform_1.reassignTo)(input, element ? 'update' : 'add', 'edge', this.resetEdgeStyle(edge), true);
                return;
            }
            const mergedStyle = edges
                .map(({ source, target, style = {} }, i) => {
                const { startArrow, endArrow } = style;
                const newStyle = {};
                const [start, end] = reverses[`${source}|${target}|${i}`]
                    ? ['endArrow', 'startArrow']
                    : ['startArrow', 'endArrow'];
                if ((0, util_1.isBoolean)(startArrow))
                    newStyle[start] = startArrow;
                if ((0, util_1.isBoolean)(endArrow))
                    newStyle[end] = endArrow;
                return newStyle;
            })
                .reduce((acc, style) => ({ ...acc, ...style }), {});
            edges.forEach((edge, i, edges) => {
                if (i === 0) {
                    const parsedStyle = Object.assign({}, (0, util_1.isFunction)(this.options.style) ? this.options.style(edges) : this.options.style, { childrenData: edges });
                    this.cacheMergeStyle.set((0, id_1.idOf)(edge), parsedStyle);
                    const mergedEdgeData = {
                        ...edge,
                        type: 'line',
                        style: { ...mergedStyle, ...parsedStyle },
                    };
                    const element = this.context.element?.getElement((0, id_1.idOf)(edge));
                    (0, transform_1.reassignTo)(input, element ? 'update' : 'add', 'edge', mergedEdgeData, true);
                }
                else {
                    (0, transform_1.reassignTo)(input, 'remove', 'edge', edge);
                }
            });
        });
    };
}
exports.ProcessParallelEdges = ProcessParallelEdges;
/**
 * <zh/> 按照端点分组
 *
 * <en/> Group by endpoints
 * @param edges - <zh/> 边集合 | <en/> Edges
 * @returns <zh/> 端点分组后的边集合 | <en/> Edges grouped by endpoints
 */
const groupByEndpoints = (edges) => {
    const edgeMap = new Map();
    const processedEdgesSet = new Set();
    const reverses = {};
    for (const [id, edge] of edges) {
        if (processedEdgesSet.has(id))
            continue;
        const { source, target } = edge;
        const sourceTarget = `${source}-${target}`;
        if (!edgeMap.has(sourceTarget))
            edgeMap.set(sourceTarget, []);
        edgeMap.get(sourceTarget).push(edge);
        processedEdgesSet.add(id);
        for (const [otherId, sedge] of edges) {
            if (processedEdgesSet.has(otherId))
                continue;
            if ((0, exports.isParallelEdges)(edge, sedge)) {
                edgeMap.get(sourceTarget).push(sedge);
                processedEdgesSet.add(otherId);
                if (source === sedge.target && target === sedge.source) {
                    reverses[`${sedge.source}|${sedge.target}|${edgeMap.get(sourceTarget).length - 1}`] = true;
                }
            }
        }
    }
    return { edgeMap, reverses };
};
exports.groupByEndpoints = groupByEndpoints;
/**
 * <zh/> 获取平行边
 *
 * <en/> Get parallel edges
 * @param edge - <zh/> 目标边 | <en/> Target edge
 * @param edges - <zh/> 边集合 | <en/> Edges
 * @param containsSelf - <zh/> 输出结果是否包含目标边 | <en/> Whether the output result contains the target edge
 * @returns <zh/> 平行边集合 | <en/> Parallel edges
 */
const getParallelEdges = (edge, edges, containsSelf) => {
    return edges.filter((e) => (containsSelf || (0, id_1.idOf)(e) !== (0, id_1.idOf)(edge)) && (0, exports.isParallelEdges)(e, edge));
};
exports.getParallelEdges = getParallelEdges;
/**
 * <zh/> 判断两条边是否平行
 *
 * <en/> Determine whether two edges are parallel
 * @param edge1 - <zh/> 边1 | <en/> Edge 1
 * @param edge2 - <zh/> 边2 | <en/> Edge 2
 * @returns <zh/> 是否平行 | <en/> Whether is parallel
 */
const isParallelEdges = (edge1, edge2) => {
    const { sourceNode: src1, targetNode: tgt1 } = edge1.style || {};
    const { sourceNode: src2, targetNode: tgt2 } = edge2.style || {};
    return (src1 === src2 && tgt1 === tgt2) || (src1 === tgt2 && tgt1 === src2);
};
exports.isParallelEdges = isParallelEdges;
//# sourceMappingURL=process-parallel-edges.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GridLine = void 0;
const constants_1 = require("../constants");
const dom_1 = require("../utils/dom");
const vector_1 = require("../utils/vector");
const base_plugin_1 = require("./base-plugin");
/**
 * <zh/> 网格线
 *
 * <en/> Grid line
 * @remarks
 * <zh/> 网格线插件，多用于辅助绘图
 *
 * <en/> Grid line plugin, often used to auxiliary drawing
 */
class GridLine extends base_plugin_1.BasePlugin {
    static defaultOptions = {
        border: true,
        borderLineWidth: 1,
        borderStroke: '#eee',
        borderStyle: 'solid',
        lineWidth: 1,
        size: 20,
        stroke: '#eee',
    };
    $element = (0, dom_1.createPluginContainer)('grid-line');
    offset = [0, 0];
    constructor(context, options) {
        super(context, Object.assign({}, GridLine.defaultOptions, options));
        const $container = this.context.canvas.getContainer();
        (0, dom_1.insertBefore)($container, this.$element);
        this.updateStyle();
        this.bindEvents();
    }
    /**
     * <zh/> 更新网格线配置
     *
     * <en/> Update the configuration of the grid line
     * @param options - <zh/> 配置项 | <en/> options
     * @internal
     */
    update(options) {
        super.update(options);
        this.updateStyle();
    }
    bindEvents() {
        const { graph } = this.context;
        graph.on(constants_1.GraphEvent.AFTER_TRANSFORM, this.onTransform);
    }
    updateStyle() {
        const { size, stroke, lineWidth, border, borderLineWidth, borderStroke, borderStyle } = this.options;
        Object.assign(this.$element.style, {
            border: border ? `${borderLineWidth}px ${borderStyle} ${borderStroke}` : 'none',
            backgroundImage: `linear-gradient(${stroke} ${lineWidth}px, transparent ${lineWidth}px), linear-gradient(90deg, ${stroke} ${lineWidth}px, transparent ${lineWidth}px)`,
            backgroundSize: `${size}px ${size}px`,
        });
    }
    updateOffset(delta) {
        this.offset = (0, vector_1.mod)((0, vector_1.add)(this.offset, delta), this.options.size);
        this.$element.style.backgroundPosition = `${this.offset[0]}px ${this.offset[1]}px`;
    }
    onTransform = (event) => {
        if (!this.options.follow)
            return;
        const { data: { translate }, } = event;
        if (translate)
            this.updateOffset(translate);
    };
    /**
     * <zh/> 销毁网格线
     *
     * <en/> Destroy the grid line
     */
    destroy() {
        this.context.graph.off(constants_1.GraphEvent.AFTER_TRANSFORM, this.onTransform);
        this.$element.remove();
        super.destroy();
    }
}
exports.GridLine = GridLine;
//# sourceMappingURL=grid-line.js.map
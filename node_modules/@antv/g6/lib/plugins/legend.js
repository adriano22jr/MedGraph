"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Legend = void 0;
const component_1 = require("@antv/component");
const util_1 = require("@antv/util");
const constants_1 = require("../constants");
const base_plugin_1 = require("./base-plugin");
/**
 * <zh/> 图例
 *
 * <en/> Legend
 * @remarks
 * <zh/> 图例插件用于展示图中元素的分类信息，支持节点、边、组合的分类信息展示。
 *
 * <en/> The legend plugin is used to display the classification information of elements in the graph, and supports the display of classification information of nodes, edges, and combos.
 */
class Legend extends base_plugin_1.BasePlugin {
    static defaultOptions = {
        position: 'bottom',
        trigger: 'hover',
        orientation: 'horizontal',
        layout: 'flex',
        itemSpacing: 4,
        rowPadding: 10,
        colPadding: 10,
        itemMarkerSize: 16,
        itemLabelFontSize: 16,
    };
    typePrefix = '__data__';
    element = null;
    draw = false;
    fieldMap = {
        node: new Map(),
        edge: new Map(),
        combo: new Map(),
    };
    selectedItems = [];
    constructor(context, options) {
        super(context, Object.assign({}, Legend.defaultOptions, options));
        this.bindEvents();
    }
    /**
     * <zh/> 更新图例配置
     *
     * <en/> Update the legend configuration
     * @param options - <zh/> 图例配置项 | <en/> Legend options
     * @internal
     */
    update(options) {
        super.update(options);
        this.clear();
        this.createElement();
    }
    clear() {
        this.element?.destroy();
        this.element = null;
        this.draw = false;
    }
    bindEvents = () => {
        const { graph } = this.context;
        graph.on(constants_1.GraphEvent.AFTER_DRAW, this.createElement);
    };
    changeState = (el, state) => {
        const { graph } = this.context;
        const { typePrefix } = this;
        const composeId = (0, util_1.get)(el, [typePrefix, 'id']);
        const category = (0, util_1.get)(el, [typePrefix, 'style', 'labelText']);
        const [type] = composeId.split('__');
        const ids = this.fieldMap[type].get(category) || [];
        graph.setElementState(Object.fromEntries(ids?.map((id) => [id, state])));
    };
    /**
     * <zh/> 图例元素点击事件
     *
     * <en/> Legend element click event
     * @param event - <zh/> 点击的元素 | <en/> The element that is clicked
     */
    click = (event) => {
        if (this.options.trigger === 'hover')
            return;
        const composeId = (0, util_1.get)(event, [this.typePrefix, 'id']);
        if (!this.selectedItems.includes(composeId)) {
            this.selectedItems.push(composeId);
            this.changeState(event, 'selected');
        }
        else {
            this.selectedItems = this.selectedItems.filter((item) => item !== composeId);
            this.changeState(event, []);
        }
    };
    /**
     * <zh/> 图例元素移出事件
     *
     * <en/> Legend element mouseleave event
     * @param event - <zh/> 移出的元素 | <en/> The element that is moved out
     */
    mouseleave = (event) => {
        if (this.options.trigger === 'click')
            return;
        this.selectedItems = [];
        this.changeState(event, []);
    };
    /**
     * <zh/> 图例元素移入事件
     *
     * <en/> Legend element mouseenter event
     * @param event - <zh/> 移入的元素 | <en/> The element that is moved in
     */
    mouseenter = (event) => {
        if (this.options.trigger === 'click')
            return;
        const composeId = (0, util_1.get)(event, [this.typePrefix, 'id']);
        if (!this.selectedItems.includes(composeId)) {
            this.selectedItems.push(composeId);
            this.changeState(event, 'active');
        }
        else {
            this.selectedItems = this.selectedItems.filter((item) => item !== composeId);
        }
    };
    /**
     * <zh/> 刷新图例元素状态
     *
     * <en/> Refresh the status of the legend element
     */
    updateElement() {
        if (!this.element)
            return;
        const category = this.element.getChildByIndex(0);
        category.update({
            itemMarkerOpacity: ({ id }) => {
                if (!this.selectedItems.length || this.selectedItems.includes(id))
                    return 1;
                return 0.5;
            },
            itemLabelOpacity: ({ id }) => {
                if (!this.selectedItems.length || this.selectedItems.includes(id))
                    return 1;
                return 0.5;
            },
        });
    }
    setFieldMap = (field, id, type) => {
        if (!field)
            return;
        const map = this.fieldMap[type];
        if (!map)
            return;
        if (!map.has(field)) {
            map.set(field, [id]);
        }
        else {
            const ids = map.get(field);
            if (ids) {
                ids.push(id);
                map.set(field, ids);
            }
        }
    };
    getEvents = () => {
        return {
            mouseenter: this.mouseenter,
            mouseleave: this.mouseleave,
            click: this.click,
        };
    };
    getMarkerData = (field, elementType) => {
        if (!field)
            return [];
        const { model, element, graph } = this.context;
        const { nodes, edges, combos } = model.getData();
        const items = {};
        const getField = (item) => {
            if ((0, util_1.isFunction)(field))
                return field(item);
            return field;
        };
        const defaultType = {
            node: 'circle',
            edge: 'line',
            combo: 'rect',
        };
        /** 用于将 G6 element 转换为 componets 支持的类型 */
        const markerMapping = {
            circle: 'circle',
            ellipse: 'circle', // 待 components 支持 ellipse
            image: 'bowtie',
            rect: 'square',
            star: 'cross',
            triangle: 'triangle',
            diamond: 'diamond',
            cubic: 'dot',
            line: 'hyphen',
            polyline: 'hyphen',
            quadratic: 'hv',
            'cubic-horizontal': 'hyphen',
            'cubic-vertical': 'line',
        };
        const getElementStyle = (type, datum) => {
            const style = element?.getElementComputedStyle(type, datum);
            return style;
        };
        const getElementModel = (data, type) => {
            data.forEach((item) => {
                const { id } = item;
                const value = (0, util_1.get)(item, ['data', getField(item)]);
                const marker = element?.getElementType(type, item) || 'circle';
                const style = getElementStyle(type, item);
                const color = (type === 'edge' ? style?.stroke : style?.fill) || '#1783ff';
                if (id && value && value.replace(/\s+/g, '')) {
                    this.setFieldMap(value, id, type);
                    if (!items[value]) {
                        items[value] = {
                            id: `${type}__${id}`,
                            label: value,
                            marker: markerMapping[marker] || defaultType[type],
                            elementType: type,
                            lineWidth: 1,
                            stroke: color,
                            fill: color,
                        };
                    }
                }
            });
        };
        switch (elementType) {
            case 'node':
                getElementModel(nodes, 'node');
                break;
            case 'edge':
                getElementModel(edges, 'edge');
                break;
            case 'combo':
                getElementModel(combos, 'combo');
                break;
            default:
                return [];
        }
        return Object.values(items);
    };
    /**
     * <zh/> 图例布局
     *
     * <en/> Legend layout
     * @param position -  <zh/> 图例位置| <en/> Legend position
     * @returns <zh/> 图例布局样式| <en/> Legend layout style
     */
    layout = (position) => {
        const preset = {
            flexDirection: 'row',
            alignItems: 'flex-end',
            justifyContent: 'center',
        };
        let { flexDirection, alignItems, justifyContent } = preset;
        const layout = {
            top: ['row', 'flex-start', 'center'],
            bottom: ['row', 'flex-end', 'center'],
            left: ['column', 'flex-start', 'center'],
            right: ['column', 'flex-end', 'center'],
        };
        if (position in layout) {
            [flexDirection, alignItems, justifyContent] = layout[position];
        }
        return {
            display: 'flex',
            flexDirection,
            justifyContent,
            alignItems,
        };
    };
    createElement = () => {
        if (this.draw) {
            this.updateElement();
            return;
        }
        const { canvas } = this.context;
        const [canvasWidth, canvasHeight] = canvas.getSize();
        const { width = canvasWidth, height = canvasHeight, nodeField, edgeField, comboField, trigger, position, ...rest } = this.options;
        const nodeItems = this.getMarkerData(nodeField, 'node');
        const edgeItems = this.getMarkerData(edgeField, 'edge');
        const comboItems = this.getMarkerData(comboField, 'combo');
        const items = [...nodeItems, ...comboItems, ...edgeItems];
        const layout = this.layout(position);
        const layoutWrapper = new component_1.Layout({
            style: {
                width,
                height,
                ...layout,
            },
        });
        const categoryStyle = Object.assign({
            width,
            height,
            data: items,
            itemMarkerLineWidth: ({ lineWidth }) => lineWidth,
            itemMarker: ({ marker }) => marker,
            itemMarkerStroke: ({ stroke }) => stroke,
            itemMarkerFill: ({ fill }) => fill,
            gridCol: nodeItems.length,
        }, rest, this.getEvents());
        const category = new component_1.Category({
            className: 'legend',
            style: categoryStyle,
        });
        layoutWrapper.appendChild(category);
        canvas.appendChild(layoutWrapper);
        this.element = layoutWrapper;
        this.draw = true;
    };
    /**
     * <zh/>销毁图例
     *
     * <en/> Destroy the legend
     */
    destroy() {
        this.clear();
        this.context.graph.off(constants_1.GraphEvent.AFTER_DRAW, this.createElement);
        super.destroy();
    }
}
exports.Legend = Legend;
//# sourceMappingURL=legend.js.map
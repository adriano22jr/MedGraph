"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.History = void 0;
const event_emitter_1 = __importDefault(require("@antv/event-emitter"));
const constants_1 = require("../../constants");
const history_1 = require("../../constants/events/history");
const id_1 = require("../../utils/id");
const base_plugin_1 = require("../base-plugin");
const util_1 = require("./util");
/**
 * <zh/> 历史记录
 *
 * <en/> History
 * @remarks
 * <zh/> 历史记录用于记录图的数据变化，支持撤销和重做等操作。
 *
 * <en/> History is used to record data changes in the graph and supports operations such as undo and redo.
 */
class History extends base_plugin_1.BasePlugin {
    static defaultOptions = {
        stackSize: 0,
    };
    emitter;
    batchChanges = null;
    batchAnimation = false;
    undoStack = [];
    redoStack = [];
    isFirstDraw = true;
    freezed = false;
    constructor(context, options) {
        super(context, Object.assign({}, History.defaultOptions, options));
        this.emitter = new event_emitter_1.default();
        const { graph } = this.context;
        graph.on(constants_1.GraphEvent.AFTER_DRAW, this.addCommand);
        graph.on(constants_1.GraphEvent.BATCH_START, this.initBatchCommand);
        graph.on(constants_1.GraphEvent.BATCH_END, this.addCommand);
    }
    /**
     * <zh/> 是否可以执行撤销操作
     *
     * <en/> Whether undo can be done
     * @returns <zh/> 是否可以执行撤销操作 | <en/> Whether undo can be done
     */
    canUndo() {
        return this.undoStack.length > 0;
    }
    /**
     * <zh/> 是否可以执行重做操作
     *
     * <en/> Whether redo can be done
     * @returns <zh/> 是否可以执行重做操作 | <en/> Whether redo can be done
     */
    canRedo() {
        return this.redoStack.length > 0;
    }
    /**
     * <zh/> 执行撤销
     *
     * <en/> Execute undo
     * @returns <zh/> 返回当前实例 | <en/> Return the current instance
     */
    undo() {
        const cmd = this.undoStack.pop();
        if (cmd) {
            this.executeCommand(cmd);
            this.options.beforeAddCommand?.(cmd, false);
            this.redoStack.push(cmd);
            this.options.afterAddCommand?.(cmd, false);
            this.notify(history_1.HistoryEvent.UNDO, cmd);
        }
        return this;
    }
    /**
     * <zh/> 执行重做
     *
     * <en/> Execute redo
     * @returns <zh/> 返回当前实例 | <en/> Return the current instance
     */
    redo() {
        const cmd = this.redoStack.pop();
        if (cmd) {
            this.executeCommand(cmd, false);
            this.undoStackPush(cmd);
            this.notify(history_1.HistoryEvent.REDO, cmd);
        }
        return this;
    }
    /**
     * <zh/> 执行撤销且不计入历史记录
     *
     * <en/> Execute undo and do not record in history
     * @returns <zh/> 返回当前实例 | <en/> Return the current instance
     */
    undoAndCancel() {
        const cmd = this.undoStack.pop();
        if (cmd) {
            this.executeCommand(cmd, false);
            this.redoStack = [];
            this.notify(history_1.HistoryEvent.CANCEL, cmd);
        }
        return this;
    }
    executeCommand = (cmd, revert = true) => {
        this.freezed = true;
        this.options.executeCommand?.(cmd);
        const values = revert ? cmd.original : cmd.current;
        this.context.graph.addData(values.add);
        this.context.graph.updateData(values.update);
        this.context.graph.removeData((0, id_1.idsOf)(values.remove, false));
        this.context.element?.draw({ silence: true, animation: cmd.animation });
        this.freezed = false;
    };
    addCommand = (event) => {
        if (this.isFirstDraw) {
            this.isFirstDraw = false;
            return;
        }
        if (this.freezed)
            return;
        if (event.type === constants_1.GraphEvent.AFTER_DRAW) {
            const { dataChanges = [], animation = true } = event.data;
            if (this.context.batch?.isBatching) {
                if (!this.batchChanges)
                    return;
                this.batchChanges.push(dataChanges);
                this.batchAnimation &&= animation;
                return;
            }
            this.batchChanges = [dataChanges];
            this.batchAnimation = animation;
        }
        this.undoStackPush((0, util_1.parseCommand)(this.batchChanges.flat(), this.batchAnimation, this.context));
        this.notify(history_1.HistoryEvent.ADD, this.undoStack[this.undoStack.length - 1]);
    };
    initBatchCommand = (event) => {
        const { initiate } = event.data;
        this.batchAnimation = false;
        if (initiate) {
            this.batchChanges = [];
        }
        else {
            const cmd = this.undoStack.pop();
            if (!cmd)
                this.batchChanges = null;
        }
    };
    undoStackPush(cmd) {
        const { stackSize } = this.options;
        if (stackSize !== 0 && this.undoStack.length >= stackSize) {
            this.undoStack.shift();
        }
        this.options.beforeAddCommand?.(cmd, true);
        this.undoStack.push(cmd);
        this.options.afterAddCommand?.(cmd, true);
    }
    /**
     * <zh/> 清空历史记录
     *
     * <en/> Clear history
     */
    clear() {
        this.undoStack = [];
        this.redoStack = [];
        this.batchChanges = null;
        this.batchAnimation = false;
        this.notify(history_1.HistoryEvent.CLEAR, null);
    }
    notify(event, cmd) {
        this.emitter.emit(event, { cmd });
        this.emitter.emit(history_1.HistoryEvent.CHANGE, { cmd });
    }
    /**
     * <zh/> 监听历史记录事件
     *
     * <en/> Listen to history events
     * @param event  - <zh/> 事件名称 | <en/> Event name
     * @param handler - <zh/> 事件处理函数 | <en/> Event handler
     */
    on(event, handler) {
        this.emitter.on(event, handler);
    }
    /**
     * <zh/> 销毁
     *
     * <en/> Destroy
     */
    destroy() {
        const { graph } = this.context;
        graph.off(constants_1.GraphEvent.AFTER_DRAW, this.addCommand);
        graph.off(constants_1.GraphEvent.BATCH_START, this.initBatchCommand);
        graph.off(constants_1.GraphEvent.BATCH_END, this.addCommand);
        this.emitter.off();
        super.destroy();
        this.undoStack = [];
        this.redoStack = [];
    }
}
exports.History = History;
//# sourceMappingURL=index.js.map
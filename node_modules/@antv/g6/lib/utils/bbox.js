"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getIncircleRadius = exports.getTriangleCenter = exports.getNearestPointToPoint = exports.getNearestSideToPoint = exports.isPointOutsideBBox = exports.isPointInBBox = exports.getCombinedBBox = exports.getExpandedBBox = exports.getPointBBox = exports.getNodeBBox = exports.getBBoxSize = exports.getBBoxHeight = exports.getBBoxWidth = void 0;
const g_1 = require("@antv/g");
const util_1 = require("@antv/util");
const is_1 = require("./is");
const math_1 = require("./math");
const padding_1 = require("./padding");
/**
 * <zh/> 获取包围盒的宽度
 *
 * <en/> Retrieves the width of a bounding box
 * @param bbox - <zh/> 包围盒 | <en/> Bounding box
 * @returns <zh/> 包围盒的宽度 | <en/> Width of box
 */
function getBBoxWidth(bbox) {
    return bbox.max[0] - bbox.min[0];
}
exports.getBBoxWidth = getBBoxWidth;
/**
 * <zh/> 获取包围盒的高度
 *
 * <en/> Retrieve the height of a bounding box
 * @param bbox - <zh/> 包围盒 | <en/> Bounding box
 * @returns <zh/> 包围盒的高度 | <en/> Height of box
 */
function getBBoxHeight(bbox) {
    return bbox.max[1] - bbox.min[1];
}
exports.getBBoxHeight = getBBoxHeight;
/**
 * <zh/> 获取包围盒的尺寸
 * @param bbox - <zh/> 包围盒 | <en/> Bounding box
 * @returns <zh/> 包围盒的尺寸 | <en/> Size of box
 */
function getBBoxSize(bbox) {
    return [getBBoxWidth(bbox), getBBoxHeight(bbox)];
}
exports.getBBoxSize = getBBoxSize;
/**
 * <zh/> 获取节点的包围盒，兼容节点为点的情况
 *
 * <en/> Get the bounding box of the node, compatible with the case where the node is a point
 * @param node - <zh/> 节点或者点 | <en/> node or point
 * @param padding - <zh/> 内边距 | <en/> padding
 * @returns <zh/> 包围盒 | <en/> bounding box
 */
function getNodeBBox(node, padding) {
    const bbox = (0, is_1.isPoint)(node) ? getPointBBox(node) : node.getShape('key').getBounds();
    return padding ? getExpandedBBox(bbox, padding) : bbox;
}
exports.getNodeBBox = getNodeBBox;
/**
 * <zh/> 获取单点的包围盒
 *
 * <en/> Get the bounding box of a single point
 * @param point - <zh/> 点 | <en/> Point
 * @returns <zh/> 包围盒 | <en/> Bounding box
 */
function getPointBBox(point) {
    const [x, y, z = 0] = point;
    const bbox = new g_1.AABB();
    bbox.setMinMax([x, y, z], [x, y, z]);
    return bbox;
}
exports.getPointBBox = getPointBBox;
/**
 * <zh/> 获取扩大后的包围盒
 *
 * <en/> Get the expanded bounding box
 * @param bbox - <zh/> 包围盒 | <en/> Bounding box
 * @param padding - <zh/> 内边距 | <en/> Padding
 * @returns <zh/> 扩大后的包围盒 | <en/> The expanded bounding box
 */
function getExpandedBBox(bbox, padding) {
    const [top, right, bottom, left] = (0, padding_1.parsePadding)(padding);
    const [minX, minY, minZ] = bbox.min;
    const [maxX, maxY, maxZ] = bbox.max;
    const eBbox = new g_1.AABB();
    eBbox.setMinMax([minX - left, minY - top, minZ], [maxX + right, maxY + bottom, maxZ]);
    return eBbox;
}
exports.getExpandedBBox = getExpandedBBox;
/**
 * <zh/> 计算整体包围盒
 *
 * <en/> Calculate the overall bounding box
 * @param bboxes - <zh/> 包围盒列表 | <en/> List of bounding boxes
 * @returns <zh/> 整体包围盒 | <en/> Overall bounding box
 */
function getCombinedBBox(bboxes) {
    if (bboxes.length === 0)
        return new g_1.AABB();
    if (bboxes.length === 1)
        return bboxes[0];
    const bbox = new g_1.AABB();
    bbox.setMinMax(bboxes[0].min, bboxes[0].max);
    for (let i = 1; i < bboxes.length; i++) {
        const b2 = bboxes[i];
        bbox.setMinMax([Math.min(bbox.min[0], b2.min[0]), Math.min(bbox.min[1], b2.min[1]), Math.min(bbox.min[2], b2.min[2])], [Math.max(bbox.max[0], b2.max[0]), Math.max(bbox.max[1], b2.max[1]), Math.max(bbox.max[2], b2.max[2])]);
    }
    return bbox;
}
exports.getCombinedBBox = getCombinedBBox;
/**
 * <zh/> 判断点是否在给定的包围盒内
 *
 * <en/> Whether the point is contained in the given box
 * @param point - <zh/> 点 | <en/> Point
 * @param bbox - <zh/> 包围盒 | <en/> Bounding box
 * @returns  <zh/> 如果点在包围盒内返回 true，否则返回 false | <en/> Returns true if the point is inside the bounding box, false otherwise
 */
function isPointInBBox(point, bbox) {
    return (0, math_1.isBetween)(point[0], bbox.min[0], bbox.max[0]) && (0, math_1.isBetween)(point[1], bbox.min[1], bbox.max[1]);
}
exports.isPointInBBox = isPointInBBox;
/**
 * <zh/> 判断点是否在给定的包围盒外
 *
 * <en/> Whether the point is outside the given box
 * @param point - <zh/> 点 | <en/> Point
 * @param bbox - <zh/> 包围盒 | <en/> Bounding box
 * @returns <zh/> 如果点在包围盒外返回 true，否则返回 false | <en/> Returns true if the point is outside the bounding box, false otherwise
 */
function isPointOutsideBBox(point, bbox) {
    return !isPointInBBox(point, bbox);
}
exports.isPointOutsideBBox = isPointOutsideBBox;
/**
 * <zh/> 获取包围盒上离点 `p` 最近的边
 *
 * <en/> Get a side of the boundary which is nearest to the point `p`
 * @param bbox - <zh/> 包围盒 | <en/> Bounding box
 * @param p - <zh/> 点 | <en/> Point
 * @returns <zh/> 离点 `p` 最近的边 | <en/> The side nearest to the point `p`
 */
function getNearestSideToPoint(bbox, p) {
    const [x, y] = p;
    const [minX, minY] = bbox.min;
    const [maxX, maxY] = bbox.max;
    const left = x - minX;
    const right = maxX - x;
    const top = y - minY;
    const bottom = maxY - y;
    const min = Math.min(left, right, top, bottom);
    return min === left ? 'left' : min === right ? 'right' : min === top ? 'top' : min === bottom ? 'bottom' : 'left';
}
exports.getNearestSideToPoint = getNearestSideToPoint;
/**
 * <zh/> 获取包围盒上离点 `p` 最近的点
 *
 * <en/> Get a point on the boundary nearest to the point `p`
 * @param bbox - <zh/> 包围盒 | <en/> Bounding box
 * @param p - <zh/> 点 | <en/> Point
 * @returns <zh/> 离点 `p` 最近的点 | <en/> The point nearest to the point `p`
 */
function getNearestPointToPoint(bbox, p) {
    const ref = (0, util_1.clone)(p);
    if (isPointInBBox(p, bbox)) {
        const side = getNearestSideToPoint(bbox, p);
        switch (side) {
            case 'left':
                ref[0] = bbox.min[0];
                break;
            case 'right':
                ref[0] = bbox.max[0];
                break;
            case 'top':
                ref[1] = bbox.min[1];
                break;
            case 'bottom':
                ref[1] = bbox.max[1];
                break;
        }
    }
    else {
        const [x, y] = p;
        const [minX, minY] = bbox.min;
        const [maxX, maxY] = bbox.max;
        ref[0] = (0, math_1.isBetween)(x, minX, maxX) ? x : x < minX ? minX : maxX;
        ref[1] = (0, math_1.isBetween)(y, minY, maxY) ? y : y < minY ? minY : maxY;
    }
    return ref;
}
exports.getNearestPointToPoint = getNearestPointToPoint;
/**
 * The triangle center point of the bounding box
 * @param bbox - bounding box
 * @param direction - direction
 * @returns Point
 */
function getTriangleCenter(bbox, direction) {
    // todo 算法只对矩形有效
    const { center } = bbox;
    const [width, height] = getBBoxSize(bbox);
    const x = direction === 'up' || direction === 'down'
        ? center[0]
        : direction === 'right'
            ? center[0] - width / 6
            : center[0] + width / 6;
    const y = direction === 'left' || direction === 'right'
        ? center[1]
        : direction === 'down'
            ? center[1] - height / 6
            : center[1] + height / 6;
    return [x, y];
}
exports.getTriangleCenter = getTriangleCenter;
/**
 * Get incircle radius
 * @param bbox - bounding box
 * @param direction - direction
 * @returns number
 */
function getIncircleRadius(bbox, direction) {
    let [w, h] = getBBoxSize(bbox);
    [w, h] = direction === 'up' || direction === 'down' ? [w, h] : [h, w];
    // 三角形的内切圆半径
    return (h ** 2 - (Math.sqrt((w / 2) ** 2 + h ** 2) - w / 2) ** 2) / (2 * h);
}
exports.getIncircleRadius = getIncircleRadius;
//# sourceMappingURL=bbox.js.map
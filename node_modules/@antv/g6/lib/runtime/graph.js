"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Graph = void 0;
const event_emitter_1 = __importDefault(require("@antv/event-emitter"));
const util_1 = require("@antv/util");
const constants_1 = require("../constants");
const registry_1 = require("../registry");
const collapsibility_1 = require("../utils/collapsibility");
const dom_1 = require("../utils/dom");
const event_1 = require("../utils/event");
const id_1 = require("../utils/id");
const point_1 = require("../utils/point");
const style_1 = require("../utils/style");
const vector_1 = require("../utils/vector");
const animation_1 = require("./animation");
const batch_1 = require("./batch");
const behavior_1 = require("./behavior");
const canvas_1 = require("./canvas");
const data_1 = require("./data");
const element_1 = require("./element");
const layout_1 = require("./layout");
const plugin_1 = require("./plugin");
const transform_1 = require("./transform");
const viewport_1 = require("./viewport");
class Graph extends event_emitter_1.default {
    options;
    /**
     * @internal
     */
    static defaultOptions = {
        autoResize: false,
        theme: 'light',
        rotation: 0,
        zoom: 1,
        zoomRange: [0.01, 10],
    };
    /**
     * <zh/> 当前图实例是否已经被销毁
     *
     * <en/> Whether the current graph instance has been destroyed
     */
    destroyed = false;
    // @ts-expect-error will be initialized in createRuntime
    context = {
        model: new data_1.DataController(),
    };
    constructor(options) {
        super();
        this.options = Object.assign({}, Graph.defaultOptions, options);
        this.setOptions(this.options);
        this.context.graph = this;
        // Listening window.resize to autoResize.
        this.options.autoResize && window.addEventListener('resize', this.onResize);
    }
    /**
     * <zh/> 获取配置项
     *
     * <en/> Get options
     * @returns <zh/> 配置项 | <en/> options
     * @apiCategory option
     */
    getOptions() {
        return this.options;
    }
    /**
     * <zh/> 设置配置项
     *
     * <en/> Set options
     * @param options - <zh/> 配置项 | <en/> options
     * @remarks
     * <zh/> 要更新 devicePixelRatio、container 属性请销毁后重新创建实例
     *
     * <en/> To update devicePixelRatio and container properties, please destroy and recreate the instance
     * @apiCategory option
     */
    setOptions(options) {
        const { background, behaviors, combo, data, edge, height, layout, node, plugins, theme, transforms, width } = options;
        Object.assign(this.options, options);
        if (background)
            this.setBackground(background);
        if (behaviors)
            this.setBehaviors(behaviors);
        if (combo)
            this.setCombo(combo);
        if (data)
            this.setData(data);
        if (edge)
            this.setEdge(edge);
        if (layout)
            this.setLayout(layout);
        if (node)
            this.setNode(node);
        if (theme)
            this.setTheme(theme);
        if (plugins)
            this.setPlugins(plugins);
        if (transforms)
            this.setTransforms(transforms);
        if ((0, util_1.isNumber)(width) || (0, util_1.isNumber)(height))
            this.setSize(width ?? this.options.width ?? 0, height ?? this.options.height ?? 0);
    }
    /**
     * <zh/> 设置画布背景色
     *
     * <en/> Set canvas background color
     * @param background - <zh/> 背景色 | <en/> background color
     * @apiCategory canvas
     */
    setBackground(background) {
        this.options.background = background;
        this.context.canvas?.setBackground(background);
    }
    /**
     * <zh/> 获取画布背景色
     *
     * <en/> Get canvas background color
     * @returns <zh/> 背景色 | <en/> background color
     * @apiCategory canvas
     */
    getBackground() {
        return this.options.background;
    }
    /**
     * <zh/> 获取当前图容器的大小
     *
     * <en/> Get the size of the current canvas container
     * @returns <zh/> 画布尺寸 | <en/> canvas size
     * @apiCategory canvas
     */
    getSize() {
        if (this.context.canvas)
            return this.context.canvas.getSize();
        return [this.options.width || 0, this.options.height || 0];
    }
    /**
     * <zh/> 获取当前图容器的大小
     *
     * <en/> Get the size of the current canvas container
     * @param width - <zh/> 画布宽度 | <en/> canvas width
     * @param height - <zh/> 画布高度 | <en/> canvas height
     * @apiCategory canvas
     */
    setSize(width, height) {
        Object.assign(this.options, { width, height });
        this.context.canvas?.resize(width, height);
    }
    /**
     * <zh/> 获取当前图的缩放区间
     *
     * <en/> Get the zoom range of the current graph
     * @param zoomRange - <zh/> 缩放区间 | <en/> zoom range
     * @apiCategory viewport
     */
    setZoomRange(zoomRange) {
        this.options.zoomRange = zoomRange;
    }
    /**
     * <zh/> 获取当前图的缩放区间
     *
     * <en/> Get the zoom range of the current graph
     * @returns <zh/> 缩放区间 | <en/> zoom range
     * @apiCategory viewport
     */
    getZoomRange() {
        return this.options.zoomRange;
    }
    /**
     * <zh/> 设置节点样式映射
     *
     * <en/> Set node mapper
     * @param node - <zh/> 节点配置 | <en/> node configuration
     * @apiCategory element
     */
    setNode(node) {
        this.options.node = node;
        this.context.model.refreshData();
    }
    /**
     * <zh/> 设置边样式映射
     *
     * <en/> Set edge mapper
     * @param edge - <zh/> 边配置 | <en/> edge configuration
     * @apiCategory element
     */
    setEdge(edge) {
        this.options.edge = edge;
        this.context.model.refreshData();
    }
    /**
     * <zh/> 设置组合样式映射
     *
     * <en/> Set combo mapper
     * @param combo - <zh/> 组合配置 | <en/> combo configuration
     * @apiCategory element
     */
    setCombo(combo) {
        this.options.combo = combo;
        this.context.model.refreshData();
    }
    /**
     * <zh/> 获取主题
     *
     * <en/> Get theme
     * @returns <zh/> 主题配置 | <en/> theme configuration
     * @apiCategory theme
     */
    getTheme() {
        return this.options.theme;
    }
    /**
     * <zh/> 设置主题
     *
     * <en/> Set theme
     * @param theme - <zh/> 主题配置 | <en/> theme configuration
     * @apiCategory theme
     */
    setTheme(theme) {
        this.options.theme = (0, util_1.isFunction)(theme) ? theme(this.getTheme()) : theme;
        const { background } = (0, registry_1.getExtension)('theme', this.options.theme) || {};
        if (background && !this.options.background) {
            this.setBackground(background);
        }
    }
    /**
     * <zh/> 设置布局
     *
     * <en/> Set layout
     * @param layout - <zh/> 布局配置 | <en/> layout configuration
     * @apiCategory layout
     */
    setLayout(layout) {
        this.options.layout = (0, util_1.isFunction)(layout) ? layout(this.getLayout()) : layout;
    }
    /**
     * <zh/> 获取布局
     *
     * <en/> Get layout
     * @returns <zh/> 布局配置 | <en/> layout configuration
     * @apiCategory layout
     */
    getLayout() {
        return this.options.layout;
    }
    /**
     * <zh/> 设置交互
     *
     * <en/> Set behaviors
     * @param behaviors - <zh/> 交互配置 | <en/> behavior configuration
     * @apiCategory behavior
     */
    setBehaviors(behaviors) {
        this.options.behaviors = (0, util_1.isFunction)(behaviors) ? behaviors(this.getBehaviors()) : behaviors;
        this.context.behavior?.setBehaviors(this.options.behaviors);
    }
    /**
     * <zh/> 更新交互
     *
     * <en/> Update behavior
     * @param behavior - <zh/> 交互配置 | <en/> behavior configuration
     * @apiCategory behavior
     */
    updateBehavior(behavior) {
        this.setBehaviors((behaviors) => behaviors.map((_behavior) => {
            if ((0, util_1.isObject)(_behavior) && _behavior.key === behavior.key) {
                return { ..._behavior, ...behavior };
            }
            return _behavior;
        }));
    }
    /**
     * <zh/> 获取交互
     *
     * <en/> Get behaviors
     * @returns <zh/> 交互配置 | <en/> behavior configuration
     * @apiCategory behavior
     */
    getBehaviors() {
        return this.options.behaviors || [];
    }
    /**
     * <zh/> 设置插件
     *
     * <en/> Set plugins
     * @param plugins - <zh/> 插件配置 | <en/> plugin configuration
     * @apiCategory plugin
     */
    setPlugins(plugins) {
        this.options.plugins = (0, util_1.isFunction)(plugins) ? plugins(this.getPlugins()) : plugins;
        this.context.plugin?.setPlugins(this.options.plugins);
    }
    /**
     * <zh/> 更新插件
     *
     * <en/> Update plugin
     * @param plugin - <zh/> 插件配置 | <en/> plugin configuration
     * @apiCategory plugin
     */
    updatePlugin(plugin) {
        this.setPlugins((plugins) => plugins.map((_plugin) => {
            if ((0, util_1.isObject)(_plugin) && _plugin.key === plugin.key) {
                return { ..._plugin, ...plugin };
            }
            return _plugin;
        }));
    }
    /**
     * <zh/> 获取插件
     *
     * <en/> Get plugins
     * @returns <zh/> 插件配置 | <en/> plugin configuration
     * @apiCategory plugin
     */
    getPlugins() {
        return this.options.plugins || [];
    }
    /**
     * <zh/> 获取插件实例
     *
     * <en/> Get plugin instance
     * @param key - <zh/> 插件 key | <en/> plugin key
     * @returns <zh/> 插件实例 | <en/> plugin instance
     * @apiCategory plugin
     */
    getPluginInstance(key) {
        return this.context.plugin.getPluginInstance(key);
    }
    /**
     * <zh/> 设置数据转换器
     *
     * <en/> Set data transforms
     * @param transforms - <zh/> 数据转换配置 | <en/> data transform configuration
     * @apiCategory transform
     */
    setTransforms(transforms) {
        this.options.transforms = (0, util_1.isFunction)(transforms) ? transforms(this.getTransforms()) : transforms;
        this.context.transform?.setTransforms(this.options.transforms);
    }
    /**
     * <zh/> 更新数据转换器
     *
     * <en/> Update data transform
     * @param transform - <zh/> 数据转换配置 | <en/> data transform configuration
     * @apiCategory transform
     */
    updateTransform(transform) {
        this.setTransforms((transforms) => transforms.map((_transform) => {
            if ((0, util_1.isObject)(_transform) && _transform.key === transform.key) {
                return { ..._transform, ...transform };
            }
            return _transform;
        }));
        this.context.model.refreshData();
    }
    /**
     * <zh/> 获取数据转换器
     *
     * <en/> Get data transforms
     * @returns <zh/> 数据转换器实例 | <en/> data transform instance
     * @apiCategory transform
     */
    getTransforms() {
        return this.options.transforms || [];
    }
    /**
     * <zh/> 获取数据
     *
     * <en/> Get data
     * @returns <zh/> 数据 | <en/> data
     * @apiCategory data
     */
    getData() {
        return this.context.model.getData();
    }
    getElementData(ids) {
        if (Array.isArray(ids))
            return ids.map((id) => this.context.model.getElementDataById(id));
        return this.context.model.getElementDataById(ids);
    }
    getNodeData(id) {
        if (id === undefined)
            return this.context.model.getNodeData();
        if (Array.isArray(id))
            return this.context.model.getNodeData(id);
        return this.context.model.getNodeData([id])?.[0];
    }
    getEdgeData(id) {
        if (id === undefined)
            return this.context.model.getEdgeData();
        if (Array.isArray(id))
            return this.context.model.getEdgeData(id);
        return this.context.model.getEdgeData([id])?.[0];
    }
    getComboData(id) {
        if (id === undefined)
            return this.context.model.getComboData();
        if (Array.isArray(id))
            return this.context.model.getComboData(id);
        return this.context.model.getComboData([id])?.[0];
    }
    /**
     * <zh/> 设置全量数据
     *
     * <en/> Set full data
     * @param data - <zh/> 数据 | <en/> data
     * @apiCategory data
     */
    setData(data) {
        this.context.model.setData((0, util_1.isFunction)(data) ? data(this.getData()) : data);
    }
    /**
     * <zh/> 新增元素数据
     *
     * <en/> Add element data
     * @param data - <zh/> 元素数据 | <en/> element data
     * @apiCategory data
     */
    addData(data) {
        this.context.model.addData((0, util_1.isFunction)(data) ? data(this.getData()) : data);
    }
    /**
     * <zh/> 新增节点数据
     *
     * <en/> Add node data
     * @param data - <zh/> 节点数据 | <en/> node data
     * @apiCategory data
     */
    addNodeData(data) {
        this.context.model.addNodeData((0, util_1.isFunction)(data) ? data(this.getNodeData()) : data);
    }
    /**
     * <zh/> 新增边数据
     *
     * <en/> Add edge data
     * @param data - <zh/> 边数据 | <en/> edge data
     * @apiCategory data
     */
    addEdgeData(data) {
        this.context.model.addEdgeData((0, util_1.isFunction)(data) ? data(this.getEdgeData()) : data);
    }
    /**
     * <zh/> 新增组合数据
     *
     * <en/> Add combo data
     * @param data - <zh/> 组合数据 | <en/> combo data
     * @apiCategory data
     */
    addComboData(data) {
        this.context.model.addComboData((0, util_1.isFunction)(data) ? data(this.getComboData()) : data);
    }
    /**
     * <zh/> 更新元素数据
     *
     * <en/> Update element data
     * @param data - <zh/> 元素数据 | <en/> element data
     * @apiCategory data
     */
    updateData(data) {
        this.context.model.updateData((0, util_1.isFunction)(data) ? data(this.getData()) : data);
    }
    /**
     * <zh/> 更新节点数据
     *
     * <en/> Update node data
     * @param data - <zh/> 节点数据 | <en/> node data
     * @apiCategory data
     */
    updateNodeData(data) {
        this.context.model.updateNodeData((0, util_1.isFunction)(data) ? data(this.getNodeData()) : data);
    }
    /**
     * <zh/> 更新边数据
     *
     * <en/> Update edge data
     * @param data - <zh/> 边数据 | <en/> edge data
     * @apiCategory data
     */
    updateEdgeData(data) {
        this.context.model.updateEdgeData((0, util_1.isFunction)(data) ? data(this.getEdgeData()) : data);
    }
    /**
     * <zh/> 更新组合数据
     *
     * <en/> Update combo data
     * @param data - <zh/> 组合数据 | <en/> combo data
     * @apiCategory data
     */
    updateComboData(data) {
        this.context.model.updateComboData((0, util_1.isFunction)(data) ? data(this.getComboData()) : data);
    }
    /**
     * <zh/> 删除多条元素数据
     *
     * <en/> Remove multiple element data
     * @param ids - <zh/> 元素 ID 数组 | <en/> element ID array
     * @apiCategory data
     */
    removeData(ids) {
        this.context.model.removeData((0, util_1.isFunction)(ids) ? ids(this.getData()) : ids);
    }
    /**
     * <zh/> 删除多条节点数据
     *
     * <en/> Remove multiple node data
     * @param ids - <zh/> 节点 ID 数组 | <en/> node ID array
     * @apiCategory data
     */
    removeNodeData(ids) {
        this.context.model.removeNodeData((0, util_1.isFunction)(ids) ? ids(this.getNodeData()) : ids);
    }
    /**
     * <zh/> 删除多条边数据
     *
     * <en/> Remove multiple edge data
     * @param ids - <zh/> 边 ID 数组 | <en/> edge ID array
     * @apiCategory data
     */
    removeEdgeData(ids) {
        this.context.model.removeEdgeData((0, util_1.isFunction)(ids) ? ids(this.getEdgeData()) : ids);
    }
    /**
     * <zh/> 删除多条组合数据
     *
     * <en/> Remove multiple combo data
     * @param ids - <zh/> 组合 ID 数组 | <en/> 组合 ID array
     * @apiCategory data
     */
    removeComboData(ids) {
        this.context.model.removeComboData((0, util_1.isFunction)(ids) ? ids(this.getComboData()) : ids);
    }
    /**
     * <zh/> 获取元素类型
     *
     * <en/> Get element type
     * @param id - <zh/> 元素 ID | <en/> element ID
     * @returns <zh/> 元素类型 | <en/> element type
     * @apiCategory element
     */
    getElementType(id) {
        return this.context.model.getElementType(id);
    }
    /**
     * <zh/> 获取节点或组合关联边的数据
     *
     * <en/> Get edge data related to the node or combo
     * @param id - <zh/> 节点或组合ID | <en/> node or combo ID
     * @param direction - <zh/> 边的方向 | <en/> edge direction
     * @returns <zh/> 边数据 | <en/> edge data
     * @apiCategory data
     */
    getRelatedEdgesData(id, direction = 'both') {
        return this.context.model.getRelatedEdgesData(id, direction);
    }
    /**
     * <zh/> 获取节点或组合的一跳邻居节点数据
     *
     * <en/> Get the one-hop neighbor node data of the node or combo
     * @param id - <zh/> 节点或组合ID | <en/> node or combo ID
     * @returns <zh/> 邻居节点数据 | <en/> neighbor node data
     * @apiCategory data
     */
    getNeighborNodesData(id) {
        return this.context.model.getNeighborNodesData(id);
    }
    /**
     * <zh/> 获取节点或组合的祖先元素数据
     *
     * <en/> Get the ancestor element data of the node or combo
     * @param id - <zh/> 节点或组合ID | <en/> node or combo ID
     * @param hierarchy - <zh/> 指定树图层级关系还是组合层级关系 | <en/> specify tree or combo hierarchy relationship
     * @returns <zh/> 祖先元素数据 | <en/> ancestor element data
     * @remarks
     * <zh/> 数组中的顺序是从父节点到祖先节点
     *
     * <en/> The order in the array is from the parent node to the ancestor node
     * @apiCategory data
     */
    getAncestorsData(id, hierarchy) {
        return this.context.model.getAncestorsData(id, hierarchy);
    }
    /**
     * <zh/> 获取节点或组合的父元素数据
     *
     * <en/> Get the parent element data of the node or combo
     * @param id - <zh/> 节点或组合ID | <en/> node or combo ID
     * @param hierarchy - <zh/> 指定树图层级关系还是组合层级关系 | <en/> specify tree or combo hierarchy relationship
     * @returns <zh/> 父元素数据 | <en/> parent element data
     * @apiCategory data
     */
    getParentData(id, hierarchy) {
        return this.context.model.getParentData(id, hierarchy);
    }
    /**
     * <zh/> 获取节点或组合的子元素数据
     *
     * <en/> Get the child element data of the node or combo
     * @param id - <zh/> 节点或组合ID | <en/> node or combo ID
     * @returns <zh/> 子元素数据 | <en/> child element data
     * @apiCategory data
     */
    getChildrenData(id) {
        return this.context.model.getChildrenData(id);
    }
    getElementDataByState(elementType, state) {
        return this.context.model.getElementDataByState(elementType, state);
    }
    async initCanvas() {
        if (this.context.canvas)
            return await this.context.canvas.init();
        const { container = 'container', width, height, renderer, background } = this.options;
        if (container instanceof canvas_1.Canvas) {
            this.context.canvas = container;
            container.setBackground(background);
            await container.init();
        }
        else {
            const $container = (0, util_1.isString)(container) ? document.getElementById(container) : container;
            const containerSize = (0, dom_1.sizeOf)($container);
            this.emit(constants_1.GraphEvent.BEFORE_CANVAS_INIT, { container: $container, width, height });
            const canvas = new canvas_1.Canvas({
                container: $container,
                width: width || containerSize[0],
                height: height || containerSize[1],
                background,
                renderer,
            });
            this.context.canvas = canvas;
            await canvas.init();
            this.emit(constants_1.GraphEvent.AFTER_CANVAS_INIT, { canvas });
        }
    }
    initRuntime() {
        this.context.options = this.options;
        if (!this.context.batch)
            this.context.batch = new batch_1.BatchController(this.context);
        if (!this.context.plugin)
            this.context.plugin = new plugin_1.PluginController(this.context);
        if (!this.context.viewport)
            this.context.viewport = new viewport_1.ViewportController(this.context);
        if (!this.context.transform)
            this.context.transform = new transform_1.TransformController(this.context);
        if (!this.context.element)
            this.context.element = new element_1.ElementController(this.context);
        if (!this.context.animation)
            this.context.animation = new animation_1.Animation(this.context);
        if (!this.context.layout)
            this.context.layout = new layout_1.LayoutController(this.context);
        if (!this.context.behavior)
            this.context.behavior = new behavior_1.BehaviorController(this.context);
    }
    async prepare() {
        // 等待同步任务执行完成，避免 render 后立即调用 destroy 导致的问题
        // Wait for synchronous tasks to complete, to avoid problems caused by calling destroy immediately after render
        await Promise.resolve();
        if (this.destroyed)
            throw new Error('Graph has been destroyed');
        await this.initCanvas();
        this.initRuntime();
    }
    /**
     * <zh/> 执行渲染
     *
     * <en/> Render
     * @remarks
     * <zh/> 此过程会执行数据更新、绘制元素、执行布局
     *
     * <en/> This process will execute data update, element rendering, and layout execution
     * @apiCategory render
     */
    async render() {
        await this.prepare();
        (0, event_1.emit)(this, new event_1.GraphLifeCycleEvent(constants_1.GraphEvent.BEFORE_RENDER));
        const animation = this.context.element.draw();
        await Promise.all([animation?.finished, this.context.layout.layout()]);
        await this.autoFit();
        (0, event_1.emit)(this, new event_1.GraphLifeCycleEvent(constants_1.GraphEvent.AFTER_RENDER));
    }
    /**
     * <zh/> 绘制元素
     *
     * <en/> Draw elements
     * @returns <zh/> 渲染结果 | <en/> draw result
     * @apiCategory element
     */
    async draw() {
        await this.prepare();
        await this.context.element.draw()?.finished;
        await this.autoFit();
    }
    /**
     * <zh/> 执行布局
     *
     * <en/> Execute layout
     * @apiCategory layout
     */
    async layout() {
        await this.context.layout.layout();
    }
    /**
     * <zh/> 停止布局
     *
     * <en/> Stop layout
     * @remarks
     * <zh/> 适用于带有迭代动画的布局，目前有 `force` 属于此类布局，即停止力导布局的迭代，一般用于布局迭代时间过长情况下的手动停止迭代动画，例如在点击画布/节点的监听中调用
     *
     * <en/> Suitable for layouts with iterative animations. Currently, `force` belongs to this type of layout, that is, stop the iteration of the force-directed layout. It is generally used to manually stop the iteration animation when the layout iteration time is too long, such as calling in the click canvas/node listener
     * @apiCategory layout
     */
    stopLayout() {
        this.context.layout.stopLayout();
    }
    /**
     * <zh/> 清空画布元素
     *
     * <en/> Clear canvas elements
     * @apiCategory canvas
     */
    async clear() {
        this.context.model.setData({});
        await this.draw();
    }
    /**
     * <zh/> 销毁当前图实例
     *
     * <en/> Destroy the current graph instance
     * @apiCategory instance
     */
    destroy() {
        (0, event_1.emit)(this, new event_1.GraphLifeCycleEvent(constants_1.GraphEvent.BEFORE_DESTROY));
        const { layout, animation, element, model, canvas, behavior, plugin } = this.context;
        plugin?.destroy();
        behavior?.destroy();
        layout?.destroy();
        animation?.destroy();
        element?.destroy();
        model.destroy();
        canvas?.destroy();
        this.options = {};
        // @ts-expect-error force delete
        this.context = {};
        this.off();
        window.removeEventListener('resize', this.onResize);
        this.destroyed = true;
        (0, event_1.emit)(this, new event_1.GraphLifeCycleEvent(constants_1.GraphEvent.AFTER_DESTROY));
    }
    /**
     * <zh/> 获取画布实例
     *
     * <en/> Get canvas instance
     * @returns - <zh/> 画布实例 | <en/> canvas instance
     * @apiCategory canvas
     */
    getCanvas() {
        return this.context.canvas;
    }
    resize(width, height) {
        const size = !width || !height ? (0, dom_1.sizeOf)(this.context.canvas.getContainer()) : [width, height];
        if ((0, util_1.isEqual)(size, this.getSize()))
            return;
        (0, event_1.emit)(this, new event_1.GraphLifeCycleEvent(constants_1.GraphEvent.BEFORE_SIZE_CHANGE, { size }));
        this.context.canvas.resize(...size);
        (0, event_1.emit)(this, new event_1.GraphLifeCycleEvent(constants_1.GraphEvent.AFTER_SIZE_CHANGE, { size }));
    }
    /**
     * <zh/> 将图缩放至合适大小并平移至视口中心
     *
     * <en/> Zoom the graph to fit the viewport and move it to the center of the viewport
     * @param options - <zh/> 适配配置 | <en/> fit options
     * @param animation - <zh/> 动画配置 | <en/> animation configuration
     * @apiCategory viewport
     */
    async fitView(options, animation) {
        await this.context.viewport?.fitView(options, animation);
    }
    /**
     * <zh/> 将图平移至视口中心
     *
     * <en/> Move the graph to the center of the viewport
     * @param animation - <zh/> 动画配置 | <en/> animation configuration
     * @apiCategory viewport
     */
    async fitCenter(animation) {
        await this.context.viewport?.fitCenter(animation);
    }
    async autoFit() {
        const { autoFit } = this.context.options;
        if (!autoFit)
            return;
        if ((0, util_1.isString)(autoFit)) {
            if (autoFit === 'view')
                await this.fitView();
            else if (autoFit === 'center')
                await this.fitCenter();
        }
        else {
            const { type, animation } = autoFit;
            if (type === 'view')
                await this.fitView(autoFit.options, animation);
            else if (type === 'center')
                await this.fitCenter(animation);
        }
    }
    /**
     * <zh/> 移动图，使得元素对齐到视口中心
     *
     * <en/> Move the graph so that the element is aligned to the center of the viewport
     * @param id - <zh/> 元素 ID | <en/> element ID
     * @param animation - <zh/> 动画配置 | <en/> animation configuration
     * @apiCategory viewport
     */
    async focusElement(id, animation) {
        await this.context.viewport?.focusElements(Array.isArray(id) ? id : [id], animation);
    }
    /**
     * <zh/> 基于当前缩放比例进行缩放
     *
     * <en/> Zoom based on the current zoom ratio
     * @param ratio - <zh/> 缩放比例 | <en/> zoom ratio
     * @param animation - <zh/> 动画配置 | <en/> animation configuration
     * @param origin - <zh/> 缩放中心(视口坐标) | <en/> zoom center(viewport coordinates)
     * @remarks
     * <zh/>
     * - ratio > 1 放大
     * - ratio < 1 缩小
     *
     * <en/>
     * - ratio > 1 zoom in
     * - ratio < 1 zoom out
     * @apiCategory viewport
     */
    async zoomBy(ratio, animation, origin) {
        await this.context.viewport.transform({ mode: 'relative', scale: ratio, origin }, animation);
    }
    /**
     * <zh/> 缩放画布至指定比例
     *
     * <en/> Zoom the canvas to the specified ratio
     * @param zoom - <zh/> 指定缩放比例 | <en/> specified zoom ratio
     * @param animation - <zh/> 动画配置 | <en/> animation configuration
     * @param origin - <zh/> 缩放中心(视口坐标) | <en/> zoom center(viewport coordinates)
     * @remarks
     * <zh/>
     * - zoom = 1 默认大小
     * - zoom > 1 放大
     * - zoom < 1 缩小
     *
     * <en/>
     * - zoom = 1 default size
     * - zoom > 1 zoom in
     * - zoom < 1 zoom out
     * @apiCategory viewport
     */
    async zoomTo(zoom, animation, origin) {
        this.context.viewport.transform({ mode: 'absolute', scale: zoom, origin }, animation);
    }
    /**
     * <zh/> 获取当前缩放比例
     *
     * <en/> Get the current zoom ratio
     * @returns <zh/> 缩放比例 | <en/> zoom ratio
     * @apiCategory viewport
     */
    getZoom() {
        return this.context.viewport.getZoom();
    }
    /**
     * <zh/> 基于当前旋转角度进行旋转
     *
     * <en/> Rotate based on the current rotation angle
     * @param angle - <zh/> 旋转角度 | <en/> rotation angle
     * @param animation - <zh/> 动画配置 | <en/> animation configuration
     * @param origin - <zh/> 旋转中心(视口坐标) | <en/> rotation center(viewport coordinates)
     * @apiCategory viewport
     */
    async rotateBy(angle, animation, origin) {
        await this.context.viewport.transform({ mode: 'relative', rotate: angle, origin }, animation);
    }
    /**
     * <zh/> 旋转画布至指定角度
     *
     * <en/> Rotate the canvas to the specified angle
     * @param angle - <zh/> 目标角度 | <en/> target angle
     * @param animation - <zh/> 动画配置 | <en/> animation configuration
     * @param origin - <zh/> 旋转中心(视口坐标) | <en/> rotation center(viewport coordinates)
     * @apiCategory viewport
     */
    async rotateTo(angle, animation, origin) {
        await this.context.viewport.transform({ mode: 'absolute', rotate: angle, origin }, animation);
    }
    /**
     * <zh/> 获取当前旋转角度
     *
     * <en/> Get the current rotation angle
     * @returns <zh/> 旋转角度 | <en/> rotation angle
     * @apiCategory viewport
     */
    getRotation() {
        return this.context.viewport.getRotation();
    }
    /**
     * <zh/> 将图平移指定距离
     *
     * <en/> Translate the graph by the specified distance
     * @param offset - <zh/> 偏移量 | <en/> offset
     * @param animation - <zh/> 动画配置 | <en/> animation configuration
     * @apiCategory viewport
     */
    async translateBy(offset, animation) {
        await this.context.viewport.transform({ mode: 'relative', translate: offset }, animation);
    }
    /**
     * <zh/> 将图平移至指定位置
     *
     * <en/> Translate the graph to the specified position
     * @param position - <zh/> 指定位置 | <en/> specified position
     * @param animation - <zh/> 动画配置 | <en/> animation configuration
     * @apiCategory viewport
     */
    async translateTo(position, animation) {
        await this.context.viewport.transform({ mode: 'absolute', translate: position }, animation);
    }
    /**
     * <zh/> 获取图的位置
     *
     * <en/> Get the position of the graph
     * @returns <zh/> 图的位置 | <en/> position of the graph
     * @remarks
     * <zh/> 默认状态下，图的位置为 [0, 0]
     *
     * <en/> By default, the position of the graph is [0, 0]
     * @apiCategory viewport
     */
    getPosition() {
        return (0, vector_1.subtract)([0, 0], this.getCanvasByViewport([0, 0]));
    }
    async translateElementBy(args1, args2, args3 = true) {
        const [config, animation] = (0, util_1.isObject)(args1)
            ? [args1, args2 ?? true]
            : [{ [args1]: args2 }, args3];
        Object.entries(config).forEach(([id, offset]) => this.context.model.translateNodeBy(id, offset));
        await this.context.element.draw({ animation })?.finished;
    }
    async translateElementTo(args1, args2, args3 = true) {
        const [config, animation] = (0, util_1.isObject)(args1)
            ? [args1, args2 ?? true]
            : [{ [args1]: args2 }, args3];
        Object.entries(config).forEach(([id, position]) => this.context.model.translateNodeTo(id, position));
        await this.context.element.draw({ animation })?.finished;
    }
    /**
     * <zh/> 获取元素位置
     *
     * <en/> Get element position
     * @param id - <zh/> 元素 ID | <en/> element ID
     * @returns <zh/> 元素位置 | <en/> element position
     * @apiCategory element
     */
    getElementPosition(id) {
        return this.context.model.getElementPosition(id);
    }
    /**
     * <zh/> 获取元素渲染样式
     *
     * <en/> Get element rendering style
     * @param id - <zh/> 元素 ID | <en/> element ID
     * @returns <zh/> 元素渲染样式 | <en/> element rendering style
     * @apiCategory element
     */
    getElementRenderStyle(id) {
        return (0, util_1.omit)(this.context.element.getElement(id).attributes, ['context']);
    }
    async setElementVisibility(args1, args2, args3 = true) {
        const [config, animation] = (0, util_1.isObject)(args1)
            ? [args1, args2 ?? true]
            : [{ [args1]: args2 }, args3];
        const dataToUpdate = { nodes: [], edges: [], combos: [] };
        Object.entries(config).forEach(([id, value]) => {
            const elementType = this.getElementType(id);
            dataToUpdate[`${elementType}s`].push({ id, style: { visibility: value } });
        });
        const { model, element } = this.context;
        model.preventUpdateNodeLikeHierarchy(() => {
            model.updateData(dataToUpdate);
        });
        await element.draw({ animation, stage: 'visibility' })?.finished;
    }
    /**
     * <zh/> 显示元素
     *
     * <en/> Show element
     * @param id - <zh/> 元素 ID | <en/> element ID
     * @param animation - <zh/> 是否启用动画 | <en/> whether to enable animation
     * @apiCategory element
     */
    async showElement(id, animation) {
        const ids = Array.isArray(id) ? id : [id];
        await this.setElementVisibility(Object.fromEntries(ids.map((_id) => [_id, 'visible'])), animation);
    }
    /**
     * <zh/> 隐藏元素
     *
     * <en/> Hide element
     * @param id - <zh/> 元素 ID | <en/> element ID
     * @param animation - <zh/> 是否启用动画 | <en/> whether to enable animation
     * @apiCategory element
     */
    async hideElement(id, animation) {
        const ids = Array.isArray(id) ? id : [id];
        await this.setElementVisibility(Object.fromEntries(ids.map((_id) => [_id, 'hidden'])), animation);
    }
    /**
     * <zh/> 获取元素可见性
     *
     * <en/> Get element visibility
     * @param id - <zh/> 元素 ID | <en/> element ID
     * @returns <zh/> 元素可见性 | <en/> element visibility
     * @apiCategory element
     */
    getElementVisibility(id) {
        const element = this.context.element.getElement(id);
        return element?.style?.visibility ?? 'visible';
    }
    async setElementZIndex(args1, args2) {
        const dataToUpdate = { nodes: [], edges: [], combos: [] };
        const config = (0, util_1.isObject)(args1) ? args1 : { [args1]: args2 };
        Object.entries(config).forEach(([id, value]) => {
            const elementType = this.getElementType(id);
            dataToUpdate[`${elementType}s`].push({ id, style: { zIndex: value } });
        });
        const { model, element } = this.context;
        model.preventUpdateNodeLikeHierarchy(() => model.updateData(dataToUpdate));
        await element.draw({ animation: false })?.finished;
    }
    /**
     * <zh/> 将元素置于最顶层
     *
     * <en/> Bring the element to the front
     * @param id - <zh/> 元素 ID | <en/> element ID
     * @apiCategory element
     */
    async frontElement(id) {
        const ids = Array.isArray(id) ? id : [id];
        const { model } = this.context;
        const config = {};
        ids.map((_id) => {
            const zIndex = model.getFrontZIndex(_id);
            const elementType = model.getElementType(_id);
            if (elementType === 'combo') {
                const ancestor = model.getAncestorsData(_id, constants_1.COMBO_KEY).at(-1) || this.getComboData(_id);
                const combos = [ancestor, ...model.getDescendantsData((0, id_1.idOf)(ancestor))].filter((datum) => model.isCombo((0, id_1.idOf)(datum)));
                const delta = zIndex - (0, style_1.zIndexOf)(ancestor);
                combos.forEach((combo) => {
                    config[(0, id_1.idOf)(combo)] = (0, style_1.zIndexOf)(combo) + delta;
                });
            }
            else
                config[_id] = zIndex;
        });
        await this.setElementZIndex(config);
    }
    /**
     * <zh/> 获取元素层级
     *
     * <en/> Get element z-index
     * @param id - <zh/> 元素 ID | <en/> element ID
     * @returns <zh/> 元素层级 | <en/> element z-index
     * @apiCategory element
     */
    getElementZIndex(id) {
        return (0, style_1.zIndexOf)(this.context.model.getElementDataById(id));
    }
    async setElementState(args1, args2, args3 = true) {
        const [config, animation] = (0, util_1.isObject)(args1)
            ? [args1, args2 ?? true]
            : [{ [args1]: args2 }, args3];
        const parseState = (state) => {
            if (!state)
                return [];
            return Array.isArray(state) ? state : [state];
        };
        const dataToUpdate = { nodes: [], edges: [], combos: [] };
        Object.entries(config).forEach(([id, value]) => {
            const elementType = this.getElementType(id);
            dataToUpdate[`${elementType}s`].push({ id, states: parseState(value) });
        });
        this.updateData(dataToUpdate);
        await this.context.element.draw({ animation })?.finished;
    }
    /**
     * <zh/> 获取元素状态
     *
     * <en/> Get element state
     * @param id - <zh/> 元素 ID | <en/> element ID
     * @returns <zh/> 元素状态 | <en/> element state
     * @apiCategory element
     */
    getElementState(id) {
        return this.context.model.getElementState(id);
    }
    /**
     * <zh/> 获取元素自身以及子节点在世界坐标系下的渲染包围盒
     *
     * <en/> Get the rendering bounding box of the element itself and its child nodes in the world coordinate system
     * @param id - <zh/> 元素 ID | <en/> element ID
     * @returns <zh/> 渲染包围盒 | <en/> render bounding box
     * @apiCategory element
     */
    getElementRenderBounds(id) {
        return this.context.element.getElement(id).getRenderBounds();
    }
    isCollapsingExpanding = false;
    /**
     * <zh/> 收起 Combo
     *
     * <en/> Collapse Combo
     * @param id - <zh/> 元素 ID | <en/> element ID
     * @param animation - <zh/> 是否启用动画 | <en/> whether to enable animation
     * @apiCategory element
     */
    async collapseElement(id, animation = true) {
        const { model, element } = this.context;
        if ((0, collapsibility_1.isCollapsed)(model.getNodeLikeData([id])[0]))
            return;
        if (this.isCollapsingExpanding)
            return;
        const elementType = model.getElementType(id);
        this.isCollapsingExpanding = true;
        this.setElementCollapsibility(id, true);
        if (elementType === 'node')
            await element.collapseNode(id, animation);
        else if (elementType === 'combo')
            await element.collapseCombo(id, animation);
        this.isCollapsingExpanding = false;
    }
    /**
     * <zh/> 展开 Combo
     *
     * <en/> Expand Combo
     * @param id - <zh/> 元素 ID | <en/> element ID
     * @param animation - <zh/> 是否启用动画 | <en/> whether to enable animation
     * @apiCategory element
     */
    async expandElement(id, animation = true) {
        const { model, element } = this.context;
        if (!(0, collapsibility_1.isCollapsed)(model.getNodeLikeData([id])[0]))
            return;
        if (this.isCollapsingExpanding)
            return;
        const elementType = model.getElementType(id);
        this.isCollapsingExpanding = true;
        this.setElementCollapsibility(id, false);
        if (elementType === 'node')
            await element.expandNode(id, animation);
        else if (elementType === 'combo')
            await element.expandCombo(id, animation);
        this.isCollapsingExpanding = false;
    }
    setElementCollapsibility(id, collapsed) {
        const elementType = this.getElementType(id);
        if (elementType === 'node')
            this.updateNodeData([{ id, style: { collapsed } }]);
        else if (elementType === 'combo')
            this.updateComboData([{ id, style: { collapsed } }]);
    }
    /**
     * <zh/> 导出画布内容为 DataURL
     *
     * <en/> Export canvas content as DataURL
     * @param options - <zh/> 导出配置 | <en/> export configuration
     * @returns <zh/> DataURL | <en/> DataURL
     * @apiCategory exportImage
     */
    async toDataURL(options = {}) {
        return this.context.canvas.toDataURL(options);
    }
    /**
     * <zh/> 给定的视窗 DOM 坐标，转换为画布上的绘制坐标
     *
     * <en/> Convert the given viewport DOM coordinates to the drawing coordinates on the canvas
     * @param point - <zh/> 视窗坐标 | <en/> viewport coordinates
     * @returns <zh/> 画布上的绘制坐标 | <en/> drawing coordinates on the canvas
     * @apiCategory viewport
     */
    getCanvasByViewport(point) {
        return (0, point_1.parsePoint)(this.context.canvas.viewport2Canvas((0, point_1.toPointObject)(point)));
    }
    /**
     * <zh/> 给定画布上的绘制坐标，转换为视窗 DOM 的坐标
     *
     * <en/> Convert the given drawing coordinates on the canvas to the coordinates of the viewport DOM
     * @param point - <zh/> 画布坐标 | <en/> canvas coordinates
     * @returns <zh/> 视窗 DOM 的坐标 | <en/> coordinates of the viewport DOM
     * @apiCategory viewport
     */
    getViewportByCanvas(point) {
        return (0, point_1.parsePoint)(this.context.canvas.canvas2Viewport((0, point_1.toPointObject)(point)));
    }
    /**
     * <zh/> 给定画布上的绘制坐标，转换为浏览器坐标
     *
     * <en/> Convert the given drawing coordinates on the canvas to browser coordinates
     * @param point - <zh/> 画布坐标 | <en/> canvas coordinates
     * @returns <zh/> 浏览器坐标 | <en/> browser coordinates
     * @apiCategory viewport
     */
    getClientByCanvas(point) {
        const viewportPoint = this.context.canvas.canvas2Viewport((0, point_1.toPointObject)(point));
        return (0, point_1.parsePoint)(this.context.canvas.viewport2Canvas(viewportPoint));
    }
    /**
     * <zh/> 给定的浏览器坐标，转换为画布上的绘制坐标
     *
     * <en/> Convert the given browser coordinates to drawing coordinates on the canvas
     * @param point - <zh/> 浏览器坐标 | <en/> browser coordinates
     * @returns <zh/> 画布上的绘制坐标 | <en/> drawing coordinates on the canvas
     * @apiCategory viewport
     */
    getCanvasByClient(point) {
        const viewportPoint = this.context.canvas.client2Viewport((0, point_1.toPointObject)(point));
        return (0, point_1.parsePoint)(this.context.canvas.viewport2Canvas(viewportPoint));
    }
    /**
     * <zh/> 获取视口中心的画布坐标
     *
     * <en/> Get the canvas coordinates of the viewport center
     * @returns <zh/> 视口中心的画布坐标 | <en/> Canvas coordinates of the viewport center
     * @apiCategory viewport
     */
    getViewportCenter() {
        return this.context.viewport.getViewportCenter();
    }
    /**
     * <zh/> 获取画布中心的画布坐标
     *
     * <en/> Get the canvas coordinates of the canvas center
     * @returns <zh/> 画布中心的画布坐标 | <en/> Canvas coordinates of the canvas center
     * @apiCategory viewport
     */
    getCanvasCenter() {
        return this.context.viewport.getCanvasCenter();
    }
    onResize = (0, util_1.debounce)(() => {
        this.resize();
    }, 300);
    /**
     * <zh/> 监听事件
     *
     * <en/> Listen to events
     * @param eventName - <zh/> 事件名称 | <en/> event name
     * @param callback - <zh/> 回调函数 | <en/> callback function
     * @returns <zh/> Graph 实例 | <en/> Graph instance
     * @apiCategory event
     */
    on(eventName, callback) {
        return super.on(eventName, callback);
    }
    /**
     * <zh/> 一次性监听事件
     *
     * <en/> Listen to events once
     * @param eventName - <zh/> 事件名称 | <en/> event name
     * @param callback - <zh/> 回调函数 | <en/> callback function
     * @returns <zh/> Graph 实例 | <en/> Graph instance
     * @apiCategory event
     */
    once(eventName, callback) {
        return super.once(eventName, callback);
    }
}
exports.Graph = Graph;
//# sourceMappingURL=graph.js.map
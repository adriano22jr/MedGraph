"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ViewportController = void 0;
const g_1 = require("@antv/g");
const util_1 = require("@antv/util");
const constants_1 = require("../constants");
const animation_1 = require("../utils/animation");
const bbox_1 = require("../utils/bbox");
const event_1 = require("../utils/event");
const padding_1 = require("../utils/padding");
const vector_1 = require("../utils/vector");
class ViewportController {
    context;
    get padding() {
        return (0, padding_1.parsePadding)(this.context.options.padding);
    }
    get paddingOffset() {
        const [top, right, bottom, left] = this.padding;
        const [offsetX, offsetY, offsetZ] = [(left - right) / 2, (top - bottom) / 2, 0];
        return [offsetX, offsetY, offsetZ];
    }
    constructor(context) {
        this.context = context;
        const [px, py] = this.paddingOffset;
        const { zoom, rotation, x = px, y = py } = context.options;
        this.transform({ mode: 'absolute', scale: zoom, translate: [x, y], rotate: rotation }, false);
    }
    get camera() {
        return this.context.canvas.getCamera();
    }
    landmarkCounter = 0;
    createLandmark(options) {
        return this.camera.createLandmark(`landmark-${this.landmarkCounter++}`, options);
    }
    getAnimation(animation) {
        const finalAnimation = (0, animation_1.getAnimationOptions)(this.context.options, animation);
        if (!finalAnimation)
            return false;
        return (0, util_1.pick)({ ...finalAnimation }, ['easing', 'duration']);
    }
    getCanvasSize() {
        const { canvas } = this.context;
        const { width = 0, height = 0 } = canvas.getConfig();
        return [width, height];
    }
    /**
     * <zh/> 获取画布中心坐标
     *
     * <en/> Get the center coordinates of the canvas
     * @returns - <zh/> 画布中心坐标 | <en/> Center coordinates of the canvas
     * @remarks
     * <zh/> 基于画布的宽高计算中心坐标，不受视口变换影响
     *
     * <en/> Calculate the center coordinates based on the width and height of the canvas, not affected by the viewport transformation
     */
    getCanvasCenter() {
        const { canvas } = this.context;
        const { width = 0, height = 0 } = canvas.getConfig();
        return [width / 2, height / 2, 0];
    }
    /**
     * <zh/> 当前视口中心坐标
     *
     * <en/> Current viewport center coordinates
     * @returns - <zh/> 视口中心坐标 | <en/> Viewport center coordinates
     * @remarks
     * <zh/> 以画布原点为原点，受到视口变换影响
     *
     * <en/> With the origin of the canvas as the origin, affected by the viewport transformation
     */
    getViewportCenter() {
        // 理论上应该通过 camera.getFocalPoint() 获取
        // 但在 2D 场景下，通过 pan 操作时，focalPoint 不会变化
        const [x, y] = this.camera.getPosition();
        return [x, y, 0];
    }
    getGraphCenter() {
        return this.context.graph.getViewportByCanvas(this.getCanvasCenter());
    }
    getZoom() {
        return this.camera.getZoom();
    }
    getRotation() {
        return this.camera.getRoll();
    }
    getTranslateArgs(options) {
        const currentZoom = this.getZoom();
        const { camera } = this;
        const { mode, translate = [] } = options;
        const [x = 0, y = 0] = translate;
        const [cx = 0, cy = 0] = this.getCanvasCenter();
        const [px, py] = camera.getPosition();
        const delta = (0, vector_1.divide)([-x, -y], currentZoom);
        const value = mode === 'relative' ? delta : (0, vector_1.add)([cx - px, cy - py], delta);
        return value;
    }
    getAnimationTranslateArgs(options) {
        const { camera } = this;
        const { mode, translate = [] } = options;
        const currentZoom = this.getZoom();
        const position = camera.getPosition();
        const focalPoint = camera.getFocalPoint();
        const canvasCenter = this.getCanvasCenter();
        const [x = 0, y = 0, z = 0] = translate;
        const delta = (0, vector_1.divide)([-x, -y, -z], currentZoom);
        return mode === 'relative'
            ? {
                position: (0, vector_1.add)(position, delta),
                focalPoint: (0, vector_1.add)(focalPoint, delta),
            }
            : {
                position: (0, vector_1.add)(canvasCenter, delta),
                focalPoint: (0, vector_1.add)(focalPoint, delta),
            };
    }
    getRotateArgs(options) {
        const { mode, rotate = 0 } = options;
        return mode === 'relative' ? rotate : rotate - this.camera.getRoll();
    }
    getAnimationRotateArgs(options) {
        const { mode, rotate = 0 } = options;
        const roll = mode === 'relative' ? this.camera.getRoll() + rotate : rotate;
        return { roll };
    }
    getZoomArgs(options) {
        const { zoomRange } = this.context.options;
        const currentZoom = this.camera.getZoom();
        const { mode, scale = 1 } = options;
        return (0, util_1.clamp)(mode === 'relative' ? currentZoom * scale : scale, ...zoomRange);
    }
    async transform(options, animation) {
        const { camera } = this;
        const { graph } = this.context;
        const { translate, rotate, scale, origin = this.getGraphCenter() } = options;
        this.cancelAnimation();
        (0, event_1.emit)(graph, new event_1.ViewportEvent(constants_1.GraphEvent.BEFORE_TRANSFORM, options));
        const _animation = this.getAnimation(animation);
        if (_animation) {
            const landmarkOptions = {};
            if (translate)
                Object.assign(landmarkOptions, this.getAnimationTranslateArgs(options));
            if ((0, util_1.isNumber)(rotate))
                Object.assign(landmarkOptions, this.getAnimationRotateArgs(options));
            if ((0, util_1.isNumber)(scale))
                Object.assign(landmarkOptions, { zoom: this.getZoomArgs(options) });
            (0, event_1.emit)(graph, new event_1.AnimateEvent(constants_1.GraphEvent.BEFORE_ANIMATE, constants_1.AnimationType.TRANSFORM, null, options));
            return new Promise((resolve) => {
                this.camera.gotoLandmark(this.createLandmark(landmarkOptions), {
                    ..._animation,
                    onfinish: () => {
                        (0, event_1.emit)(graph, new event_1.AnimateEvent(constants_1.GraphEvent.AFTER_ANIMATE, constants_1.AnimationType.TRANSFORM, null, options));
                        (0, event_1.emit)(graph, new event_1.ViewportEvent(constants_1.GraphEvent.AFTER_TRANSFORM, options));
                        resolve();
                    },
                });
            });
        }
        else {
            if (translate)
                camera.pan(...this.getTranslateArgs(options));
            if ((0, util_1.isNumber)(rotate)) {
                const [x, y] = camera.getFocalPoint();
                if (origin)
                    camera.pan(origin[0] - x, origin[1] - y);
                const value = this.getRotateArgs(options);
                camera.rotate(0, 0, value);
                if (origin)
                    camera.pan(x - origin[0], y - origin[1]);
            }
            if ((0, util_1.isNumber)(scale)) {
                const targetZoom = this.getZoomArgs(options);
                camera.setZoomByViewportPoint(targetZoom, origin);
            }
            (0, event_1.emit)(graph, new event_1.ViewportEvent(constants_1.GraphEvent.AFTER_TRANSFORM, options));
        }
    }
    async fitView(options, animation) {
        const [top, right, bottom, left] = this.padding;
        const { when = 'always', direction = 'both' } = options || {};
        const [width, height] = this.context.canvas.getSize();
        const innerWidth = width - left - right;
        const innerHeight = height - top - bottom;
        const canvasBounds = this.context.canvas.getBounds();
        const bboxInViewPort = this.getBBoxInViewport(canvasBounds);
        const [contentWidth, contentHeight] = (0, bbox_1.getBBoxSize)(bboxInViewPort);
        const isOverflow = (direction === 'x' && contentWidth >= innerWidth) ||
            (direction === 'y' && contentHeight >= innerHeight) ||
            (direction === 'both' && contentWidth >= innerWidth && contentHeight >= innerHeight);
        if (when === 'overflow' && !isOverflow)
            return await this.fitCenter(animation);
        const scaleX = innerWidth / contentWidth;
        const scaleY = innerHeight / contentHeight;
        const scale = direction === 'x' ? scaleX : direction === 'y' ? scaleY : Math.min(scaleX, scaleY);
        const _animation = this.getAnimation(animation);
        await this.transform({
            mode: 'relative',
            scale,
            translate: (0, vector_1.add)((0, vector_1.subtract)(this.getCanvasCenter(), this.getBBoxInViewport(canvasBounds).center), 
            // 启用动画时， zoom 和 translate 是同时进行的，因此需要除以缩放比例
            // When animation is enabled, zoom and translate are performed simultaneously, so they need to be divided by the scaling ratio
            _animation ? (0, vector_1.divide)(this.paddingOffset, scale) : this.paddingOffset),
        }, _animation);
    }
    async fitCenter(animation) {
        const canvasBounds = this.context.canvas.getBounds();
        await this.focus(canvasBounds, animation);
    }
    async focusElements(ids, animation) {
        const { element } = this.context;
        if (!element)
            return;
        const elementsBounds = (0, bbox_1.getCombinedBBox)(ids.map((id) => element.getElement(id).getRenderBounds()));
        await this.focus(elementsBounds, animation);
    }
    async focus(bbox, animation) {
        const { center } = this.getBBoxInViewport(bbox);
        const canvasCenter = this.getCanvasCenter();
        const delta = (0, vector_1.subtract)(canvasCenter, center);
        await this.transform({ mode: 'relative', translate: (0, vector_1.add)(delta, this.paddingOffset) }, animation);
    }
    /**
     * <zh/> 获取画布元素在视口中的包围盒
     *
     * <en/> Get the bounding box of the canvas element in the viewport
     * @param bbox - <zh/> 画布元素包围盒 | <en/> Canvas element bounding box
     * @returns - <zh/> 视口中的包围盒 | <en/> Bounding box in the viewport
     */
    getBBoxInViewport(bbox) {
        const { min, max } = bbox;
        const { graph } = this.context;
        const [x1, y1] = graph.getViewportByCanvas(min);
        const [x2, y2] = graph.getViewportByCanvas(max);
        const bboxInViewport = new g_1.AABB();
        bboxInViewport.setMinMax([x1, y1, 0], [x2, y2, 0]);
        return bboxInViewport;
    }
    cancelAnimation() {
        // @ts-expect-error landmarks is private
        if (this.camera.landmarks?.length) {
            this.camera.cancelLandmarkAnimation();
        }
    }
}
exports.ViewportController = ViewportController;
//# sourceMappingURL=viewport.js.map
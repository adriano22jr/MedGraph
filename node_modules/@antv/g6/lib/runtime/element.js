"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ElementController = void 0;
const g_1 = require("@antv/g");
const util_1 = require("@antv/util");
const constants_1 = require("../constants");
const element_1 = require("../constants/element");
const registry_1 = require("../registry");
const cache_1 = require("../utils/cache");
const change_1 = require("../utils/change");
const collapsibility_1 = require("../utils/collapsibility");
const element_2 = require("../utils/element");
const event_1 = require("../utils/event");
const id_1 = require("../utils/id");
const palette_1 = require("../utils/palette");
const position_1 = require("../utils/position");
const style_1 = require("../utils/style");
const theme_1 = require("../utils/theme");
class ElementController {
    context;
    container;
    elementMap = {};
    shapeTypeMap = {};
    constructor(context) {
        this.context = context;
    }
    init() {
        if (!this.container) {
            const { canvas } = this.context;
            this.container = {
                node: canvas.appendChild(new g_1.Group({ style: { zIndex: 2 } })),
                edge: canvas.appendChild(new g_1.Group({ style: { zIndex: 1 } })),
                combo: canvas.appendChild(new g_1.Group({ style: { zIndex: 0 } })),
            };
        }
    }
    emit(event, context) {
        if (context.silence)
            return;
        (0, event_1.emit)(this.context.graph, event);
    }
    forEachElementData(callback) {
        element_1.ELEMENT_TYPES.forEach((elementType) => {
            const elementData = this.context.model.getElementsDataByType(elementType);
            callback(elementType, elementData);
        });
    }
    getElementType(elementType, datum) {
        const { options } = this.context;
        const userDefinedType = options[elementType]?.type || datum.type;
        if (!userDefinedType) {
            if (elementType === 'edge')
                return 'line';
            // node / combo
            else
                return 'circle';
        }
        if (typeof userDefinedType === 'string')
            return userDefinedType;
        return userDefinedType(datum);
    }
    getTheme(elementType) {
        return (0, theme_1.themeOf)(this.context.options)[elementType] || {};
    }
    getThemeStyle(elementType) {
        return this.getTheme(elementType).style || {};
    }
    getThemeStateStyle(elementType, states) {
        const { state = {} } = this.getTheme(elementType);
        return Object.assign({}, ...states.map((name) => state[name] || {}));
    }
    paletteStyle = {};
    computePaletteStyle() {
        const { options } = this.context;
        this.paletteStyle = {};
        this.forEachElementData((elementType, elementData) => {
            const palette = Object.assign({}, (0, palette_1.parsePalette)(this.getTheme(elementType)?.palette), (0, palette_1.parsePalette)(options[elementType]?.palette));
            if (palette?.field) {
                Object.assign(this.paletteStyle, (0, palette_1.assignColorByPalette)(elementData, palette));
            }
        });
    }
    getPaletteStyle(elementType, id) {
        const color = this.paletteStyle[id];
        if (!color)
            return {};
        if (elementType === 'edge')
            return { stroke: color };
        return { fill: color };
    }
    defaultStyle = {};
    /**
     * <zh/> 计算单个元素的默认样式
     *
     * <en/> compute default style of single element
     */
    computeElementDefaultStyle(elementType, context) {
        const { options } = this.context;
        const defaultStyle = options[elementType]?.style || {};
        this.defaultStyle[(0, id_1.idOf)(context.datum)] = (0, style_1.computeElementCallbackStyle)(defaultStyle, context);
    }
    computeElementsDefaultStyle(ids) {
        this.forEachElementData((elementType, elementData) => {
            const length = elementData.length;
            for (let i = 0; i < length; i++) {
                const datum = elementData[i];
                if (ids === undefined || ids.includes((0, id_1.idOf)(datum))) {
                    this.computeElementDefaultStyle(elementType, { datum });
                }
            }
        });
    }
    getDefaultStyle(id) {
        return this.defaultStyle[id] || {};
    }
    getElementState(id) {
        try {
            const { model } = this.context;
            return model.getElementState(id);
        }
        catch {
            return [];
        }
    }
    stateStyle = {};
    /**
     * <zh/> 获取单个元素的单个状态的样式
     *
     * <en/> get single state style of single element
     */
    getElementStateStyle(elementType, state, context) {
        const { options } = this.context;
        const stateStyle = options[elementType]?.state?.[state] || {};
        return (0, style_1.computeElementCallbackStyle)(stateStyle, context);
    }
    /**
     * <zh/> 计算单个元素的合并状态样式
     *
     * <en/> compute merged state style of single element
     */
    computeElementStatesStyle(elementType, states, context) {
        this.stateStyle[(0, id_1.idOf)(context.datum)] = Object.assign({}, ...states.map((state) => this.getElementStateStyle(elementType, state, context)));
    }
    /**
     * <zh/> 计算全部元素的状态样式
     *
     * <en/> compute state style of all elements
     * @param ids - <zh/> 计算指定元素的状态样式 | <en/> compute state style of specified elements
     */
    computeElementsStatesStyle(ids) {
        this.forEachElementData((elementType, elementData) => {
            const length = elementData.length;
            for (let i = 0; i < length; i++) {
                const datum = elementData[i];
                if (ids === undefined || ids.includes((0, id_1.idOf)(datum))) {
                    const states = this.getElementState((0, id_1.idOf)(datum));
                    this.computeElementStatesStyle(elementType, states, { datum });
                }
            }
        });
    }
    getStateStyle(id) {
        return this.stateStyle[id] || {};
    }
    computeStyle(ids) {
        this.computePaletteStyle();
        this.computeElementsDefaultStyle(ids);
        this.computeElementsStatesStyle(ids);
    }
    getElement(id) {
        return this.elementMap[id];
    }
    getNodes() {
        return this.container.node.children;
    }
    getEdges() {
        return this.container.edge.children;
    }
    getCombos() {
        return this.container.combo.children;
    }
    getElementComputedStyle(elementType, datum) {
        const id = (0, id_1.idOf)(datum);
        // 优先级(从低到高) Priority (from low to high):
        const themeStyle = this.getThemeStyle(elementType);
        const paletteStyle = this.getPaletteStyle(elementType, id);
        const dataStyle = datum.style || {};
        const defaultStyle = this.getDefaultStyle(id);
        const themeStateStyle = this.getThemeStateStyle(elementType, this.getElementState(id));
        const stateStyle = this.getStateStyle(id);
        const style = Object.assign({}, themeStyle, paletteStyle, dataStyle, defaultStyle, themeStateStyle, stateStyle);
        if (elementType === 'combo') {
            const childrenData = this.context.model.getChildrenData(id);
            const isCollapsed = !!style.collapsed;
            const childrenNode = isCollapsed ? [] : childrenData.map(id_1.idOf).filter((id) => this.getElement(id));
            Object.assign(style, { childrenNode, childrenData });
        }
        return style;
    }
    /**
     * <zh/> 开始绘制流程
     *
     * <en/> start render process
     */
    draw(context = { animation: true }) {
        this.init();
        const data = this.computeChangesAndDrawData(context);
        if (!data)
            return null;
        const { dataChanges, drawData } = data;
        // 计算样式 / Calculate style
        this.computeStyle();
        // 创建渲染任务 / Create render task
        const { add, update, remove } = drawData;
        this.destroyElements(remove, context);
        this.createElements(add, context);
        this.updateElements(update, context);
        const { animation, silence } = context;
        return this.context.animation.animate(animation, silence
            ? {}
            : {
                before: () => this.emit(new event_1.GraphLifeCycleEvent(constants_1.GraphEvent.BEFORE_DRAW, { dataChanges, animation }), context),
                beforeAnimate: (animation) => this.emit(new event_1.AnimateEvent(constants_1.GraphEvent.BEFORE_ANIMATE, constants_1.AnimationType.DRAW, animation, drawData), context),
                afterAnimate: (animation) => this.emit(new event_1.AnimateEvent(constants_1.GraphEvent.AFTER_ANIMATE, constants_1.AnimationType.DRAW, animation, drawData), context),
                after: () => this.emit(new event_1.GraphLifeCycleEvent(constants_1.GraphEvent.AFTER_DRAW, { dataChanges, animation }), context),
            });
    }
    computeChangesAndDrawData(context) {
        const { model } = this.context;
        const dataChanges = model.getChanges();
        const tasks = (0, change_1.reduceDataChanges)(dataChanges);
        if (tasks.length === 0)
            return null;
        const { NodeAdded = [], NodeUpdated = [], NodeRemoved = [], EdgeAdded = [], EdgeUpdated = [], EdgeRemoved = [], ComboAdded = [], ComboUpdated = [], ComboRemoved = [], } = (0, util_1.groupBy)(tasks, (change) => change.type);
        const dataOf = (data) => new Map(data.map((datum) => {
            const data = datum.value;
            return [(0, id_1.idOf)(data), data];
        }));
        const input = {
            add: {
                nodes: dataOf(NodeAdded),
                edges: dataOf(EdgeAdded),
                combos: dataOf(ComboAdded),
            },
            update: {
                nodes: dataOf(NodeUpdated),
                edges: dataOf(EdgeUpdated),
                combos: dataOf(ComboUpdated),
            },
            remove: {
                nodes: dataOf(NodeRemoved),
                edges: dataOf(EdgeRemoved),
                combos: dataOf(ComboRemoved),
            },
        };
        const drawData = this.transformData(input, context);
        // 清空变更 / Clear changes
        model.clearChanges();
        return { dataChanges, drawData };
    }
    transformData(input, context) {
        const transforms = this.context.transform.getTransformInstance();
        return Object.values(transforms).reduce((data, transform) => transform.beforeDraw(data, context), input);
    }
    createElement(elementType, datum, context) {
        const id = (0, id_1.idOf)(datum);
        const currentElement = this.getElement(id);
        if (currentElement)
            return;
        const type = this.getElementType(elementType, datum);
        const style = this.getElementComputedStyle(elementType, datum);
        // get shape constructor
        const Ctor = (0, registry_1.getExtension)(elementType, type);
        if (!Ctor)
            return;
        this.emit(new event_1.ElementLifeCycleEvent(constants_1.GraphEvent.BEFORE_ELEMENT_CREATE, elementType, datum), context);
        const element = this.container[elementType].appendChild(new Ctor({
            id,
            style: {
                context: this.context,
                ...style,
            },
        }));
        this.shapeTypeMap[id] = type;
        this.elementMap[id] = element;
        const { stage = 'enter' } = context;
        this.context.animation?.add({
            element,
            elementType,
            stage,
            originalStyle: { ...element.attributes },
            modifiedStyle: { ...element.attributes, ...style },
        }, {
            after: () => {
                this.emit(new event_1.ElementLifeCycleEvent(constants_1.GraphEvent.AFTER_ELEMENT_CREATE, elementType, datum), context);
                element.onCreate();
            },
        });
    }
    createElements(data, context) {
        const { nodes, edges, combos } = data;
        const iteration = [
            ['node', nodes],
            ['combo', combos],
            ['edge', edges],
        ];
        iteration.forEach(([elementType, elementData]) => {
            elementData.forEach((datum) => this.createElement(elementType, datum, context));
        });
    }
    updateElement(elementType, datum, context) {
        const id = (0, id_1.idOf)(datum);
        const element = this.getElement(id);
        if (!element)
            return () => null;
        this.emit(new event_1.ElementLifeCycleEvent(constants_1.GraphEvent.BEFORE_ELEMENT_UPDATE, elementType, datum), context);
        const type = this.getElementType(elementType, datum);
        const style = this.getElementComputedStyle(elementType, datum);
        // 如果类型不同，需要先销毁原有元素，再创建新元素
        // If the type is different, you need to destroy the original element first, and then create a new element
        if (this.shapeTypeMap[id] !== type) {
            element.destroy();
            delete this.shapeTypeMap[id];
            delete this.elementMap[id];
            this.createElement(elementType, datum, { animation: false, silence: true });
        }
        const { stage = 'update' } = context;
        const exactStage = stage !== 'visibility' ? stage : style.visibility === 'hidden' ? 'hide' : 'show';
        this.context.animation?.add({
            element,
            elementType,
            stage: exactStage,
            originalStyle: { ...element.attributes },
            modifiedStyle: { ...element.attributes, ...style },
        }, {
            before: () => {
                if (stage !== 'collapse')
                    (0, element_2.updateStyle)(element, style);
                if (stage === 'visibility') {
                    // 缓存原始透明度 / Cache original opacity
                    // 会在 animation controller 中访问该缓存值 / The cached value will be accessed in the animation controller
                    if (!(0, cache_1.hasCachedStyle)(element, 'opacity'))
                        (0, cache_1.cacheStyle)(element, 'opacity');
                    (0, cache_1.setCacheStyle)(element, 'visibility', exactStage === 'show' ? 'visible' : 'hidden');
                    if (exactStage === 'show')
                        (0, element_2.updateStyle)(element, { visibility: 'visible' });
                }
            },
            after: () => {
                if (stage === 'collapse')
                    (0, element_2.updateStyle)(element, style);
                if (exactStage === 'hide')
                    (0, element_2.updateStyle)(element, { visibility: (0, cache_1.getCachedStyle)(element, 'visibility') });
                this.emit(new event_1.ElementLifeCycleEvent(constants_1.GraphEvent.AFTER_ELEMENT_UPDATE, elementType, datum), context);
                element.onUpdate();
            },
        });
    }
    updateElements(data, context) {
        const { nodes, edges, combos } = data;
        const iteration = [
            ['node', nodes],
            ['combo', combos],
            ['edge', edges],
        ];
        iteration.forEach(([elementType, elementData]) => {
            elementData.forEach((datum) => this.updateElement(elementType, datum, context));
        });
    }
    destroyElement(elementType, datum, context) {
        const { stage = 'exit' } = context;
        const id = (0, id_1.idOf)(datum);
        const element = this.elementMap[id];
        if (!element)
            return () => null;
        this.emit(new event_1.ElementLifeCycleEvent(constants_1.GraphEvent.BEFORE_ELEMENT_DESTROY, elementType, datum), context);
        this.context.animation?.add({
            element,
            elementType,
            stage,
            originalStyle: { ...element.attributes },
            modifiedStyle: { ...element.attributes },
        }, {
            after: () => {
                this.clearElement(id);
                element.destroy();
                element.onDestroy();
                this.emit(new event_1.ElementLifeCycleEvent(constants_1.GraphEvent.AFTER_ELEMENT_DESTROY, elementType, datum), context);
            },
        });
    }
    destroyElements(data, context) {
        const { nodes, edges, combos } = data;
        const iteration = [
            ['combo', combos],
            ['edge', edges],
            ['node', nodes],
        ];
        iteration.forEach(([elementType, elementData]) => {
            elementData.forEach((datum) => this.destroyElement(elementType, datum, context));
        });
        // TODO 重新计算色板样式，如果是分组色板，则不需要重新计算
    }
    clearElement(id) {
        delete this.paletteStyle[id];
        delete this.defaultStyle[id];
        delete this.stateStyle[id];
        delete this.elementMap[id];
        delete this.shapeTypeMap[id];
    }
    /**
     * <zh/> 收起节点
     *
     * <en/> collapse node
     * @param id - <zh/> 元素 ID | <en/> element ID
     * @param animation - <zh/> 是否使用动画，默认为 true | <en/> Whether to use animation, default is true
     */
    async collapseNode(id, animation) {
        const { model, layout } = this.context;
        const preprocess = this.computeChangesAndDrawData({ stage: 'collapse', animation });
        preprocess.drawData.remove.nodes.forEach((datum) => {
            const id = (0, id_1.idOf)(datum);
            const element = this.getElement(id);
            if (element)
                (0, element_2.markToBeDestroyed)(element);
        });
        // 进行预布局，计算出所有元素的位置
        // Perform pre-layout to calculate the position of all elements
        const result = await layout.simulate();
        model.updateData(result);
        // 重新计算数据 / Recalculate data
        const { drawData } = this.computeChangesAndDrawData({ stage: 'collapse', animation });
        const { add, remove, update } = drawData;
        const context = { animation, stage: 'collapse', data: drawData };
        this.destroyElements(remove, context);
        this.createElements(add, context);
        this.updateElements(update, context);
        await this.context.animation.animate(animation, {
            beforeAnimate: (animation) => this.emit(new event_1.AnimateEvent(constants_1.GraphEvent.BEFORE_ANIMATE, constants_1.AnimationType.COLLAPSE, animation, drawData), context),
            afterAnimate: (animation) => this.emit(new event_1.AnimateEvent(constants_1.GraphEvent.AFTER_ANIMATE, constants_1.AnimationType.COLLAPSE, animation, drawData), context),
        }, {
            collapse: {
                target: id,
                descendants: Array.from(remove.nodes).map(([, node]) => (0, id_1.idOf)(node)),
                position: (0, position_1.positionOf)(update.nodes.get(id)),
            },
        })?.finished;
    }
    /**
     * <zh/> 展开节点
     *
     * <en/> expand node
     * @param id - <zh/> 元素 ID | <en/> element ID
     * @param animation - <zh/> 是否使用动画，默认为 true | <en/> Whether to use animation, default is true
     */
    async expandNode(id, animation) {
        const { model, layout } = this.context;
        if (!model.getAncestorsData(id, constants_1.COMBO_KEY).every((datum) => (0, collapsibility_1.isCollapsed)(datum)))
            return;
        const position = (0, position_1.positionOf)(model.getNodeData([id])[0]);
        // 首先创建展开的元素，然后进行预布局
        // First create the expanded element, then perform pre-layout
        const { drawData: { add }, } = this.computeChangesAndDrawData({ stage: 'collapse', animation });
        this.createElements(add, { animation: false, stage: 'expand' });
        // 重置动画 / Reset animation
        this.context.animation.clear();
        const result = await layout.simulate();
        model.updateData(result);
        // 重新计算数据 / Recalculate data
        this.computeStyle();
        const { drawData } = this.computeChangesAndDrawData({ stage: 'collapse', animation });
        const { update } = drawData;
        const context = { animation, stage: 'expand', data: drawData };
        // 将新增边添加到更新列表 / Add new edges to the update list
        add.edges.forEach((edge) => {
            const id = (0, id_1.idOf)(edge);
            if (!update.edges.has(id))
                update.edges.set(id, edge);
        });
        this.updateElements(update, context);
        await this.context.animation.animate(animation, {
            beforeAnimate: (animation) => this.emit(new event_1.AnimateEvent(constants_1.GraphEvent.BEFORE_ANIMATE, constants_1.AnimationType.EXPAND, animation, drawData), context),
            afterAnimate: (animation) => this.emit(new event_1.AnimateEvent(constants_1.GraphEvent.AFTER_ANIMATE, constants_1.AnimationType.EXPAND, animation, drawData), context),
        }, {
            expand: {
                target: id,
                descendants: Array.from(add.nodes).map(([, node]) => (0, id_1.idOf)(node)),
                position,
            },
        })?.finished;
    }
    async collapseCombo(id, animation) {
        const { model, element } = this.context;
        if (model.getAncestorsData(id, constants_1.COMBO_KEY).some((datum) => (0, collapsibility_1.isCollapsed)(datum)))
            return;
        const combo = element.getElement(id);
        const position = combo.getComboPosition({
            ...combo.attributes,
            collapsed: true,
        });
        const { dataChanges, drawData } = this.computeChangesAndDrawData({ stage: 'collapse', animation });
        const { update, remove } = drawData;
        const context = { animation, stage: 'collapse', data: drawData };
        this.destroyElements(remove, context);
        this.updateElements(update, context);
        const idsOf = (data) => Array.from(data).map(([, node]) => (0, id_1.idOf)(node));
        await this.context.animation.animate(animation, {
            before: () => this.emit(new event_1.GraphLifeCycleEvent(constants_1.GraphEvent.BEFORE_DRAW, { dataChanges, animation }), context),
            beforeAnimate: (animation) => this.emit(new event_1.AnimateEvent(constants_1.GraphEvent.BEFORE_ANIMATE, constants_1.AnimationType.COLLAPSE, animation, drawData), context),
            afterAnimate: (animation) => this.emit(new event_1.AnimateEvent(constants_1.GraphEvent.AFTER_ANIMATE, constants_1.AnimationType.COLLAPSE, animation, drawData), context),
            after: () => this.emit(new event_1.GraphLifeCycleEvent(constants_1.GraphEvent.AFTER_DRAW, { dataChanges, animation }), context),
        }, {
            collapse: {
                target: id,
                descendants: [...idsOf(remove.nodes), ...idsOf(remove.combos)],
                position,
            },
        })?.finished;
    }
    async expandCombo(id, animation) {
        const { model } = this.context;
        const position = (0, position_1.positionOf)(model.getComboData([id])[0]);
        // 重新计算数据 / Recalculate data
        this.computeStyle();
        const { dataChanges, drawData } = this.computeChangesAndDrawData({ stage: 'expand', animation });
        const { add, update } = drawData;
        const context = { animation, stage: 'expand', data: drawData };
        this.createElements(add, context);
        this.updateElements(update, context);
        const idsOf = (data) => Array.from(data).map(([, node]) => (0, id_1.idOf)(node));
        await this.context.animation.animate(animation, {
            before: () => this.emit(new event_1.GraphLifeCycleEvent(constants_1.GraphEvent.BEFORE_DRAW, { dataChanges, animation }), context),
            beforeAnimate: (animation) => this.emit(new event_1.AnimateEvent(constants_1.GraphEvent.BEFORE_ANIMATE, constants_1.AnimationType.EXPAND, animation, drawData), context),
            afterAnimate: (animation) => this.emit(new event_1.AnimateEvent(constants_1.GraphEvent.AFTER_ANIMATE, constants_1.AnimationType.EXPAND, animation, drawData), context),
            after: () => this.emit(new event_1.GraphLifeCycleEvent(constants_1.GraphEvent.AFTER_DRAW, { dataChanges, animation }), context),
        }, {
            expand: {
                target: id,
                descendants: [...idsOf(add.nodes), ...idsOf(add.combos)],
                position,
            },
        })?.finished;
    }
    destroy() {
        // @ts-expect-error force delete
        this.container = {};
        this.elementMap = {};
        this.shapeTypeMap = {};
        this.defaultStyle = {};
        this.stateStyle = {};
        this.paletteStyle = {};
        // @ts-expect-error force delete
        this.context = {};
    }
}
exports.ElementController = ElementController;
//# sourceMappingURL=element.js.map
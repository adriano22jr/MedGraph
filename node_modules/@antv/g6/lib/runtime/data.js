"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataController = void 0;
const graphlib_1 = require("@antv/graphlib");
const util_1 = require("@antv/util");
const constants_1 = require("../constants");
const collapsibility_1 = require("../utils/collapsibility");
const data_1 = require("../utils/data");
const diff_1 = require("../utils/diff");
const graphlib_2 = require("../utils/graphlib");
const id_1 = require("../utils/id");
const position_1 = require("../utils/position");
const style_1 = require("../utils/style");
const traverse_1 = require("../utils/traverse");
const vector_1 = require("../utils/vector");
class DataController {
    model;
    /**
     * <zh/> 最近一次删除的 combo 的 id
     *
     * <en/> The ids of the last deleted combos
     * @remarks
     * <zh/> 当删除 combo 后，会将其 id 从 comboIds 中移除，此时根据 Graphlib 的 changes 事件获取到的 NodeRemoved 无法区分是 combo 还是 node。
     * 因此需要记录最近一次删除的 combo 的 id，并用于 isCombo 的判断
     *
     * <en/> When the combo is deleted, its id will be removed from comboIds. At this time, the NodeRemoved obtained according to the changes event of Graphlib cannot distinguish whether it is a combo or a node.
     * Therefore, it is necessary to record the id of the last deleted combo and use it to judge isCombo
     */
    latestRemovedComboIds = new Set();
    comboIds = new Set();
    /**
     * <zh/> 获取详细数据变更
     *
     * <en/> Get detailed data changes
     */
    changes = [];
    /**
     * <zh/> 批处理计数器
     *
     * <en/> Batch processing counter
     */
    batchCount = 0;
    /**
     * <zh/> 是否处于无痕模式
     *
     * <en/> Whether it is in traceless mode
     */
    isTraceless = false;
    constructor() {
        this.model = new graphlib_1.Graph();
    }
    pushChange(change) {
        if (this.isTraceless)
            return;
        const { type } = change;
        if (type === constants_1.ChangeType.NodeUpdated || type === constants_1.ChangeType.EdgeUpdated || type === constants_1.ChangeType.ComboUpdated) {
            const { value, original } = change;
            this.changes.push({ value: (0, data_1.cloneElementData)(value), original: (0, data_1.cloneElementData)(original), type });
        }
        else {
            this.changes.push({ value: (0, data_1.cloneElementData)(change.value), type });
        }
    }
    /**
     * <zh/> [警告] 此 API 仅供 Element Controller 调用
     *
     * <en/> [WARNING] This API is only for Element Controller
     * @returns <zh/> 数据变更 | <en/> data changes
     */
    getChanges() {
        return this.changes;
    }
    clearChanges() {
        this.changes = [];
    }
    batch(callback) {
        this.batchCount++;
        this.model.batch(callback);
        this.batchCount--;
    }
    /**
     * <zh/> 执行操作而不会留下记录
     *
     * <en/> Perform operations without leaving records
     * @param callback - <zh/> 回调函数 | <en/> callback function
     * @remarks
     * <zh/> 通常用于运行时调整元素并同步数据，避免触发数据变更导致重绘
     *
     * <en/> Usually used to adjust elements at runtime and synchronize data to avoid triggering data changes and causing redraws
     */
    silence(callback) {
        this.isTraceless = true;
        callback();
        this.isTraceless = false;
    }
    isCombo(id) {
        return this.comboIds.has(id) || this.latestRemovedComboIds.has(id);
    }
    getData() {
        return {
            nodes: this.getNodeData(),
            edges: this.getEdgeData(),
            combos: this.getComboData(),
        };
    }
    getNodeData(ids) {
        return this.model.getAllNodes().reduce((acc, node) => {
            const data = (0, graphlib_2.toG6Data)(node);
            if (this.isCombo((0, id_1.idOf)(data)))
                return acc;
            if (ids === undefined)
                acc.push(data);
            else
                ids.includes((0, id_1.idOf)(data)) && acc.push(data);
            return acc;
        }, []);
    }
    getEdgeDatum(id) {
        return (0, graphlib_2.toG6Data)(this.model.getEdge(id));
    }
    getEdgeData(ids) {
        return this.model.getAllEdges().reduce((acc, edge) => {
            const data = (0, graphlib_2.toG6Data)(edge);
            if (ids === undefined)
                acc.push(data);
            else
                ids.includes((0, id_1.idOf)(data)) && acc.push(data);
            return acc;
        }, []);
    }
    getComboData(ids) {
        return this.model.getAllNodes().reduce((acc, combo) => {
            const data = (0, graphlib_2.toG6Data)(combo);
            if (!this.isCombo((0, id_1.idOf)(data)))
                return acc;
            if (ids === undefined)
                acc.push(data);
            else
                ids.includes((0, id_1.idOf)(data)) && acc.push(data);
            return acc;
        }, []);
    }
    getAncestorsData(id, hierarchyKey) {
        const { model } = this;
        if (!model.hasNode(id) || !model.hasTreeStructure(hierarchyKey))
            return [];
        return model.getAncestors(id, hierarchyKey).map(graphlib_2.toG6Data);
    }
    getDescendantsData(id) {
        const root = this.getElementDataById(id);
        const data = [];
        (0, traverse_1.dfs)(root, (node) => {
            if (node !== root)
                data.push(node);
        }, (node) => this.getChildrenData((0, id_1.idOf)(node)), 'TB');
        return data;
    }
    getParentData(id, hierarchyKey) {
        const { model } = this;
        if (!hierarchyKey) {
            console.error('The hierarchy structure key is not specified');
            return undefined;
        }
        if (!model.hasNode(id) || !model.hasTreeStructure(hierarchyKey))
            return undefined;
        const parent = model.getParent(id, hierarchyKey);
        return parent ? (0, graphlib_2.toG6Data)(parent) : undefined;
    }
    getChildrenData(id) {
        const structureKey = this.getElementType(id) === 'node' ? constants_1.TREE_KEY : constants_1.COMBO_KEY;
        const { model } = this;
        if (!model.hasNode(id) || !model.hasTreeStructure(structureKey))
            return [];
        return model.getChildren(id, structureKey).map(graphlib_2.toG6Data);
    }
    /**
     * <zh/> 获取指定类型元素的数据
     *
     * <en/> Get the data of the specified type of element
     * @param elementType - <zh/> 元素类型 | <en/> element type
     * @returns <zh/> 元素数据 | <en/> element data
     */
    getElementsDataByType(elementType) {
        if (elementType === 'node')
            return this.getNodeData();
        if (elementType === 'edge')
            return this.getEdgeData();
        if (elementType === 'combo')
            return this.getComboData();
        return [];
    }
    /**
     * <zh/> 根据 ID 获取元素的数据，不用关心元素的类型
     *
     * <en/> Get the data of the element by ID, no need to care about the type of the element
     * @param id - <zh/> 元素 ID 数组 | <en/> element ID array
     * @returns <zh/> 元素数据 | <en/> data of the element
     */
    getElementDataById(id) {
        const type = this.getElementType(id);
        if (type === 'edge')
            return this.getEdgeDatum(id);
        return this.getNodeLikeDatum(id);
    }
    /**
     * <zh/> 获取节点的数据
     *
     * <en/> Get node data
     * @param id - <zh/> 节点 ID | <en/> node ID
     * @returns <zh/> 节点数据 | <en/> node data
     */
    getNodeLikeDatum(id) {
        const data = this.model.getNode(id);
        return (0, graphlib_2.toG6Data)(data);
    }
    /**
     * <zh/> 获取所有节点和 combo 的数据
     *
     * <en/> Get all node and combo data
     * @param ids - <zh/> 节点和 combo ID 数组 | <en/> node and combo ID array
     * @returns <zh/> 节点和 combo 的数据 | <en/> node and combo data
     */
    getNodeLikeData(ids) {
        return this.model.getAllNodes().reduce((acc, node) => {
            const data = (0, graphlib_2.toG6Data)(node);
            if (ids)
                ids.includes((0, id_1.idOf)(data)) && acc.push(data);
            else
                acc.push(data);
            return acc;
        }, []);
    }
    getElementDataByState(elementType, state) {
        const elementData = this.getElementsDataByType(elementType);
        return elementData.filter((datum) => datum.states?.includes(state));
    }
    getElementState(id) {
        return this.getElementDataById(id)?.states || [];
    }
    hasNode(id) {
        return this.model.hasNode(id) && !this.isCombo(id);
    }
    hasEdge(id) {
        return this.model.hasEdge(id);
    }
    hasCombo(id) {
        return this.model.hasNode(id) && this.isCombo(id);
    }
    getRelatedEdgesData(id, direction = 'both') {
        return this.model.getRelatedEdges(id, direction).map(graphlib_2.toG6Data);
    }
    getNeighborNodesData(id) {
        return this.model.getNeighbors(id).map(graphlib_2.toG6Data);
    }
    setData(data) {
        const { nodes: modifiedNodes = [], edges: modifiedEdges = [], combos: modifiedCombos = [] } = data;
        const { nodes: originalNodes = [], edges: originalEdges = [], combos: originalCombos = [] } = this.getData();
        const nodeDiff = (0, diff_1.arrayDiff)(originalNodes, modifiedNodes, (node) => (0, id_1.idOf)(node));
        const edgeDiff = (0, diff_1.arrayDiff)(originalEdges, modifiedEdges, (edge) => (0, id_1.idOf)(edge));
        const comboDiff = (0, diff_1.arrayDiff)(originalCombos, modifiedCombos, (combo) => (0, id_1.idOf)(combo));
        this.batch(() => {
            this.addData({
                nodes: nodeDiff.enter,
                edges: edgeDiff.enter,
                combos: comboDiff.enter,
            });
            this.updateData({
                nodes: nodeDiff.update,
                edges: edgeDiff.update,
                combos: comboDiff.update,
            });
            this.removeData({
                nodes: nodeDiff.exit.map(id_1.idOf),
                edges: edgeDiff.exit.map(id_1.idOf),
                combos: comboDiff.exit.map(id_1.idOf),
            });
        });
    }
    addData(data) {
        const { nodes, edges, combos } = data;
        this.batch(() => {
            // add combo first
            this.addComboData(combos);
            this.addNodeData(nodes);
            this.addEdgeData(edges);
        });
    }
    addNodeData(nodes = []) {
        if (!nodes.length)
            return;
        this.model.addNodes(nodes.map((node) => {
            this.pushChange({ value: node, type: constants_1.ChangeType.NodeAdded });
            return (0, graphlib_2.toGraphlibData)(node);
        }));
        this.updateNodeLikeHierarchy(nodes);
    }
    addEdgeData(edges = []) {
        if (!edges.length)
            return;
        this.model.addEdges(edges.map((edge) => {
            this.pushChange({ value: edge, type: constants_1.ChangeType.EdgeAdded });
            return (0, graphlib_2.toGraphlibData)(edge);
        }));
    }
    addComboData(combos = []) {
        if (!combos.length)
            return;
        const { model } = this;
        if (!model.hasTreeStructure(constants_1.COMBO_KEY)) {
            model.attachTreeStructure(constants_1.COMBO_KEY);
        }
        model.addNodes(combos.map((combo) => {
            this.comboIds.add((0, id_1.idOf)(combo));
            this.pushChange({ value: combo, type: constants_1.ChangeType.ComboAdded });
            return (0, graphlib_2.toGraphlibData)(combo);
        }));
        this.updateNodeLikeHierarchy(combos);
    }
    updateNodeLikeHierarchy(data) {
        if (!this.enableUpdateNodeLikeHierarchy)
            return;
        const { model } = this;
        data.forEach((datum) => {
            const id = (0, id_1.idOf)(datum);
            model.attachTreeStructure(constants_1.COMBO_KEY);
            this.setParent(id, (0, id_1.parentIdOf)(datum), constants_1.COMBO_KEY);
            const children = datum.children;
            if (children !== undefined) {
                model.attachTreeStructure(constants_1.TREE_KEY);
                children.forEach((child) => {
                    this.setParent(child, id, constants_1.TREE_KEY);
                });
            }
        });
    }
    enableUpdateNodeLikeHierarchy = true;
    /**
     * <zh/> 执行变更时不要更新节点层次结构
     *
     * <en/> Do not update the node hierarchy when executing changes
     * @param callback - <zh/> 变更函数 | <en/> change function
     */
    preventUpdateNodeLikeHierarchy(callback) {
        this.enableUpdateNodeLikeHierarchy = false;
        callback();
        this.enableUpdateNodeLikeHierarchy = true;
    }
    updateData(data) {
        const { nodes, edges, combos } = data;
        this.batch(() => {
            this.updateNodeData(nodes);
            this.updateComboData(combos);
            this.updateEdgeData(edges);
        });
    }
    updateNodeData(nodes = []) {
        if (!nodes.length)
            return;
        const { model } = this;
        this.batch(() => {
            const modifiedNodes = [];
            nodes.forEach((modifiedNode) => {
                const id = (0, id_1.idOf)(modifiedNode);
                const originalNode = (0, graphlib_2.toG6Data)(model.getNode(id));
                if ((0, util_1.isEqual)(originalNode, modifiedNode))
                    return;
                const value = (0, data_1.mergeElementsData)(originalNode, modifiedNode);
                this.pushChange({ value, original: originalNode, type: constants_1.ChangeType.NodeUpdated });
                model.mergeNodeData(id, value);
                modifiedNodes.push(value);
            });
            this.updateNodeLikeHierarchy(modifiedNodes);
        });
    }
    /**
     * <zh/> 将所有数据提交到变更记录中以进行重绘
     *
     * <en/> Submit all data to the change record for redrawing
     */
    refreshData() {
        const { nodes, edges, combos } = this.getData();
        nodes.forEach((node) => {
            this.pushChange({ value: node, original: node, type: constants_1.ChangeType.NodeUpdated });
        });
        edges.forEach((edge) => {
            this.pushChange({ value: edge, original: edge, type: constants_1.ChangeType.EdgeUpdated });
        });
        combos.forEach((combo) => {
            this.pushChange({ value: combo, original: combo, type: constants_1.ChangeType.ComboUpdated });
        });
    }
    syncNodeDatum(datum) {
        const { model } = this;
        const id = (0, id_1.idOf)(datum);
        const original = (0, graphlib_2.toG6Data)(model.getNode(id));
        const value = (0, data_1.mergeElementsData)(original, datum);
        model.mergeNodeData(id, value);
    }
    updateEdgeData(edges = []) {
        if (!edges.length)
            return;
        const { model } = this;
        this.batch(() => {
            edges.forEach((modifiedEdge) => {
                const id = (0, id_1.idOf)(modifiedEdge);
                const originalEdge = (0, graphlib_2.toG6Data)(model.getEdge(id));
                if ((0, util_1.isEqual)(originalEdge, modifiedEdge))
                    return;
                if (modifiedEdge.source && originalEdge.source !== modifiedEdge.source) {
                    model.updateEdgeSource(id, modifiedEdge.source);
                }
                if (modifiedEdge.target && originalEdge.target !== modifiedEdge.target) {
                    model.updateEdgeTarget(id, modifiedEdge.target);
                }
                const updatedData = (0, data_1.mergeElementsData)(originalEdge, modifiedEdge);
                this.pushChange({ value: updatedData, original: originalEdge, type: constants_1.ChangeType.EdgeUpdated });
                model.mergeEdgeData(id, updatedData);
            });
        });
    }
    updateComboData(combos = []) {
        if (!combos.length)
            return;
        const { model } = this;
        model.batch(() => {
            const modifiedCombos = [];
            combos.forEach((modifiedCombo) => {
                const id = (0, id_1.idOf)(modifiedCombo);
                const originalCombo = (0, graphlib_2.toG6Data)(model.getNode(id));
                if ((0, util_1.isEqual)(originalCombo, modifiedCombo))
                    return;
                const value = (0, data_1.mergeElementsData)(originalCombo, modifiedCombo);
                this.pushChange({ value, original: originalCombo, type: constants_1.ChangeType.ComboUpdated });
                model.mergeNodeData(id, value);
                modifiedCombos.push(value);
            });
            this.updateNodeLikeHierarchy(modifiedCombos);
        });
    }
    /**
     * <zh/> 设置节点的父节点
     *
     * <en/> Set the parent node of the node
     * @param id - <zh/> 节点 ID | <en/> node ID
     * @param parent - <zh/> 父节点 ID | <en/> parent node ID
     * @param hierarchyKey - <zh/> 层次结构类型 | <en/> hierarchy type
     * @param update - <zh/> 添加新/旧父节点数据更新记录 | <en/> add new/old parent node data update record
     */
    setParent(id, parent, hierarchyKey, update = true) {
        if (id === parent)
            return;
        const originalParentId = (0, id_1.parentIdOf)(this.getNodeLikeDatum(id));
        // Sync data
        if (originalParentId !== parent && hierarchyKey === constants_1.COMBO_KEY) {
            const modifiedDatum = { id, combo: parent };
            if (this.isCombo(id))
                this.syncComboDatum(modifiedDatum);
            else
                this.syncNodeDatum(modifiedDatum);
        }
        this.model.setParent(id, parent, hierarchyKey);
        if (update && hierarchyKey === constants_1.COMBO_KEY) {
            (0, util_1.uniq)([originalParentId, parent]).forEach((pId) => {
                if (pId !== undefined)
                    this.refreshComboData(pId);
            });
        }
    }
    /**
     * <zh/> 刷新 combo 数据
     *
     * <en/> Refresh combo data
     * @param id - <zh/> combo ID | <en/> combo ID
     * @remarks
     * <zh/> 不会更改数据，但会触发数据变更事件
     *
     * <en/> Will not change the data, but will trigger data change events
     */
    refreshComboData(id) {
        const combo = this.getComboData([id])[0];
        const ancestors = this.getAncestorsData(id, constants_1.COMBO_KEY);
        if (combo)
            this.pushChange({ value: combo, original: combo, type: constants_1.ChangeType.ComboUpdated });
        ancestors.forEach((value) => {
            this.pushChange({ value: value, original: value, type: constants_1.ChangeType.ComboUpdated });
        });
    }
    /**
     * <zh/> 将 combo 数据同步到 model 中
     *
     * <en/> Synchronize combo data to the model
     * @param datum - <zh/> combo 数据 | <en/> combo data
     */
    syncComboDatum(datum) {
        const { model } = this;
        const id = (0, id_1.idOf)(datum);
        const original = (0, graphlib_2.toG6Data)(model.getNode(id));
        const value = (0, data_1.mergeElementsData)(original, datum);
        model.mergeNodeData(id, value);
    }
    getElementPosition(id) {
        const datum = this.getElementDataById(id);
        return (0, position_1.positionOf)(datum);
    }
    translateNodeBy(id, offset) {
        const curr = this.getElementPosition(id);
        const position = (0, vector_1.add)(curr, [...offset, 0].slice(0, 3));
        this.translateNodeTo(id, position);
    }
    translateNodeTo(id, position) {
        const [x = 0, y = 0, z = 0] = position;
        this.preventUpdateNodeLikeHierarchy(() => {
            this.updateNodeData([{ id, style: { x, y, z } }]);
        });
    }
    translateComboBy(id, offset) {
        const [dx = 0, dy = 0, dz = 0] = offset;
        if ([dx, dy, dz].some(isNaN) || [dx, dy, dz].every((o) => o === 0))
            return;
        const combo = this.getComboData([id])[0];
        if (!combo)
            return;
        (0, traverse_1.dfs)(combo, (succeed) => {
            const succeedID = (0, id_1.idOf)(succeed);
            const [x, y, z] = (0, position_1.positionOf)(succeed);
            const value = (0, data_1.mergeElementsData)(succeed, {
                style: { x: x + dx, y: y + dy, z: z + dz },
            });
            this.pushChange({
                value,
                // @ts-ignore
                original: succeed,
                type: this.isCombo(succeedID) ? constants_1.ChangeType.ComboUpdated : constants_1.ChangeType.NodeUpdated,
            });
            this.model.mergeNodeData(succeedID, value);
        }, (node) => this.getChildrenData((0, id_1.idOf)(node)), 'BT');
    }
    translateComboTo(id, position) {
        if (position.some(isNaN))
            return;
        const [tx = 0, ty = 0, tz = 0] = position;
        const combo = this.getComboData([id])?.[0];
        if (!combo)
            return;
        const [comboX, comboY, comboZ] = (0, position_1.positionOf)(combo);
        const dx = tx - comboX;
        const dy = ty - comboY;
        const dz = tz - comboZ;
        (0, traverse_1.dfs)(combo, (succeed) => {
            const succeedId = (0, id_1.idOf)(succeed);
            const [x, y, z] = (0, position_1.positionOf)(succeed);
            const value = (0, data_1.mergeElementsData)(succeed, {
                style: { x: x + dx, y: y + dy, z: z + dz },
            });
            this.pushChange({
                value,
                // @ts-ignore
                original: succeed,
                type: this.isCombo(succeedId) ? constants_1.ChangeType.ComboUpdated : constants_1.ChangeType.NodeUpdated,
            });
            this.model.mergeNodeData(succeedId, value);
        }, (node) => this.getChildrenData((0, id_1.idOf)(node)), 'BT');
    }
    removeData(data) {
        const { nodes, edges, combos } = data;
        this.batch(() => {
            // remove edges first
            this.removeEdgeData(edges);
            this.removeNodeData(nodes);
            this.removeComboData(combos);
            this.latestRemovedComboIds = new Set(combos);
        });
    }
    removeNodeData(ids = []) {
        if (!ids.length)
            return;
        this.batch(() => {
            ids.forEach((id) => {
                // 移除关联边、子节点
                // remove related edges and child nodes
                this.removeEdgeData(this.getRelatedEdgesData(id).map(id_1.idOf));
                // TODO 树图情况下移除子节点
                this.pushChange({ value: this.getNodeData([id])[0], type: constants_1.ChangeType.NodeRemoved });
                this.removeNodeLikeHierarchy(id);
            });
            this.model.removeNodes(ids);
        });
    }
    removeEdgeData(ids = []) {
        if (!ids.length)
            return;
        ids.forEach((id) => this.pushChange({ value: this.getEdgeData([id])[0], type: constants_1.ChangeType.EdgeRemoved }));
        this.model.removeEdges(ids);
    }
    removeComboData(ids = []) {
        if (!ids.length)
            return;
        this.batch(() => {
            ids.forEach((id) => {
                this.pushChange({ value: this.getComboData([id])[0], type: constants_1.ChangeType.ComboRemoved });
                this.removeNodeLikeHierarchy(id);
                this.comboIds.delete(id);
            });
            this.model.removeNodes(ids);
        });
    }
    /**
     * <zh/> 移除节点层次结构，将其子节点移动到父节点的 children 列表中
     *
     * <en/> Remove the node hierarchy and move its child nodes to the parent node's children list
     * @param id - <zh/> 待处理的节点 | <en/> node to be processed
     */
    removeNodeLikeHierarchy(id) {
        if (this.model.hasTreeStructure(constants_1.COMBO_KEY)) {
            const grandParent = (0, id_1.parentIdOf)(this.getNodeLikeDatum(id));
            // 从父节点的 children 列表中移除
            // remove from its parent's children list
            // 调用 graphlib.setParent，不需要更新数据
            this.setParent(id, undefined, constants_1.COMBO_KEY, false);
            // 将子节点移动到父节点的 children 列表中
            // move the children to the grandparent's children list
            this.model.getChildren(id, constants_1.COMBO_KEY).forEach((child) => {
                const childData = (0, graphlib_2.toG6Data)(child);
                const childId = (0, id_1.idOf)(childData);
                this.setParent((0, id_1.idOf)(childData), grandParent, constants_1.COMBO_KEY, false);
                const value = (0, data_1.mergeElementsData)(childData, {
                    id: (0, id_1.idOf)(childData),
                    combo: grandParent,
                });
                this.pushChange({
                    value,
                    original: childData,
                    type: this.isCombo(childId) ? constants_1.ChangeType.ComboUpdated : constants_1.ChangeType.NodeUpdated,
                });
                this.model.mergeNodeData((0, id_1.idOf)(childData), value);
            });
            if (!(0, util_1.isUndefined)(grandParent))
                this.refreshComboData(grandParent);
        }
    }
    /**
     * <zh/> 获取元素的类型
     *
     * <en/> Get the type of the element
     * @param id - <zh/> 元素 ID | <en/> ID of the element
     * @returns <zh/> 元素类型 | <en/> type of the element
     */
    getElementType(id) {
        if (this.model.hasNode(id)) {
            if (this.isCombo(id))
                return 'combo';
            return 'node';
        }
        if (this.model.hasEdge(id))
            return 'edge';
        throw new Error(`Unknown element type of id: ${id}`);
    }
    /**
     * <zh/> 计算元素置顶后的 zIndex
     *
     * <en/> Calculate the zIndex after the element is placed on top
     * @param id - <zh/> 元素 ID | <en/> ID of the element
     * @returns <zh/> zIndex | <en/> zIndex
     */
    getFrontZIndex(id) {
        const elementType = this.getElementType(id);
        let elementsToCompare = [];
        if (elementType === 'combo') {
            const ancestors = [id, ...this.getAncestorsData(id, constants_1.COMBO_KEY).map(id_1.idOf)];
            // 过滤掉以下 combo 不参与 zIndex 计算
            // - 未展开的 combo
            // - 当前 combo 及其祖先和后代
            // The following combos do not participate in zIndex calculation
            // - collapsed combo
            // - current combo and its ancestors and descendants
            elementsToCompare = this.getComboData().filter((combo) => {
                const comboId = (0, id_1.idOf)(combo);
                const comboAncestors = this.getAncestorsData(comboId, constants_1.COMBO_KEY);
                const comboAncestorIds = comboAncestors.map(id_1.idOf);
                return !comboAncestors.some(collapsibility_1.isCollapsed) && !ancestors.includes(comboId) && !comboAncestorIds.includes(comboId);
            });
        }
        else
            elementsToCompare = this.getNodeData().filter((node) => (0, id_1.idOf)(node) !== id);
        return Math.max(0, ...elementsToCompare.map(style_1.zIndexOf)) + 1;
    }
    destroy() {
        const { model } = this;
        const nodes = model.getAllNodes();
        const edges = model.getAllEdges();
        model.removeEdges(edges.map((edge) => edge.id));
        model.removeNodes(nodes.map((node) => node.id));
        // @ts-expect-error force delete
        this.context = {};
    }
}
exports.DataController = DataController;
//# sourceMappingURL=data.js.map
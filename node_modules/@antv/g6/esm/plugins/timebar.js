import { Timebar as TimebarComponent } from '@antv/component';
import { Canvas } from '@antv/g';
import { Renderer as CanvasRenderer } from '@antv/g-canvas';
import { isArray, isDate, isNumber } from '@antv/util';
import { idOf } from '../utils/id';
import { parsePadding } from '../utils/padding';
import { BasePlugin } from './base-plugin';
const prospectiveTimeKeys = ['timestamp', 'time', 'date', 'datetime'];
/**
 * <zh/> 时间组件
 *
 * <en/> Timebar
 */
export class Timebar extends BasePlugin {
    static defaultOptions = {
        position: 'bottom',
        enable: true,
        timebarType: 'time',
        className: 'g6-timebar',
        width: 450,
        height: 60,
        zIndex: 3,
        elementTypes: ['node'],
        padding: 10,
        mode: 'modify',
        getTime: (datum) => inferTime(datum, prospectiveTimeKeys, undefined),
        loop: false,
    };
    timebar;
    canvas;
    wrapper;
    originalData;
    get padding() {
        return parsePadding(this.options.padding);
    }
    constructor(context, options) {
        super(context, Object.assign({}, Timebar.defaultOptions, options));
        this.backup();
        this.upsertTimebar();
    }
    /**
     * <zh/> 播放
     *
     * <en/> Play
     */
    play() {
        this.timebar?.play();
    }
    /**
     * <zh/> 暂停
     *
     * <en/> Pause
     */
    pause() {
        this.timebar?.pause();
    }
    /**
     * <zh/> 前进
     *
     * <en/> Forward
     */
    forward() {
        this.timebar?.forward();
    }
    /**
     * <zh/> 后退
     *
     * <en/> Backward
     */
    backward() {
        this.timebar?.backward();
    }
    /**
     * <zh/> 重置
     *
     * <en/> Reset
     */
    reset() {
        this.timebar?.reset();
    }
    /**
     * <zh/> 更新时间条配置项
     *
     * <en/> Update timebar configuration options
     * @param options - <zh/> 配置项 | <en/> Options
     * @internal
     */
    update(options) {
        super.update(options);
        this.backup();
        Object.keys(options).forEach((key) => {
            switch (key) {
                case 'position':
                    this.upsertWrapper();
                    break;
                default:
                    this.upsertTimebar();
                    break;
            }
        });
    }
    /**
     * <zh/> 备份数据
     *
     * <en/> Backup data
     */
    backup() {
        this.originalData = shallowCopy(this.context.graph.getData());
    }
    upsertTimebar() {
        const { canvas } = this.context;
        const { onChange, timebarType, data, x, y, width, height, mode, ...restOptions } = this.options;
        const canvasSize = canvas.getSize();
        const [top] = this.padding;
        this.upsertCanvas().ready.then(() => {
            const style = {
                x: canvasSize[0] / 2 - width / 2,
                y: top,
                onChange: (value) => {
                    const range = (isArray(value) ? value : [value, value]).map((time) => isDate(time) ? time.getTime() : time);
                    if (this.options.mode === 'modify')
                        this.filterElements(range);
                    else
                        this.hiddenElements(range);
                    onChange?.(range);
                },
                ...restOptions,
                data: data.map((datum) => (isNumber(datum) ? { time: datum, value: 0 } : datum)),
                width,
                height,
                type: timebarType,
            };
            if (!this.timebar) {
                this.timebar = new TimebarComponent({ style });
                this.canvas?.appendChild(this.timebar);
            }
            else {
                this.timebar.update(style);
            }
        });
    }
    upsertWrapper() {
        if (!this.wrapper) {
            const wrapper = document.createElement('div');
            wrapper.style.position = 'absolute';
            this.wrapper = wrapper;
        }
        const { x, y, className, position } = this.options;
        if (className)
            this.wrapper.className = className;
        if (isNumber(x) || isNumber(y)) {
            Object.assign(this.wrapper.style, {
                left: `${x ?? 0}px`,
                top: `${y ?? 0}px`,
            });
        }
        else {
            Object.assign(this.wrapper.style, {
                [position === 'top' ? 'bottom' : 'top']: 'unset',
                [position === 'top' ? 'top' : 'bottom']: '0px',
            });
        }
        this.context.canvas.getContainer()?.appendChild(this.wrapper);
        return this.wrapper;
    }
    upsertCanvas() {
        const wrapper = this.upsertWrapper();
        if (this.canvas)
            return this.canvas;
        const { height } = this.options;
        const [width] = this.context.canvas.getSize();
        const [top, , bottom] = this.padding;
        this.canvas = new Canvas({
            container: wrapper,
            width,
            height: height + top + bottom,
            renderer: this.context.options.renderer?.('main') || new CanvasRenderer(),
            supportsMutipleCanvasesInOneContainer: true,
        });
        return this.canvas;
    }
    async filterElements(range) {
        if (!this.originalData)
            return;
        const { elementTypes, getTime } = this.options;
        const { graph, element } = this.context;
        const newData = shallowCopy(this.originalData);
        elementTypes.forEach((type) => {
            const key = `${type}s`;
            newData[key] = (this.originalData[key] || []).filter((datum) => {
                const time = getTime(datum);
                if (match(time, range))
                    return true;
                return false;
            });
        });
        const nodeLikeIds = [...newData.nodes, ...newData.combos].map((datum) => idOf(datum));
        newData.edges = newData.edges.filter((edge) => {
            const source = edge.source;
            const target = edge.target;
            return nodeLikeIds.includes(source) && nodeLikeIds.includes(target);
        });
        graph.setData(newData);
        await element.draw({ animation: false, silence: true })?.finished;
    }
    hiddenElements(range) {
        const { graph } = this.context;
        const { elementTypes, getTime } = this.options;
        const hideElementId = [];
        const showElementId = [];
        elementTypes.forEach((elementType) => {
            const key = `${elementType}s`;
            const elementData = this.originalData?.[key] || [];
            elementData.forEach((elementDatum) => {
                const id = idOf(elementDatum);
                const time = getTime(elementDatum);
                if (match(time, range))
                    showElementId.push(id);
                else
                    hideElementId.push(id);
            });
        });
        graph.hideElement(hideElementId, false);
        graph.showElement(showElementId, false);
    }
    /**
     * <zh/> 销毁时间条
     *
     * <en/> Destroy the timebar
     */
    destroy() {
        const { graph } = this.context;
        this.originalData && graph.setData({ ...this.originalData });
        this.timebar?.destroy();
        this.canvas?.destroy();
        this.wrapper?.remove();
        this.originalData = undefined;
        this.wrapper = undefined;
        this.timebar = undefined;
        this.canvas = undefined;
        super.destroy();
    }
}
const shallowCopy = (data) => {
    const { nodes = [], edges = [], combos = [] } = data;
    return {
        nodes: [...nodes],
        edges: [...edges],
        combos: [...combos],
    };
};
const match = (time, range) => {
    if (isNumber(range))
        return time === range;
    const [start, end] = range;
    return time >= start && time <= end;
};
const inferTime = (datum, optionsKeys, defaultValue) => {
    for (let i = 0; i < optionsKeys.length; i++) {
        const key = optionsKeys[i];
        const val = datum.data?.[key];
        if (val)
            return val;
    }
    return defaultValue;
};
//# sourceMappingURL=timebar.js.map
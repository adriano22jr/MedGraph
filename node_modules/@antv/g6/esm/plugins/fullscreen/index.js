import { Shortcut } from '../../utils/shortcut';
import { BasePlugin } from '../base-plugin';
/**
 * <zh/> 全屏
 *
 * <en/> Full screen
 */
export class Fullscreen extends BasePlugin {
    static defaultOptions = {
        trigger: {},
        autoFit: true,
    };
    shortcut;
    $el = this.context.canvas.getContainer();
    graphSize = [0, 0];
    constructor(context, options) {
        super(context, Object.assign({}, Fullscreen.defaultOptions, options));
        this.shortcut = new Shortcut(context.graph);
        this.bindEvents();
        this.$el.style.backgroundColor = this.context.graph.getBackground();
    }
    bindEvents() {
        this.unbindEvents();
        this.shortcut.unbindAll();
        const { request = [], exit = [] } = this.options.trigger;
        this.shortcut.bind(request, this.request);
        this.shortcut.bind(exit, this.exit);
        const events = ['webkitfullscreenchange', 'mozfullscreenchange', 'fullscreenchange', 'MSFullscreenChange'];
        events.forEach((eventName) => {
            document.addEventListener(eventName, this.onFullscreenChange, false);
        });
    }
    unbindEvents() {
        this.shortcut.unbindAll();
        const events = ['webkitfullscreenchange', 'mozfullscreenchange', 'fullscreenchange', 'MSFullscreenChange'];
        events.forEach((eventName) => {
            document.removeEventListener(eventName, this.onFullscreenChange, false);
        });
    }
    setGraphSize(fullScreen = true) {
        let width, height;
        if (fullScreen) {
            width = window.screen.width;
            height = window.screen.height;
            this.graphSize = this.context.graph.getSize();
        }
        else {
            [width, height] = this.graphSize;
        }
        this.context.graph.setSize(width, height);
        this.context.graph.render();
    }
    onFullscreenChange = () => {
        const isFull = !!document.fullscreenElement;
        if (this.options.autoFit)
            this.setGraphSize(isFull);
        if (isFull) {
            this.options.onEnter?.();
        }
        else {
            this.options.onExit?.();
        }
    };
    /**
     * <zh/> 请求全屏
     *
     * <en/> Request full screen
     */
    request() {
        if (document.fullscreenElement || !isFullscreenEnabled())
            return;
        this.$el.requestFullscreen().catch((err) => {
            console.debug(`Error attempting to enable full-screen: ${err.message} (${err.name})`);
        });
    }
    /**
     * <zh/> 退出全屏
     *
     * <en/> Exit full screen
     */
    exit() {
        if (!document.fullscreenElement)
            return;
        document.exitFullscreen();
    }
    /**
     * <zh/> 更新配置
     *
     * <en/> Update options
     * @param options - <zh/> 配置项 | <en/> Options
     * @internal
     */
    update(options) {
        this.unbindEvents();
        super.update(options);
        this.bindEvents();
    }
}
/**
 * <zh/> 判断是否支持全屏
 *
 * <en/> Determine whether full screen is enabled
 * @returns <zh/> 是否支持全屏 | <en/> Whether full screen is enabled
 */
function isFullscreenEnabled() {
    return (document.fullscreenEnabled ||
        // <zh/> 使用 Reflect 语法规避 ts 检查 | <en/> use Reflect to avoid ts checking
        Reflect.get(document, 'webkitFullscreenEnabled') ||
        Reflect.get(document, 'mozFullscreenEnabled') ||
        Reflect.get(document, 'msFullscreenEnabled'));
}
//# sourceMappingURL=index.js.map
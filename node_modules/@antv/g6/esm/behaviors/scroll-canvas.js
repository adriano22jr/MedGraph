import { isFunction, isObject } from '@antv/util';
import { CommonEvent } from '../constants';
import { Shortcut } from '../utils/shortcut';
import { BaseBehavior } from './base-behavior';
/**
 * <zh/> 滚动画布交互
 *
 * <en/> Scroll canvas behavior
 */
export class ScrollCanvas extends BaseBehavior {
    static defaultOptions = {
        enable: true,
        sensitivity: 1,
    };
    shortcut;
    constructor(context, options) {
        super(context, Object.assign({}, ScrollCanvas.defaultOptions, options));
        this.shortcut = new Shortcut(context.graph);
        this.bindEvents();
    }
    /**
     * <zh/> 更新配置
     *
     * <en/> Update options
     * @param options - <zh/> 配置项 | <en/> Options
     * @internal
     */
    update(options) {
        super.update(options);
        this.bindEvents();
    }
    bindEvents() {
        const { trigger } = this.options;
        this.shortcut.unbindAll();
        if (isObject(trigger)) {
            this.graphDom?.removeEventListener(CommonEvent.WHEEL, this.onWheel);
            const { up = [], down = [], left = [], right = [] } = trigger;
            this.shortcut.bind(up, (event) => this.scroll([0, -10], event));
            this.shortcut.bind(down, (event) => this.scroll([0, 10], event));
            this.shortcut.bind(left, (event) => this.scroll([-10, 0], event));
            this.shortcut.bind(right, (event) => this.scroll([10, 0], event));
        }
        else {
            /**
             * 这里必需在原生canvas上绑定wheel事件，参考：
             * https://g.antv.antgroup.com/api/event/faq#%E5%9C%A8-chrome-%E4%B8%AD%E7%A6%81%E6%AD%A2%E9%A1%B5%E9%9D%A2%E9%BB%98%E8%AE%A4%E6%BB%9A%E5%8A%A8%E8%A1%8C%E4%B8%BA
             */
            this.graphDom?.addEventListener(CommonEvent.WHEEL, this.onWheel, { passive: false });
        }
    }
    get graphDom() {
        return this.context.graph.getCanvas().getContextService().getDomElement();
    }
    onWheel = async (event) => {
        event.preventDefault();
        const diffX = event.deltaX;
        const diffY = event.deltaY;
        await this.scroll([-diffX, -diffY], event);
    };
    formatDisplacement([dx, dy]) {
        const { direction, sensitivity } = this.options;
        dx = dx * sensitivity;
        dy = dy * sensitivity;
        if (direction === 'x') {
            dy = 0;
        }
        else if (direction === 'y') {
            dx = 0;
        }
        return [dx, dy];
    }
    async scroll(value, event) {
        if (!this.validate(event))
            return;
        const { onFinish } = this.options;
        const graph = this.context.graph;
        const formattedValue = this.formatDisplacement(value);
        await graph.translateBy(formattedValue, false);
        onFinish?.();
    }
    validate(event) {
        if (this.destroyed)
            return false;
        const { enable } = this.options;
        if (isFunction(enable))
            return enable(event);
        return !!enable;
    }
    /**
     * <zh/> 销毁画布滚动
     *
     * <en/> Destroy the canvas scrolling
     */
    destroy() {
        this.shortcut.destroy();
        this.graphDom?.removeEventListener(CommonEvent.WHEEL, this.onWheel);
        super.destroy();
    }
}
//# sourceMappingURL=scroll-canvas.js.map
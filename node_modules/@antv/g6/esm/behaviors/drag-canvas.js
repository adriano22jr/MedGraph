import { isFunction, isObject } from '@antv/util';
import { CanvasEvent } from '../constants';
import { Shortcut } from '../utils/shortcut';
import { multiply } from '../utils/vector';
import { BaseBehavior } from './base-behavior';
/**
 * <zh/> 拖拽画布交互
 *
 * <en/> Drag canvas behavior
 */
export class DragCanvas extends BaseBehavior {
    static defaultOptions = {
        enable: true,
        sensitivity: 10,
    };
    shortcut;
    defaultCursor;
    constructor(context, options) {
        super(context, Object.assign({}, DragCanvas.defaultOptions, options));
        this.shortcut = new Shortcut(context.graph);
        this.bindEvents();
        this.defaultCursor = this.context.canvas.getConfig().cursor || 'default';
        context.canvas.setCursor('grab');
    }
    /**
     * <zh/> 更新配置
     *
     * <en/> Update options
     * @param options - <zh/> 配置项 | <en/> Options
     * @internal
     */
    update(options) {
        this.unbindEvents();
        super.update(options);
        this.bindEvents();
    }
    bindEvents() {
        const { trigger } = this.options;
        const { graph } = this.context;
        if (isObject(trigger)) {
            graph.off(CanvasEvent.DRAG, this.onDrag);
            const { up = [], down = [], left = [], right = [] } = trigger;
            this.shortcut.bind(up, (event) => this.onTranslate([0, 1], event));
            this.shortcut.bind(down, (event) => this.onTranslate([0, -1], event));
            this.shortcut.bind(left, (event) => this.onTranslate([1, 0], event));
            this.shortcut.bind(right, (event) => this.onTranslate([-1, 0], event));
        }
        else {
            graph.on(CanvasEvent.DRAG, this.onDrag);
        }
    }
    onDrag = (event) => {
        if (!this.validate(event))
            return;
        if (event.targetType === 'canvas') {
            this.translate([event.movement.x, event.movement.y], false);
            this.options.onFinish?.();
        }
    };
    async onTranslate(value, event) {
        if (!this.validate(event))
            return;
        const { sensitivity } = this.options;
        const delta = sensitivity * -1;
        await this.translate(multiply(value, delta), this.options.animation);
        this.options.onFinish?.();
    }
    /**
     * <zh/> 平移画布
     *
     * <en/> Translate canvas
     * @param offset - <zh/> 平移距离 | <en/> Translation distance
     * @param animation - <zh/> 动画配置 | <en/> Animation configuration
     * @internal
     */
    async translate(offset, animation) {
        await this.context.graph.translateBy(offset, animation);
    }
    validate(event) {
        if (this.destroyed)
            return false;
        const { enable } = this.options;
        if (isFunction(enable))
            return enable(event);
        return !!enable;
    }
    unbindEvents() {
        this.shortcut.unbindAll();
        this.context.graph.off(CanvasEvent.DRAG, this.onDrag);
    }
    destroy() {
        this.shortcut.destroy();
        this.context.canvas.setCursor(this.defaultCursor);
        super.destroy();
    }
}
//# sourceMappingURL=drag-canvas.js.map
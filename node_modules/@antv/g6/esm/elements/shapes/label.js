import { Rect, Text } from '@antv/g';
import { parsePadding } from '../../utils/padding';
import { omitStyleProps, startsWith, subStyleProps } from '../../utils/prefix';
import { mergeOptions } from '../../utils/style';
import { BaseShape } from './base-shape';
export class Label extends BaseShape {
    static defaultStyleProps = {
        padding: 0,
        fontSize: 12,
        wordWrap: true,
        maxLines: 1,
        wordWrapWidth: 128,
        textOverflow: '...',
        textBaseline: 'middle',
        backgroundOpacity: 0.75,
        backgroundZIndex: -1,
        backgroundLineWidth: 0,
    };
    constructor(options) {
        super(mergeOptions({ style: Label.defaultStyleProps }, options));
    }
    isTextStyle(key) {
        return startsWith(key, 'label');
    }
    isBackgroundStyle(key) {
        return startsWith(key, 'background');
    }
    getTextStyle(attributes) {
        const { padding, ...style } = this.getGraphicStyle(attributes);
        return omitStyleProps(style, 'background');
    }
    getBackgroundStyle(attributes) {
        if (attributes.background === false)
            return false;
        const style = this.getGraphicStyle(attributes);
        const { wordWrap, wordWrapWidth, padding } = style;
        const backgroundStyle = subStyleProps(style, 'background');
        const { min: [minX, minY], center: [centerX, centerY], halfExtents: [halfWidth, halfHeight], } = this.shapeMap.text.getGeometryBounds();
        const [top, right, bottom, left] = parsePadding(padding);
        const totalWidth = halfWidth * 2 + left + right;
        const { width, height } = backgroundStyle;
        if (width && height) {
            Object.assign(backgroundStyle, { x: centerX - Number(width) / 2, y: centerY - Number(height) / 2 });
        }
        else {
            Object.assign(backgroundStyle, {
                x: minX - left,
                y: minY - top,
                width: wordWrap ? Math.min(totalWidth, wordWrapWidth) : totalWidth,
                height: halfHeight * 2 + top + bottom,
            });
        }
        // parse percentage radius
        const { radius } = backgroundStyle;
        // if radius look like '10%', convert it to number
        if (typeof radius === 'string' && radius.endsWith('%')) {
            const percentage = Number(radius.replace('%', '')) / 100;
            backgroundStyle.radius = Math.min(+backgroundStyle.width, +backgroundStyle.height) * percentage;
        }
        return backgroundStyle;
    }
    render(attributes = this.parsedAttributes, container = this) {
        this.upsert('text', Text, this.getTextStyle(attributes), container);
        this.upsert('background', Rect, this.getBackgroundStyle(attributes), container);
    }
    getGeometryBounds() {
        const shape = this.getShape('background') || this.getShape('text');
        return shape.getGeometryBounds();
    }
}
//# sourceMappingURL=label.js.map
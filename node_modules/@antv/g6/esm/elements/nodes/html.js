import { FederatedPointerEvent, HTML as GHTML, Rect, } from '@antv/g';
import { isNil, isUndefined, pick } from '@antv/util';
import { CommonEvent } from '../../constants';
import { BaseNode } from './base-node';
/**
 * <zh/> HTML 节点
 *
 * <en/> HTML node
 * @see https://github.com/antvis/G/blob/next/packages/g/src/plugins/EventPlugin.ts
 */
export class HTML extends BaseNode {
    static defaultStyleProps = {
        size: [160, 80],
        halo: false,
        icon: false,
        label: false,
        pointerEvents: 'auto',
    };
    constructor(options) {
        super({ ...options, style: Object.assign({}, HTML.defaultStyleProps, options.style) });
    }
    rootPointerEvent = new FederatedPointerEvent(null);
    get eventService() {
        return this.attributes.context.canvas.context.eventService;
    }
    get events() {
        return [
            CommonEvent.CLICK,
            CommonEvent.POINTER_DOWN,
            CommonEvent.POINTER_MOVE,
            CommonEvent.POINTER_UP,
            CommonEvent.POINTER_OVER,
            CommonEvent.POINTER_LEAVE,
        ];
    }
    getDomElement() {
        return this.getShape('key').getDomElement();
    }
    getKeyStyle(attributes) {
        const style = pick(attributes, ['innerHTML', 'pointerEvents', 'cursor']);
        const [width, height] = this.getSize(attributes);
        return { ...style, width, height };
    }
    drawKeyShape(attributes, container) {
        const style = this.getKeyStyle(attributes);
        const { width = 0, height = 0 } = style;
        const bounds = this.upsert('key-container', Rect, { width, height, opacity: 0 }, container);
        return this.upsert('key', GHTML, style, bounds);
    }
    connectedCallback() {
        const element = this.getDomElement();
        this.events.forEach((eventName) => {
            // @ts-expect-error assert event is PointerEvent
            element.addEventListener(eventName, this.forwardEvents);
        });
    }
    attributeChangedCallback(name, oldValue, newValue) {
        if (name === 'zIndex' && oldValue !== newValue) {
            this.getDomElement().style.zIndex = newValue;
        }
    }
    destroy() {
        const element = this.getDomElement();
        this.events.forEach((eventName) => {
            // @ts-expect-error assert event is PointerEvent
            element.removeEventListener(eventName, this.forwardEvents);
        });
        super.destroy();
    }
    forwardEvents = (nativeEvent) => {
        const canvas = this.attributes.context.canvas.main;
        const iCanvas = canvas.context.renderingContext.root.ownerDocument.defaultView;
        const normalizedEvents = this.normalizeToPointerEvent(nativeEvent, iCanvas);
        normalizedEvents.forEach((normalizedEvent) => {
            const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvent, iCanvas, nativeEvent);
            canvas.context.eventService.mapEvent(event);
        });
    };
    normalizeToPointerEvent(event, canvas) {
        const normalizedEvents = [];
        if (canvas.isTouchEvent(event)) {
            for (let i = 0; i < event.changedTouches.length; i++) {
                const touch = event.changedTouches[i];
                // use changedTouches instead of touches since touchend has no touches
                // @see https://stackoverflow.com/a/10079076
                if (isUndefined(touch.button))
                    touch.button = 0;
                if (isUndefined(touch.buttons))
                    touch.buttons = 1;
                if (isUndefined(touch.isPrimary)) {
                    touch.isPrimary = event.touches.length === 1 && event.type === 'touchstart';
                }
                if (isUndefined(touch.width))
                    touch.width = touch.radiusX || 1;
                if (isUndefined(touch.height))
                    touch.height = touch.radiusY || 1;
                if (isUndefined(touch.tiltX))
                    touch.tiltX = 0;
                if (isUndefined(touch.tiltY))
                    touch.tiltY = 0;
                if (isUndefined(touch.pointerType))
                    touch.pointerType = 'touch';
                // @see https://developer.mozilla.org/zh-CN/docs/Web/API/Touch/identifier
                if (isUndefined(touch.pointerId))
                    touch.pointerId = touch.identifier || 0;
                if (isUndefined(touch.pressure))
                    touch.pressure = touch.force || 0.5;
                if (isUndefined(touch.twist))
                    touch.twist = 0;
                if (isUndefined(touch.tangentialPressure))
                    touch.tangentialPressure = 0;
                touch.isNormalized = true;
                touch.type = event.type;
                normalizedEvents.push(touch);
            }
        }
        else if (canvas.isMouseEvent(event)) {
            const tempEvent = event;
            if (isUndefined(tempEvent.isPrimary))
                tempEvent.isPrimary = true;
            if (isUndefined(tempEvent.width))
                tempEvent.width = 1;
            if (isUndefined(tempEvent.height))
                tempEvent.height = 1;
            if (isUndefined(tempEvent.tiltX))
                tempEvent.tiltX = 0;
            if (isUndefined(tempEvent.tiltY))
                tempEvent.tiltY = 0;
            if (isUndefined(tempEvent.pointerType))
                tempEvent.pointerType = 'mouse';
            if (isUndefined(tempEvent.pointerId))
                tempEvent.pointerId = 1;
            if (isUndefined(tempEvent.pressure))
                tempEvent.pressure = 0.5;
            if (isUndefined(tempEvent.twist))
                tempEvent.twist = 0;
            if (isUndefined(tempEvent.tangentialPressure))
                tempEvent.tangentialPressure = 0;
            tempEvent.isNormalized = true;
            normalizedEvents.push(tempEvent);
        }
        else {
            normalizedEvents.push(event);
        }
        return normalizedEvents;
    }
    transferMouseData(event, nativeEvent) {
        event.isTrusted = nativeEvent.isTrusted;
        event.srcElement = nativeEvent.srcElement;
        event.timeStamp = performance.now();
        event.type = nativeEvent.type;
        event.altKey = nativeEvent.altKey;
        event.metaKey = nativeEvent.metaKey;
        event.shiftKey = nativeEvent.shiftKey;
        event.ctrlKey = nativeEvent.ctrlKey;
        event.button = nativeEvent.button;
        event.buttons = nativeEvent.buttons;
        event.client.x = nativeEvent.clientX;
        event.client.y = nativeEvent.clientY;
        event.movement.x = nativeEvent.movementX;
        event.movement.y = nativeEvent.movementY;
        event.page.x = nativeEvent.pageX;
        event.page.y = nativeEvent.pageY;
        event.screen.x = nativeEvent.screenX;
        event.screen.y = nativeEvent.screenY;
        event.relatedTarget = null;
    }
    bootstrapEvent(event, normalizedEvent, view, nativeEvent) {
        event.view = view;
        // @ts-ignore
        event.originalEvent = null;
        event.nativeEvent = nativeEvent;
        event.pointerId = normalizedEvent.pointerId;
        event.width = normalizedEvent.width;
        event.height = normalizedEvent.height;
        event.isPrimary = normalizedEvent.isPrimary;
        event.pointerType = normalizedEvent.pointerType;
        event.pressure = normalizedEvent.pressure;
        event.tangentialPressure = normalizedEvent.tangentialPressure;
        event.tiltX = normalizedEvent.tiltX;
        event.tiltY = normalizedEvent.tiltY;
        event.twist = normalizedEvent.twist;
        this.transferMouseData(event, normalizedEvent);
        const { x, y } = this.getViewportXY(normalizedEvent);
        event.viewport.x = x;
        event.viewport.y = y;
        const { x: canvasX, y: canvasY } = this.attributes.context.canvas.viewport2Canvas(event.viewport);
        event.canvas.x = canvasX;
        event.canvas.y = canvasY;
        event.global.copyFrom(event.canvas);
        event.offset.copyFrom(event.canvas);
        event.isTrusted = nativeEvent.isTrusted;
        if (event.type === 'pointerleave') {
            event.type = 'pointerout';
        }
        return event;
    }
    getViewportXY(nativeEvent) {
        let x;
        let y;
        const { offsetX, offsetY, clientX, clientY } = nativeEvent;
        if (this.attributes.context?.canvas.main.context.config.supportsCSSTransform &&
            !isNil(offsetX) &&
            !isNil(offsetY)) {
            x = offsetX;
            y = offsetY;
        }
        else {
            const point = this.eventService.client2Viewport({ x: clientX, y: clientY });
            x = point.x;
            y = point.y;
        }
        return { x, y };
    }
    onframe() {
        super.onframe();
        // sync opacity
        const { opacity } = this.attributes;
        this.getDomElement().style.opacity = `${opacity}`;
    }
}
//# sourceMappingURL=html.js.map
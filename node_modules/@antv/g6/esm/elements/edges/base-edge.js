import { Image, Path } from '@antv/g';
import { isFunction, pick } from '@antv/util';
import { getBBoxHeight, getBBoxWidth, getNodeBBox } from '../../utils/bbox';
import { getArrowSize, getBadgePositionStyle, getCubicLoopPath, getLabelPositionStyle } from '../../utils/edge';
import { findPorts, getConnectionPoint, isSameNode } from '../../utils/element';
import { omitStyleProps, subStyleProps } from '../../utils/prefix';
import { parseSize } from '../../utils/size';
import { mergeOptions } from '../../utils/style';
import * as Symbol from '../../utils/symbol';
import { getWordWrapWidthByEnds } from '../../utils/text';
import { BaseElement } from '../base-element';
import { Badge, Label } from '../shapes';
/**
 * <zh/> 边元素基类
 *
 * <en/> Base class of the edge
 */
export class BaseEdge extends BaseElement {
    type = 'edge';
    static defaultStyleProps = {
        badge: true,
        badgeOffsetX: 0,
        badgeOffsetY: 0,
        badgePlacement: 'suffix',
        isBillboard: true,
        label: true,
        labelAutoRotate: true,
        labelIsBillboard: true,
        labelMaxWidth: '80%',
        labelOffsetX: 4,
        labelOffsetY: 0,
        labelPlacement: 'center',
        labelTextBaseline: 'middle',
        labelWordWrap: false,
        halo: false,
        haloDroppable: false,
        haloLineDash: 0,
        haloLineWidth: 12,
        haloPointerEvents: 'none',
        haloStrokeOpacity: 0.25,
        haloZIndex: -1,
        loop: true,
        startArrow: false,
        startArrowLineDash: 0,
        startArrowLineJoin: 'round',
        startArrowLineWidth: 1,
        startArrowTransformOrigin: 'center',
        startArrowType: 'vee',
        endArrow: false,
        endArrowLineDash: 0,
        endArrowLineJoin: 'round',
        endArrowLineWidth: 1,
        endArrowTransformOrigin: 'center',
        endArrowType: 'vee',
        loopPlacement: 'top',
        loopClockwise: true,
    };
    constructor(options) {
        super(mergeOptions({ style: BaseEdge.defaultStyleProps }, options));
    }
    get sourceNode() {
        const { context, sourceNode: source } = this.parsedAttributes;
        return context.element.getElement(source);
    }
    get targetNode() {
        const { context, targetNode: target } = this.parsedAttributes;
        return context.element.getElement(target);
    }
    getKeyStyle(attributes) {
        const { loop, ...style } = this.getGraphicStyle(attributes);
        const { sourceNode, targetNode } = this;
        const d = loop && isSameNode(sourceNode, targetNode) ? this.getLoopPath(attributes) : this.getKeyPath(attributes);
        return {
            d,
            ...omitStyleProps(style, ['halo', 'label', 'startArrow', 'endArrow']),
        };
    }
    getLoopPath(attributes) {
        const { sourcePort, targetPort } = attributes;
        const node = this.sourceNode;
        const bbox = getNodeBBox(node);
        const defaultDist = Math.max(getBBoxWidth(bbox), getBBoxHeight(bbox));
        const { placement, clockwise, dist = defaultDist, } = subStyleProps(this.getGraphicStyle(attributes), 'loop');
        return getCubicLoopPath(node, placement, clockwise, dist, sourcePort, targetPort);
    }
    getEndpoints(attributes) {
        const { sourcePort: sourcePortKey, targetPort: targetPortKey } = attributes;
        const { sourceNode, targetNode } = this;
        const [sourcePort, targetPort] = findPorts(sourceNode, targetNode, sourcePortKey, targetPortKey);
        const sourcePoint = getConnectionPoint(sourcePort || sourceNode, targetPort || targetNode);
        const targetPoint = getConnectionPoint(targetPort || targetNode, sourcePort || sourceNode);
        return [sourcePoint, targetPoint];
    }
    getHaloStyle(attributes) {
        if (attributes.halo === false)
            return false;
        const keyStyle = this.getKeyStyle(attributes);
        const haloStyle = subStyleProps(this.getGraphicStyle(attributes), 'halo');
        return { ...keyStyle, ...haloStyle };
    }
    getLabelStyle(attributes) {
        if (attributes.label === false || !attributes.labelText)
            return false;
        const labelStyle = subStyleProps(this.getGraphicStyle(attributes), 'label');
        const { placement, offsetX, offsetY, autoRotate, maxWidth, ...restStyle } = labelStyle;
        const labelPositionStyle = getLabelPositionStyle(this.shapeMap.key, placement, autoRotate, offsetX, offsetY);
        const bbox = this.shapeMap.key.getLocalBounds();
        const wordWrapWidth = getWordWrapWidthByEnds([bbox.min, bbox.max], maxWidth);
        return Object.assign({ wordWrapWidth }, labelPositionStyle, restStyle);
    }
    getBadgeStyle(attributes) {
        if (attributes.badge === false || !attributes.badgeText)
            return false;
        const { offsetX, offsetY, placement, ...badgeStyle } = subStyleProps(attributes, 'badge');
        return Object.assign(badgeStyle, getBadgePositionStyle(this.shapeMap, placement, attributes.labelPlacement, offsetX, offsetY));
    }
    drawArrow(attributes, type) {
        const isStart = type === 'start';
        const arrowType = type === 'start' ? 'startArrow' : 'endArrow';
        const enable = attributes[arrowType];
        const keyShape = this.shapeMap.key;
        if (enable) {
            const arrowStyle = this.getArrowStyle(attributes, isStart);
            const [marker, markerOffset, arrowOffset] = isStart
                ? ['markerStart', 'markerStartOffset', 'startArrowOffset']
                : ['markerEnd', 'markerEndOffset', 'endArrowOffset'];
            const arrow = keyShape.parsedStyle[marker];
            // update
            if (arrow)
                arrow.attr(arrowStyle);
            // create
            else {
                const Ctor = arrowStyle.src ? Image : Path;
                const arrowShape = new Ctor({ style: arrowStyle });
                keyShape.style[marker] = arrowShape;
            }
            keyShape.style[markerOffset] = attributes[arrowOffset] || arrowStyle.width / 2 + +arrowStyle.lineWidth;
        }
        else {
            // destroy
            const marker = isStart ? 'markerStart' : 'markerEnd';
            keyShape.style[marker]?.destroy();
            keyShape.style[marker] = null;
        }
    }
    getArrowStyle(attributes, isStart) {
        const keyStyle = this.getShape('key').attributes;
        const arrowType = isStart ? 'startArrow' : 'endArrow';
        const { size, type, ...arrowStyle } = subStyleProps(this.getGraphicStyle(attributes), arrowType);
        const [width, height] = parseSize(getArrowSize(keyStyle.lineWidth, size));
        const arrowFn = isFunction(type) ? type : Symbol[type] || Symbol.triangle;
        const d = arrowFn(width, height);
        return Object.assign(pick(keyStyle, ['stroke', 'strokeOpacity', 'fillOpacity']), { width, height }, { ...(d && { d, fill: type === 'simple' ? '' : keyStyle.stroke }) }, arrowStyle);
    }
    drawLabelShape(attributes, container) {
        this.upsert('label', Label, this.getLabelStyle(attributes), container);
    }
    drawHaloShape(attributes, container) {
        this.upsert('halo', Path, this.getHaloStyle(attributes), container);
    }
    drawBadgeShape(attributes, container) {
        this.upsert('badge', Badge, this.getBadgeStyle(attributes), container);
    }
    drawKeyShape(attributes, container) {
        const key = this.upsert('key', Path, this.getKeyStyle(attributes), container);
        this.drawArrow(attributes, 'start');
        this.drawArrow(attributes, 'end');
        return key;
    }
    render(attributes = this.parsedAttributes, container = this) {
        // 1. key shape
        const keyShape = this.drawKeyShape(attributes, container);
        if (!keyShape)
            return;
        // 2. label
        this.drawLabelShape(attributes, container);
        // 3. halo
        this.drawHaloShape(attributes, container);
        // 4. badge
        this.drawBadgeShape(attributes, container);
    }
    onframe() {
        this.drawKeyShape(this.parsedAttributes, this);
        this.drawHaloShape(this.parsedAttributes, this);
        this.drawLabelShape(this.parsedAttributes, this);
        this.drawBadgeShape(this.parsedAttributes, this);
    }
    animate(keyframes, options) {
        const animation = super.animate(keyframes, options);
        if (!animation)
            return animation;
        // 设置 currentTime 时触发更新
        // Trigger update when setting currentTime
        return new Proxy(animation, {
            set: (target, propKey, value) => {
                // 需要推迟 onframe 调用时机，等待节点位置更新完成
                // Need to delay the timing of the onframe call, wait for the node position update to complete
                if (propKey === 'currentTime')
                    Promise.resolve().then(() => this.onframe());
                return Reflect.set(target, propKey, value);
            },
        });
    }
}
//# sourceMappingURL=base-edge.js.map